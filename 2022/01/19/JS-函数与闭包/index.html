<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Sunburst7">
    
    <title>
        
            JS深入学习(6)：函数与闭包 |
        
        Sunburst7&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/blog.svg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"sunburst7.github.io","root":"/","language":"en","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/希露菲.jpg","favicon":"/images/blog.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"遍履城山不求仙，独羇花月欲穷年，一罢掷杯秋泓饮，胜却青锋十三弦。"},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":false},"lazyload":{"enable":true},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/cat50.svg">
                </a>
            
            <a class="logo-title" href="/">
                Sunburst7&#39;s Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                时间线
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tag"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">时间线</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tag">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">JS深入学习(6)：函数与闭包</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/%E5%B8%8C%E9%9C%B2%E8%8F%B2.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Sunburst7</span>
                        
                            <span class="author-label">Lv3</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-01-19 11:00:22</span>
        <span class="mobile">2022-01-19 11:00</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/JavaScript/">JavaScript</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/JavaScript/">JavaScript</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/%E5%89%8D%E7%AB%AF/">前端</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>5.5k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>23 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>函数实际上是对象。每个函数都是 Function 类型的实例，而 Function 也有属性和方法，跟其他引用类型一样。因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定与函数本身紧密绑定。</p>
<p>函数有两种常见的定义方式：</p>
<ul>
<li><p>函数声明，注意函数定义最后没有加分号。：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>函数表达式</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>ES6中新增了箭头函数，使用胖箭头（=&gt;）语法定义函数表达式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种写法都有效</span></span><br><span class="line"><span class="keyword">let</span> double = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123; <span class="keyword">return</span> <span class="number">2</span> * x; &#125;;</span><br><span class="line"><span class="keyword">let</span> triple = <span class="function"><span class="params">x</span> =&gt;</span> &#123; <span class="keyword">return</span> <span class="number">3</span> * x; &#125;;</span><br><span class="line"><span class="comment">// 没有参数需要括号</span></span><br><span class="line"><span class="keyword">let</span> getRandom = <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> <span class="built_in">Math</span>.random(); &#125;;</span><br><span class="line"><span class="comment">// 多个参数需要括号</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="comment">// 无效的写法：</span></span><br><span class="line"><span class="keyword">let</span> multiply = a, <span class="function"><span class="params">b</span> =&gt;</span> &#123; <span class="keyword">return</span> a * b; &#125;;</span><br></pre></td></tr></table></figure>

<p>箭头函数虽然语法简洁，但也有很多场合不适用。箭头函数不能使用arguments、super 和 new.target，也不能用作构造函数。此外，箭头函数也没有prototype 属性。</p>
<h1 id="1-函数基础"><a href="#1-函数基础" class="headerlink" title="1 函数基础"></a>1 函数基础</h1><h2 id="1-1-函数名"><a href="#1-1-函数名" class="headerlink" title="1.1 函数名"></a>1.1 函数名</h2><p>函数名就是指向函数的指针，这意味着一个函数可以有多个名称：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherSum = sum;</span><br><span class="line"><span class="built_in">console</span>.log(anotherSum(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<p>ES6的所有函数对象都会暴露一个只读的 name 属性，其中包含关于函数的信息。</p>
<h2 id="1-2-函数参数"><a href="#1-2-函数参数" class="headerlink" title="1.2 函数参数"></a>1.2 函数参数</h2><p>ES函数既不关心传入的参数个数，也不关心这些参数的数据类型。定义函数时要接收两个参数，并不意味着调用时就传两个参数。你可以传一个、三个，甚至一个也不传，解释器都不会报错。</p>
<p>函数参数在内部表现为一个数组，函数被调用时总会接收一个数组，但函数并不关心这个数组中包含什么。，在使用<code>function</code>关键字定义（非箭头）函数时，可以在函数内部访问<code>arguments</code>对象，从中取得传进来的每个参数值。下面两个函数效果相同：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name, message</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name + <span class="string">&quot;, &quot;</span> + message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + <span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="string">&quot;, &quot;</span> + <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以通过<code>arguments</code>对象的<code>length</code>属性检查传入的参数个数。下面的例子展示了在每调用一个函数时，都会打印出传入的参数个数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="number">10</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">doAdd(<span class="number">10</span>); <span class="comment">// 20</span></span><br><span class="line">doAdd(<span class="number">30</span>, <span class="number">20</span>); <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>

<p>对于命名参数而言，如果调用函数时没有传这个参数，那么它的值就是undefined。</p>
<p><code>arguments</code>对象的另一个有意思的地方就是，它的值始终会与对应的命名参数同步。来看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] + num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>严格模式下，arguments 会有一些变化。首先，像前面那样给arguments[1]赋值不会再影响num2的值。就算把arguments[1]设置为10，num2 的值仍然还是传入的值。其次，在函数中尝试重写arguments 对象会导致语法错误。（代码也不会执行。）</p>
</blockquote>
<p>ES6支持函数默认参数传递，只要在函数定义中的参数后面用=就可以为参数赋一个默认值，箭头函数同样也可以这样使用默认参数，只不过在只有一个参数时，就必须使用括号而不能省略了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeKing</span>(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> VIII`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(makeKing(<span class="string">&#x27;Louis&#x27;</span>)); <span class="comment">// &#x27;King Louis VIII&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(makeKing()); <span class="comment">// &#x27;King Henry VIII&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> makeKing = <span class="function">(<span class="params">name = <span class="string">&#x27;Henry&#x27;</span></span>) =&gt;</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(makeKing()); <span class="comment">// King Henry</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-函数参数传递方式"><a href="#1-3-函数参数传递方式" class="headerlink" title="1.3 函数参数传递方式"></a>1.3 函数参数传递方式</h2><p>在《JavaScript高级程序设计》中有这么一句话：</p>
<blockquote>
<p>ECMAScript 中的所有参数都按值传递的。不可能按引用传递参数。如果把对象作为参数传递，那么传递的值就是这个对象的引用。</p>
</blockquote>
<p>这句话理解起来是有点问题的，让我们看两个例子：</p>
<ol>
<li><p>```js<br> var value = 1;<br> function foo(v) {</p>
<pre><code> v = 2;
 console.log(v); //2
</code></pre>
<p> }<br> foo(value);<br> console.log(value) // 1</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    这个例子说明前半句话没有问题，我们传入了一个 value 相当于拷贝了一个value的副本`_value`，这样对`_value`的修改不会影响value的值。</span><br><span class="line"></span><br><span class="line">2. ```js</span><br><span class="line">    var obj = &#123;</span><br><span class="line">        value: 1</span><br><span class="line">    &#125;;</span><br><span class="line">    function foo(o) &#123;</span><br><span class="line">        o = 2;// 修改对象的引用(指针)，指向一个number</span><br><span class="line">        console.log(o); //2</span><br><span class="line">    &#125;</span><br><span class="line">    foo(obj);</span><br><span class="line">    console.log(obj.value) // 1 </span><br></pre></td></tr></table></figure>

<p> 按照书中原话描述的：“如果把对象作为参数传递，那么传递的值就是这个对象的引用”。那么obj应该被改为了2啊。</p>
</li>
</ol>
<p><strong>出现这个现象的原因是，JS传递对象参数的方式遵循<code>call by sharing, copy the reference</code>，可以理解是共享传递。</strong>在传递对象的时候，传递对象的引用的副本。注意： 按引用传递是传递对象的引用，而按共享传递是传递对象的引用的副本(复制一个指针传递给函数)！</p>
<blockquote>
<p>The main point of this strategy is that function <strong>receives the copy of the reference to object.</strong> This reference copy is associated with the formal parameter and is its value.Regardless the fact that the concept of the reference in this case appears, this strategy should not be treated as call by reference (though, in this case the majority makes a mistake), <strong>because the value of the argument is not the direct alias, but the copy of the address.</strong></p>
<p>The main difference consists that assignment of a new value to argument inside the function does not affect object outside (as it would be in case of call by reference). However, because formal parameter, having an address copy, gets access to the same object that is outside (i.e. the object from the outside completely was not copied as would be in case of call by value), changes of properties of local argument object — are reflected in the external object.</p>
</blockquote>
<p>结合上面两个例子再分析下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    o.value = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(o.value); <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line">foo(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.value) <span class="comment">// 2 能成功修改</span></span><br></pre></td></tr></table></figure>

<p>其内存中的使用情况模拟：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/01/19/JS-%E5%87%BD%E6%95%B0%E4%B8%8E%E9%97%AD%E5%8C%85/image-20220119111631967.png"
                      class="" title="image-20220119111631967"
                >

<p><strong>引用类型把在内存中的地址复制给了函数中的局部变量。</strong>所以修改 o.value，可以通过引用找到原值，但是直接修改 o，并不会修改原值。所以第二个和第三个例子其实都是按共享传递。</p>
<p>总结：<strong>参数如果是基本类型是按值传递，如果是引用类型按共享传递。</strong></p>
<h2 id="1-4-函数扩展与收集"><a href="#1-4-函数扩展与收集" class="headerlink" title="1.4 函数扩展与收集"></a>1.4 函数扩展与收集</h2><p>ES6新增了扩展运算符(…)，扩展操作符最有用的场景就是函数定义中的参数列表，扩展操作符既可以用于调用函数时传参，也可以用于定义函数参数。</p>
<p><strong>扩展参数：</strong></p>
<p>在给函数传参时，有时候可能不需要传一个数组，而是要分别传入数组的元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; ++i) &#123;</span><br><span class="line">		sum += <span class="built_in">arguments</span>[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数希望将所有加数逐个传进来，然后通过迭代arguments 对象来实现累加。如果不使用扩展操作符，想把定义在这个函数这面的数组拆分，那么就得求助于<code>apply()</code>方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(getSum.apply(<span class="literal">null</span>, values)); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>而扩展操作符极为简洁地实现这种操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(getSum(...values)); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>因为数组的长度已知，所以在使用扩展操作符传参的时候，并不妨碍在其前面或后面再传其他的值，包括使用扩展操作符传其他参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line">&#125;</span><br><span class="line">countArguments(-<span class="number">1</span>, ...values); <span class="comment">// 5</span></span><br><span class="line">countArguments(...values, <span class="number">5</span>); <span class="comment">// 5</span></span><br><span class="line">countArguments(-<span class="number">1</span>, ...values, <span class="number">5</span>); <span class="comment">// 6</span></span><br><span class="line">countArguments(...values, ...[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<p>除了使用<code>arguments</code>操作元素，在普通函数和箭头函数中，也可以将扩展操作符用于命名参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProduct</span>(<span class="params">a, b, c = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a * b * c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getProduct(...[<span class="number">1</span>,<span class="number">2</span>])); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(getProduct(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(getProduct(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p><strong>收集参数：</strong></p>
<p>使用扩展操作符把不同长度的独立参数组合为一个Array实例。收集参数的前面如果还有命名参数，则只会收集其余的参数；如果没有则会得到空数组。因为收集参数的结果可变，所以<strong>只能把它作为最后一个参数</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可以</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProduct</span>(<span class="params">...values, lastValue</span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 可以</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ignoreFirst</span>(<span class="params">firstValue, ...values</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(values);</span><br><span class="line">&#125;</span><br><span class="line">ignoreFirst(); <span class="comment">// []</span></span><br><span class="line">ignoreFirst(<span class="number">1</span>); <span class="comment">// []</span></span><br><span class="line">ignoreFirst(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// [2]</span></span><br><span class="line">ignoreFirst(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure>

<p>箭头函数虽然不支持<code>arguments</code>对象，但支持收集参数的定义方式，因此也可以实现与使用<code>arguments</code> 一样的逻辑：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> getSum = <span class="function">(<span class="params">...values</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> values.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用收集参数与<code>arguments</code>互不影响。</p>
<h2 id="1-5-函数声明"><a href="#1-5-函数声明" class="headerlink" title="1.5 函数声明"></a>1.5 函数声明</h2><p>JavaScript 引擎在加载数据时对函数声明与函数表达式是区别对待的。之前学习执行上下文时说过，JavaScript 引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中生成函数定义。而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。</p>
<p><strong>函数声明提升（function declaration hoisting）</strong>：以下代码可以正常运行，因为函数声明会在任何代码执行之前先被读取并添加到执行上下文。这个过程叫作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没问题</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该段代码会出错：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会出错</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-6-函数表达式"><a href="#1-6-函数表达式" class="headerlink" title="1.6 函数表达式"></a>1.6 函数表达式</h2><p>我们知道，定义函数有两种方式：函数声明和函数表达式。函数声明的关键特点是<strong>函数声明提升</strong>，即函数声明会在代码执行之前获得定义。这意味着函数声明可以出现在调用它的代码之后。</p>
<p>第二种创建函数的方式就是函数表达式。最常见的形式是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> functionName = <span class="function"><span class="keyword">function</span>(<span class="params">arg0, arg1, arg2</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 函数体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>函数表达式看起来就像一个普通的变量定义和赋值，即创建一个函数再把它赋值给一个变量 functionName。这样创建的函数叫作<code>匿名函数（anonymous funtion）</code>。<strong>任何时候，只要函数被当作值来使用，它就是一个函数表达式。在下一节具体说明</strong></p>
<h2 id="1-7-函数作为值"><a href="#1-7-函数作为值" class="headerlink" title="1.7 函数作为值"></a>1.7 函数作为值</h2><p>因为函数名在ECMAScript 中就是变量（类似指针），所以函数可以用在任何可以使用变量的地方。这意味着不仅可以把函数作为参数传给另一个函数，而且还可以在一个函数中返回另一个函数。</p>
<p><strong>作为参数：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeFunction</span>(<span class="params">someFunction, someArgument</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> someFunction(someArgument);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add10</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result1 = callSomeFunction(add10, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>如果是函数作为参数传递(访问函数)而不是调用函数，那就必须不带括号，所以传给<code>callSomeFunction()</code>的必须是 add10 ，而不能是它们的执行结果。</p>
<p><strong>返回函数：</strong></p>
<p>例如，假设有一个包含对象的数组，而我们想按照任意对象属性对数组进行排序。为此，可以定义一个<code>sort()</code>方法需要的比较函数，它接收两个参数，即要比较的值。但这个比较函数还需要想办法确定根据哪个属性来排序。这个问题可以通过定义一个根据属性名来创建比较函数的函数来解决。比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">let</span> value1 = object1[propertyName];</span><br><span class="line">		<span class="keyword">let</span> value2 = object2[propertyName];</span><br><span class="line">		<span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用时</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">	&#123;<span class="attr">name</span>: <span class="string">&quot;Zachary&quot;</span>, <span class="attr">age</span>: <span class="number">28</span>&#125;,</span><br><span class="line">	&#123;<span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, <span class="attr">age</span>: <span class="number">29</span>&#125;</span><br><span class="line">];</span><br><span class="line">data.sort(createComparisonFunction(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(data[<span class="number">0</span>].name); <span class="comment">// Nicholas</span></span><br><span class="line">data.sort(createComparisonFunction(<span class="string">&quot;age&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(data[<span class="number">0</span>].name); <span class="comment">// Zachary</span></span><br></pre></td></tr></table></figure>

<h1 id="2-函数作为对象"><a href="#2-函数作为对象" class="headerlink" title="2 函数作为对象"></a>2 函数作为对象</h1><h2 id="2-1-函数内部对象"><a href="#2-1-函数内部对象" class="headerlink" title="2.1 函数内部对象"></a>2.1 函数内部对象</h2><p>在ECMAScript 5 中，函数内部存在两个特殊的对象：arguments 和this。ECMAScript 6 又新增了new.target 属性。</p>
<h3 id="2-1-1-arguments"><a href="#2-1-1-arguments" class="headerlink" title="2.1.1 arguments"></a>2.1.1 arguments</h3><p>之前讨论过，它是一个<strong>类数组对象</strong>，包含调用函数时传入的所有参数。这个对象只有以 function 关键字定义函数（相对于使用箭头语法创建函数）时才会有。</p>
<blockquote>
<p>所谓的类数组对象，可以理解为拥有多个属性和若干索引属性的对象，举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>];<span class="comment">//数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arrayLike = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">&#x27;age&#x27;</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">&#x27;sex&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;<span class="comment">//类数组|对象</span></span><br></pre></td></tr></table></figure>

<p>类数组对象在读写、获取长度、遍历的三个方面有类似于数组的性质：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读写</span></span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="number">0</span>]); <span class="comment">// name</span></span><br><span class="line"><span class="built_in">console</span>.log(arrayLike[<span class="number">0</span>]); <span class="comment">// name</span></span><br><span class="line"></span><br><span class="line">array[<span class="number">0</span>] = <span class="string">&#x27;new name&#x27;</span>;</span><br><span class="line">arrayLike[<span class="number">0</span>] = <span class="string">&#x27;new name&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取长度</span></span><br><span class="line"><span class="built_in">console</span>.log(array.length); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(arrayLike.length); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = array.length; i &lt; len; i++) &#123;</span><br><span class="line">   ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = arrayLike.length; i &lt; len; i++) &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用数组方法：</strong>类数组对象无法直接调用数组的方法，但我们可以用 Function.call 间接调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayLike = &#123;<span class="number">0</span>: <span class="string">&#x27;name&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;age&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;sex&#x27;</span>, <span class="attr">length</span>: <span class="number">3</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.join.call(arrayLike, <span class="string">&#x27;&amp;&#x27;</span>); <span class="comment">// name&amp;age&amp;sex</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(arrayLike, <span class="number">0</span>); <span class="comment">// [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] </span></span><br><span class="line"><span class="comment">// slice可以做到类数组转数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.map.call(arrayLike, <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item.toUpperCase();</span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">// [&quot;NAME&quot;, &quot;AGE&quot;, &quot;SEX&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>类数组对象转数组</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayLike = &#123;<span class="number">0</span>: <span class="string">&#x27;name&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;age&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;sex&#x27;</span>, <span class="attr">length</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="comment">// 1. slice</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(arrayLike); <span class="comment">// [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] </span></span><br><span class="line"><span class="comment">// 2. splice</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.splice.call(arrayLike, <span class="number">0</span>); <span class="comment">// [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] </span></span><br><span class="line"><span class="comment">// 3. ES6 Array.from</span></span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike); <span class="comment">// [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] </span></span><br><span class="line"><span class="comment">// 4. apply</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.concat.apply([], arrayLike)</span><br><span class="line"><span class="comment">// 5. ...</span></span><br><span class="line">...arrayLike</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Arguments 对象只定义在函数体中，包括了函数的参数和其他属性。在函数体中，arguments 指代该函数的 Arguments 对象。举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>打印结果如下：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/01/19/JS-%E5%87%BD%E6%95%B0%E4%B8%8E%E9%97%AD%E5%8C%85/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f617267756d656e74732e706e67.png"
                      class="" title="arguments"
                >

<p><code>arguments</code>对象还有一个<code>callee</code>属性，是一个指向<code>arguments</code>对象所在函数的指针。我们可以利用这个特性在递归函数中<strong>让函数逻辑与函数名解耦：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用<code>arguments</code>将参数从一个函数传递到另一个函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 apply 将 foo 的参数传递给 bar</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    bar.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-this"><a href="#2-1-2-this" class="headerlink" title="2.1.2 this"></a>2.1.2 this</h3><p>this并不属于一个对象的属性，而是在执行上下文中。在之前讨论过this的问题，不清楚可以回顾<a href="https://sunburst7.github.io/2022/01/16/JS-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/">JS深入学习(5)：执行上下文 | Sunburst7’s Blog</a>。在这里考察特殊情况：</p>
<p>在箭头函数中，this 引用的是定义箭头函数的上下文。下面的例子演示了这一点。o.sayColor作为Reference类型，其baseValue是global：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">	<span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> sayColor = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.color);</span><br><span class="line">sayColor(); <span class="comment">// &#x27;red&#x27;</span></span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor(); <span class="comment">// &#x27;red&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在事件回调或定时回调中调用某个函数时，this 值指向的并非想要的对象。此时将回调函数写成箭头函数就可以解决问题。这是因为<strong>箭头函数中的 this 会保留定义该函数时的上下文</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">King</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.royaltyName = <span class="string">&#x27;Henry&#x27;</span>;</span><br><span class="line">	<span class="comment">// this 引用King 的实例</span></span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.royaltyName), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.royaltyName = <span class="string">&#x27;Elizabeth&#x27;</span>;</span><br><span class="line">	<span class="comment">// this 引用window 对象</span></span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="built_in">this</span>.royaltyName); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> King(); <span class="comment">// Henry</span></span><br><span class="line"><span class="keyword">new</span> Queen(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-3-new-target"><a href="#2-1-3-new-target" class="headerlink" title="2.1.3 new.target"></a>2.1.3 new.target</h3><p>之前在<a href="https://sunburst7.github.io/2022/01/11/JS-%E5%AF%B9%E8%B1%A1/">JS深入学习(1)：对象与类初步 | Sunburst7’s Blog</a>中提到，ES中的函数始终可以作为构造函数实例化一个新对象，也可以作为普通函数被调用。ES6 新增了检测函数是否使用 new 关键字调用的<code>new.target</code>属性。</p>
<p>如果函数是正常调用的。则<code>new.target</code>的值是undefined；如果是使用 new 关键字调用的，则<code>new.target</code>将引用被调用的构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">King</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">new</span>.target) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="string">&#x27;King must be instantiated using &quot;new&quot;&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;King instantiated using &quot;new&quot;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> King(); <span class="comment">// King instantiated using &quot;new&quot;</span></span><br><span class="line">King(); <span class="comment">// Error: King must be instantiated using &quot;new&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-函数属性"><a href="#2-2-函数属性" class="headerlink" title="2.2 函数属性"></a>2.2 函数属性</h2><p>ECMAScript 中的函数是对象，因此有属性和方法。每个函数都有两个属性：<code>length</code>和<code>prototype</code>。</p>
<ul>
<li><p><code>length</code>属性保存函数定义的命名参数的个数：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sayName.length); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(sum.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(sayHi.length); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>prototype</code>保存着该函数（作为构造函数）的原型，<code>toString()、valueOf()</code>等方法实际上都保存在<code>prototype</code>上，进而由所有实例共享。<code>prototype</code>属性是不可枚举的，因此使用for-in 循环不会返回这个属性。</p>
</li>
</ul>
<h2 id="2-3-函数方法"><a href="#2-3-函数方法" class="headerlink" title="2.3 函数方法"></a>2.3 函数方法</h2><p><code>apply()和call()</code>。这两个方法都会以指定的 this 值来调用函数，即会设置调用函数时函数体内 this 对象的值。</p>
<ul>
<li><code>apply()</code>：方法接收两个参数：函数内 this 的值和一个参数数组。第二个参数可以是Array 的实例，但也可以是arguments 对象</li>
<li><code>call()</code>：方法第一个参数跟apply()一样，也是this值，而剩下的要传给被调用函数的参数则是逐个传递的。换句话说，通过call()向函数传参时，必须将参数一个一个地列出来</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sum.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 传入arguments 对象</span></span><br><span class="line">    <span class="comment">//return sum.apply(this, [num1, num2]); // 传入数组，效果相同</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sum.call(<span class="built_in">this</span>, num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(callSum1(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(callSum2(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<p><strong>apply()和call()真正强大的地方并不是给函数传参，而是控制函数调用上下文即函数体内this值的能力。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">	<span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayColor(); <span class="comment">// red</span></span><br><span class="line">sayColor.call(o); <span class="comment">// blue</span></span><br></pre></td></tr></table></figure>

<p>使用<code>call()</code>或<code>apply()</code>的好处是可以将任意对象设置为任意函数的作用域，这样对象可以不用关心方法。</p>
<p>ES5中定义了一个类似的方法：<code>bind()</code>。<code>bind()</code>方法会创建一个新的函数实例，其 this 值会被绑定到传给<code>bind()</code>的对象:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">	<span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> objectSayColor = sayColor.bind(o);</span><br><span class="line">objectSayColor(); <span class="comment">// blue</span></span><br></pre></td></tr></table></figure>

<h1 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3 闭包"></a>3 闭包</h1><p><strong>闭包（closure）指的是那些引用了另一个函数作用域中变量的函数</strong>，通常是在嵌套函数中实现的。比如，下面是之前展示的<code>createComparisonFunction()</code>函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">let</span> value1 = object1[propertyName];<span class="comment">//引用了外部函数的变量propertyName</span></span><br><span class="line">		<span class="keyword">let</span> value2 = object2[propertyName];<span class="comment">//引用了外部函数的变量propertyName</span></span><br><span class="line">		<span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>闭包的原理依赖于执行上下文，详情<a href="https://sunburst7.github.io/2022/01/16/JS-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/">JS深入学习(5)：执行上下文 | Sunburst7’s Blog</a>。在调用一个函数时，会为这个函数调用创建一个执行上下文，并创建一个作用域链。然后用 arguments 和其他命名参数来初始化这个函数的活动对象。外部函数的活动对象是内部函数作用域链上的第二个对象。这个作用域链一直向外串起了所有包含函数的活动对象，直到全局执行上下文才终止。</p>
<p>当一个函数执行完毕时，其执行上下文的作用域链会销毁，但它的<strong>活动对象</strong>仍然会保留在内存中供嵌套的函数的作用域链使用。</p>
<p>总结闭包的特点：</p>
<ol>
<li><p><strong>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</strong></p>
<p> 因为闭包会保留它们包含函数的作用域，所以比其他函数更占用内存。过度使用闭包可能导致内存过度占用</p>
</li>
<li><p><strong>在代码中引用了自由变量</strong></p>
</li>
</ol>
<p>以下两段代码为例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();<span class="comment">//3</span></span><br><span class="line">data[<span class="number">1</span>]();<span class="comment">//3</span></span><br><span class="line">data[<span class="number">2</span>]();<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//闭包写法</span></span><br><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">        		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           			<span class="built_in">console</span>.log(i);</span><br><span class="line">        		&#125;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]();</span><br></pre></td></tr></table></figure>

<p>第一段答案是都是 3，让我们分析一下原因：</p>
<p>当执行到 data[0] 函数之前，此时全局上下文的 VO 为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">globalContext = &#123;</span><br><span class="line">    VO: &#123;</span><br><span class="line">        data: [...],</span><br><span class="line">        i: 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当执行 data[0] 函数的时候，data[0] 函数的作用域链为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data[0]Context = &#123;</span><br><span class="line">    Scope: [AO, globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。data[1] 和 data[2] 是一样的道理。</p>
<p>重点关注第二段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">        		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            		<span class="built_in">console</span>.log(i);</span><br><span class="line">        		&#125;</span><br><span class="line">  &#125;)(i);<span class="comment">//立即调用函数，data[i]中保存的是该匿名函数的返回值，也就是另一个匿名函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]();</span><br></pre></td></tr></table></figure>

<p>当执行到 data[0] 函数之前，此时全局上下文的 VO 为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">globalContext = &#123;</span><br><span class="line">    VO: &#123;</span><br><span class="line">        data: [...],</span><br><span class="line">        i: 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟没改之前一模一样。当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data[0]Context = &#123;</span><br><span class="line">    Scope: [AO, 匿名函数Context.AO globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名函数执行上下文的AO为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">匿名函数Context = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            i: 0,</span><br><span class="line">            length: 1</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是0。data[1] 和 data[2] 是一样的道理。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>【1】JavaScript高级程序设计（第四版）</p>
<p>【2】<a class="link"   target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/10" >(1) JavaScript深入之参数按值传递 · Issue #10 · mqyqingfeng/Blog (github.com)<i class="fas fa-external-link-alt"></i></a></p>
<p>【3】<a class="link"   target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000005177386" >call by sharing——JavaScript中“共享传参”和“按值传参”的理解 - SegmentFault 思否<i class="fas fa-external-link-alt"></i></a></p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>Post title：JS深入学习(6)：函数与闭包</li>
        <li>Post author：Sunburst7</li>
        <li>Create time：2022-01-19 11:00:22</li>
        <li>
            Post link：https://sunburst7.github.io/2022/01/19/JS-函数与闭包/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/JavaScript/">#JavaScript</a>&nbsp;
                    </li>
                
                    <li class="tag-item">
                        <a href="/tags/%E5%89%8D%E7%AB%AF/">#前端</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2022/01/19/leetcode-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">leetcode(5)最长公共前缀</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2022/01/17/leetcode-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">leetcode(4)盛水最多的容器</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2021</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Sunburst7</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80"><span class="nav-text">1 函数基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E5%87%BD%E6%95%B0%E5%90%8D"><span class="nav-text">1.1 函数名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-text">1.2 函数参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F"><span class="nav-text">1.3 函数参数传递方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95%E4%B8%8E%E6%94%B6%E9%9B%86"><span class="nav-text">1.4 函数扩展与收集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="nav-text">1.5 函数声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">1.6 函数表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%80%BC"><span class="nav-text">1.7 函数作为值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%AF%B9%E8%B1%A1"><span class="nav-text">2 函数作为对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E5%AF%B9%E8%B1%A1"><span class="nav-text">2.1 函数内部对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-arguments"><span class="nav-text">2.1.1 arguments</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-this"><span class="nav-text">2.1.2 this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3-new-target"><span class="nav-text">2.1.3 new.target</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7"><span class="nav-text">2.2 函数属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95"><span class="nav-text">2.3 函数方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E9%97%AD%E5%8C%85"><span class="nav-text">3 闭包</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-text">参考</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/code-copy.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/lazyload.js"></script>


<div class="post-scripts">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/toc.js"></script>
    
</div>



</body>
</html>
