<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Sunburst7">
    
    <title>
        
            JS深入学习(20)：Promise的模拟实现 |
        
        Sunburst7&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/blog.svg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"sunburst7.github.io","root":"/","language":"en","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/希露菲.jpg","favicon":"/images/blog.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"遍履城山不求仙，独羇花月欲穷年，一罢掷杯秋泓饮，胜却青锋十三弦。"},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":false},"lazyload":{"enable":true},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/cat50.svg">
                </a>
            
            <a class="logo-title" href="/">
                Sunburst7&#39;s Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                时间线
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tag"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">时间线</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tag">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">JS深入学习(20)：Promise的模拟实现</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/%E5%B8%8C%E9%9C%B2%E8%8F%B2.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Sunburst7</span>
                        
                            <span class="author-label">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-02-08 15:24:04</span>
        <span class="mobile">2022-02-08 15:24</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/JavaScript/">JavaScript</a>&nbsp;
                    </li>
                
                    <li>
                        &gt; <a href="/categories/JavaScript/JS%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/">JS深入学习</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/JavaScript/">JavaScript</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/%E5%89%8D%E7%AB%AF/">前端</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/">模拟实现</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>17.1k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>79 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>本文<strong>转载</strong>一种尝试根据PromiseA+规范实现一个能通过所有Test case的Promise类。</p>
<ul>
<li>详细的PromiseA+规范在这里：<a class="link"   target="_blank" rel="noopener" href="https://promisesaplus.com/" >Promises/A+ (promisesaplus.com)<i class="fas fa-external-link-alt"></i></a></li>
<li>中文版：<a class="link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/wangjiachen666/p/11261091.html" >Promise A+ 规范【中文版】 - 难凉热血，码梦为生！ - 博客园 (cnblogs.com)<i class="fas fa-external-link-alt"></i></a></li>
<li>转载博客：<a class="link"   target="_blank" rel="noopener" href="https://github.com/yuanyuanbyte/Blog/issues/125" >JavaScript 深入系列之 Promise 核心原理的模拟实现，通过 Promises/A+ 官方872个测试用例 · Issue #125 · yuanyuanbyte/Blog (github.com)<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h1 id="一、定义初始结构"><a href="#一、定义初始结构" class="headerlink" title="一、定义初始结构"></a>一、定义初始结构</h1><p>原生的promise我们一般都会用new来创建实例 👇 ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>()</span><br></pre></td></tr></table></figure>

<p>所以我们手写的时候可以用构造函数或者class来创建，为了方便代码的整体观看就用class。把我们手写的Promise命名为myPromise，具体名字可以按自己想法，都可以</p>
<p>首先创建一个<code>myPromise</code>类</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在new一个promise实例的时候肯定是需要传入参数的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>不然这个实例用处不大；而这个参数我们知道是一个函数，并且当我们传入这个函数参数的时候，这个函数参数会自动执行。</p>
<p>因此，我们需要在类的<code>构造函数constructor</code>里面添加一个参数，这里就用func来做形参，并且执行一下这个参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">+    <span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">+       func();</span><br><span class="line">+   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、实现-resolve-和-reject"><a href="#二、实现-resolve-和-reject" class="headerlink" title="二、实现 resolve 和 reject"></a>二、实现 resolve 和 reject</h1><p>接下来，大家都知道需要为这个函数参数传入它自己的函数，也就是<code>resolve()</code>和<code>reject()</code></p>
<p>原生的promise里面可以传入<code>resolve</code>和<code>reject</code>两个参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>那么我们也得允许手写这边可以传入这两个参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">       func(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里这样写明显有一个问题 🤨，那就是手写这边不知道哪里调用<code>resolve()</code>和<code>reject()</code>这两个参数，毕竟<code>resolve()</code>和<code>reject()</code>还没有定义。因此就需要创造出这两个对象 😀</p>
<p>我们需要用<code>this</code>来调用自身<code>class</code>的方法，因此我们需要在构造函数里把两个参数前加上<code>this</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class myPromise &#123;</span><br><span class="line">    constructor(func) &#123;</span><br><span class="line">+       func(this.resolve, this.reject);</span><br><span class="line">    &#125;</span><br><span class="line">    resolve() &#123;&#125;</span><br><span class="line">    reject() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/02/08/JS-Promise%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f66376339666363306238356134326435393738616134373533313036653332632e706e67.png"
                      class=""
                >

<p>那么这里的<code>resolve()</code>和<code>reject()</code>方法应该如何执行呢？里面应该写什么内容呢？😯</p>
<p>这就需要用到状态了 😛</p>
<h2 id="1-管理状态和结果"><a href="#1-管理状态和结果" class="headerlink" title="1. 管理状态和结果"></a>1. 管理状态和结果</h2><p>promise有三种状态：分别是<code>pending</code>，<code>fulfilled</code>和<code>rejected</code></p>
<ul>
<li>初始的时候是<code>pending</code></li>
<li><code>pending</code>可以转为<code>fulfilled</code>状态，但是不能逆转</li>
<li><code>pending</code>也可以转为<code>rejected</code>状态，但是也不能逆转</li>
<li>这里<code>fulfilled</code>和<code>rejected</code>也不能互转</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/02/08/JS-Promise%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/image-20220208125915659.png"
                      class="" title="image-20220208125915659"
                >

<p>因此我们需要提前先把这些状态定义好，可以用<code>const</code>来创建外部的固定变量，但是这里为了统一就用<code>static</code>来创建<code>静态属性</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">+   <span class="keyword">static</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">+   <span class="keyword">static</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">+   <span class="keyword">static</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">        func(<span class="built_in">this</span>.resolve, <span class="built_in">this</span>.reject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">resolve</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="title">reject</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了状态属性以后，还需要为每一个实例添加一个<code>状态属性</code>，原生Promise用<code>PromiseState</code>这个字段来保存实例的状态属性，这里就也用 <code>this.PromiseState</code> 来保存实例的状态属性，这个状态属性默认就是 <code>待定pending</code> 状态，<strong>这样在每一个实例被创建以后就会有自身的状态属性可以进行判断和变动了</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">+       <span class="built_in">this</span>.PromiseState = myPromise.PENDING;</span><br><span class="line">        func(<span class="built_in">this</span>.resolve, <span class="built_in">this</span>.reject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">resolve</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="title">reject</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么在执行<code>resolve()</code>的时候就需要判断状态是否为 <code>待定 pending</code>，如果是 <code>待定 pending</code>的话就把状态改为 <code>成功 fulfilled</code>，<code>reject()</code>同理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.PromiseState = myPromise.PENDING;</span><br><span class="line">        func(<span class="built_in">this</span>.resolve, <span class="built_in">this</span>.reject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">resolve</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.PromiseState = myPromise.FULFILLED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">reject</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">+       <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">+           <span class="built_in">this</span>.PromiseState = myPromise.REJECT;</span><br><span class="line">+       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>◾ 执行 <code>resolve()</code> 和 <code>reject()</code> 可以传参</strong></p>
<p>现在我们再回忆一下原生<code>Promise</code> 🙂，在执行<code>resolve()</code>或者<code>reject()</code>的时候都是可以传入一个参数，这样我们后面就可以使用这个参数了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;这次一定&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我们可以把这个结果参数命名为<code>PromiseResult</code> *(和原生Promise保持一致)*，不管是成功还是拒绝的结果，两者选其一，我们让每个实例都有<code>PromiseResult</code>属性，并且给他们都赋值<code>null</code>，这里给空值<code>null</code>是因为执行<code>resolve()</code>或者<code>reject()</code>的时候会给结果赋值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.PromiseState = myPromise.PENDING;</span><br><span class="line">+       <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span>;</span><br><span class="line">        func(<span class="built_in">this</span>.resolve, <span class="built_in">this</span>.reject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">resolve</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.PromiseState = myPromise.FULFILLED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">reject</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.PromiseState = myPromise.REJECT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们就可以给<code>resolve()/reject()</code>添加参数，并且把参数赋值给实例的<code>PromiseResult</code>属性:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.PromiseState = myPromise.PENDING;</span><br><span class="line">        <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span>;</span><br><span class="line">        func(<span class="built_in">this</span>.resolve, <span class="built_in">this</span>.reject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">resolve</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.PromiseState = myPromise.FULFILLED;</span><br><span class="line">            <span class="built_in">this</span>.PromiseResult = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">+   <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.PromiseState = myPromise.REJECT;</span><br><span class="line">+           <span class="built_in">this</span>.PromiseResult = reason;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-this-指向问题"><a href="#2-this-指向问题" class="headerlink" title="2. this 指向问题"></a>2. this 指向问题</h2><p>现在的代码看起来风平浪静的，但很多人会在这里犯错~😥大家觉得这里有什么错误？🧐</p>
<p>我们来<code>new</code>一个实例 🌰 执行一下代码就知道有没有问题了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.PromiseState = myPromise.PENDING;</span><br><span class="line">        <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span>;</span><br><span class="line">        func(<span class="built_in">this</span>.resolve, <span class="built_in">this</span>.reject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">resolve</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.PromiseState = myPromise.FULFILLED;</span><br><span class="line">            <span class="built_in">this</span>.PromiseResult = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.PromiseState = myPromise.REJECT;</span><br><span class="line">            <span class="built_in">this</span>.PromiseResult = reason;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">+  <span class="keyword">let</span> promise1 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">+      resolve(<span class="string">&#x27;这次一定&#x27;</span>);</span><br><span class="line">+  &#125;)</span><br></pre></td></tr></table></figure>

<p>运行上面代码，报错 🦁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught TypeError: Cannot read property &#x27;PromiseState &#x27; of undefined</span><br></pre></td></tr></table></figure>

<p>可从报错的信息里面我们貌似发现不了有什么错误🤨，因为<code>PromiseState </code>属性我们已经创建了，不应该是<code>undefined</code>~</p>
<p>原作者的解释如下：</p>
<blockquote>
<p>🔍 但我们仔细看看<code>resolve()</code>和<code>reject()</code>方法里调用<code>PromiseState </code>，前面是有<code>this</code>关键字的😲</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    resolve(result) &#123;</span><br><span class="line">➡      if (this.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">➡          this.PromiseState = myPromise.FULFILLED;</span><br><span class="line">            this.PromiseResult = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reject(reason) &#123;</span><br><span class="line">➡      if (this.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">➡          this.PromiseState = myPromise.REJECT;</span><br><span class="line">            this.PromiseResult = reason;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>那么只有一种可能🧐，调用<code>this.PromiseState </code>的时候并没有调用<code>constructor</code>里的<code>this.PromiseState </code>，也就是这里的<code>this</code>已经跟丢了~</p>
<p>我们在<code>new</code>一个新实例的时候执行的是<code>constructor</code>里的内容，也就是<code>constructor</code>里的<code>this</code>确实是新实例的，但现在我们是在新实例被创建后再在外部环境下执行<code>resolve()</code>方法的，这里的<code>resolve()</code>看着像是和实例一起执行的，其实不然，也就<strong>相当于不在<code>class</code>内部使用这个<code>this</code><strong>，而</strong>我们没有在外部定义任何<code>PromiseState </code>变量，因此这里会报错</strong></p>
</blockquote>
<p>我觉得可以这样解释，因为func声明的时候是用箭头函数声明，而箭头函数的作用域指向父作用域，也就是全局作用域，而全局中没有promiseState变量，因此会报undefined。</p>
<p>解决<code>class</code>的<code>this</code>指向问题一般会用箭头函数或者<code>bind</code>，在这里我们就可以使用<code>bind</code>来绑定<code>this</code>，只需要在构造函数<code>constructor</code>中的<code>this.resolve</code>和<code>this.reject</code>后加上，<code>.bind（this）</code>就可以了 😺:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.PromiseState = myPromise.PENDING;</span><br><span class="line">        <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span>;</span><br><span class="line">+       func(<span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>));</span><br><span class="line">        <span class="comment">// 或者将resolve与reject定义在constructor中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">resolve</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.PromiseState = myPromise.FULFILLED;</span><br><span class="line">            <span class="built_in">this</span>.PromiseResult  = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.PromiseState = myPromise.REJECT;</span><br><span class="line">            <span class="built_in">this</span>.PromiseResult = reason;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;这次一定&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>对于<code>resolve/reject</code>来说，这里就是给实例的<code>resolve()/reject()</code>方法绑定这个<code>this</code>为当前的实例对象，并且执行<code>this.resolve()</code>方法：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/02/08/JS-Promise%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/image-20220208130830983.png"
                      class="" title="image-20220208130830983"
                >

<p>咱们来测试一下代码吧：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.PromiseState = myPromise.PENDING;</span><br><span class="line">        <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span>;</span><br><span class="line">        func(<span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">resolve</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.PromiseState = myPromise.FULFILLED;</span><br><span class="line">            <span class="built_in">this</span>.PromiseResult = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.PromiseState = myPromise.REJECTED;</span><br><span class="line">            <span class="built_in">this</span>.PromiseResult = reason;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;这次一定&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(promise1); </span><br><span class="line"><span class="comment">// myPromise &#123;PromiseState: &#x27;fulfilled&#x27;, PromiseResult: &#x27;这次一定&#x27;&#125;</span></span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">&#x27;下次一定&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(promise2); </span><br><span class="line"><span class="comment">// myPromise &#123;PromiseState: &#x27;rejected&#x27;, PromiseResult: &#x27;下次一定&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面是我们手写的 <code>myPromise</code>的执行情况，看看原生Promise的执行情况：</p>
<p>说明执行结果符合我们的预期，是不是觉得离成功又进了一步啦~ 👏👏👏</p>
<p>那么大家觉得下一步我们要做什么？是不是很多同学觉得需要写<code>then</code>了？那么我们就先来满足想要写<code>then</code>的同学们~</p>
<h1 id="三、实现-then-方法"><a href="#三、实现-then-方法" class="headerlink" title="三、实现 then 方法"></a>三、实现 then 方法</h1><p><strong>因为<code>then</code>是在创建实例后再进行调用的，因此我们再创建一个类方法，可千万不要创建在 <code>constructor</code> 里面了~😛</strong></p>
<p><code>then</code>方法可以传入两个参数，这两个参数都是函数，一个是当状态为<code>fulfilled 成功</code> 时执行的代码，另一个是当状态为 <code>rejected 拒绝</code> 时执行的代码。</p>
<p>因此我们就可以先给手写的<code>then</code>里面添加 <strong>两个参数</strong>：</p>
<ul>
<li>一个是 <code>onFulfilled</code> 表示 <code>“当状态为成功时”</code></li>
<li>另一个是 <code>onRejected</code> 表示 <code>“当状态为拒绝时”</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.PromiseState = myPromise.PENDING;</span><br><span class="line">        <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span>;</span><br><span class="line">        func(<span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">resolve</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.PromiseState = myPromise.FULFILLED;</span><br><span class="line">            <span class="built_in">this</span>.PromiseResult = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.PromiseState = myPromise.REJECTED;</span><br><span class="line">            <span class="built_in">this</span>.PromiseResult = reason;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">+   <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-状态不可变"><a href="#1-状态不可变" class="headerlink" title="1. 状态不可变"></a>1. 状态不可变</h2><p>这里我们先看看<code>原生 Promise</code> 产生的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(&#x27;这次一定&#x27;)</span><br><span class="line">    reject(&#x27;下次一定&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(</span><br><span class="line">    result =&gt; &#123;</span><br><span class="line">        console.log(&#x27;fulfilled&#x27;, result);</span><br><span class="line">    &#125;,</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">        console.log(&#x27;rejected&#x27;, reason.message);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/02/08/JS-Promise%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/image-20220208132632981.png"
                      class="" title="image-20220208132632981"
                >

<p>可以看到控制台只显示了一个<code>console.log</code>的结果，<strong>证明 <code>Promise</code> 只会执行<code>成功状态</code> 或者 <code>拒绝状态</code> 的其中一个</strong></p>
<p>也就是我们前文讲到的，<code>Promise</code> 只以 <code>第一次为准</code>，第一次成功就<code>永久</code>为<code>fulfilled</code>，第一次失败就<code>永远</code>状态为<code>rejected</code></p>
<p>因此我们在手写的时候就必须进行判断 🤖：</p>
<p>◾ 如果当前实例的 <code>PromiseState</code> 状态属性为 <code>fulfilled 成功 </code>的话，我们就执行传进来的 <code>onFulfilled</code> 函数，并且为<code>onFulfilled</code>函数传入前面保留的<code>PromiseResult</code>属性值：</p>
<p>◾ 如果当前实例的 <code>PromiseState</code> 状态属性为 <code>rejected 拒绝</code> 的话，我们就执行传进来的 <code>onRejected</code> 函数，并且为<code>onRejected</code>函数传入前面保留的<code>PromiseResult</code>属性值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.PromiseState = myPromise.PENDING;</span><br><span class="line">        <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span>;</span><br><span class="line">        func(<span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">resolve</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.PromiseState = myPromise.FULFILLED;</span><br><span class="line">            <span class="built_in">this</span>.PromiseResult = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.PromiseState = myPromise.REJECTED;</span><br><span class="line">            <span class="built_in">this</span>.PromiseResult = reason;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myProise.FULFILLED) &#123;</span><br><span class="line">            onFulfilled(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.REJECTED) &#123;</span><br><span class="line">           onRejected(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义好了判断条件以后，我们就来测试一下代码，也是一样，在实例 🌰 上使用<code>then</code>方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.PromiseState = myPromise.PENDING;</span><br><span class="line">        <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span>;</span><br><span class="line">        func(<span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">resolve</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.PromiseState = myPromise.FULFILLED;</span><br><span class="line">            <span class="built_in">this</span>.PromiseResult = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.PromiseState = myPromise.REJECTED;</span><br><span class="line">            <span class="built_in">this</span>.PromiseResult = reason;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.FULFILLED) &#123;</span><br><span class="line">            onFulfilled(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.REJECTED) &#123;</span><br><span class="line">            onRejected(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;这次一定&#x27;</span>);</span><br><span class="line">    reject(<span class="string">&#x27;下次一定&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">promise1.then(</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(reason.message)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>执行上面的测试代码，查看控制台：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/02/08/JS-Promise%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/image-20220208132757532.png"
                      class="" title="image-20220208132757532"
                >

<p>可以看到控制台只显示了一个<code>console.log</code>的结果：<code>这次一定</code> 😎，证明我们已经实现了 <code>promise的状态不可变</code> 👏👏👏</p>
<h2 id="2-执行异常-throw"><a href="#2-执行异常-throw" class="headerlink" title="2. 执行异常 throw"></a>2. 执行异常 throw</h2><p>在<code>new Promise</code>的时候，执行函数里面如果抛出错误，是会触发<code>then</code>方法的第二个参数，即<code>rejected</code>状态的回调函数</p>
<p>也就是在原生的Promise里面，<code>then</code>方法的第二个参数，即<code>rejected</code>状态的回调函数可以把错误的信息作为内容输出出来</p>
<p>到这里，有的同学可能会说，执行异常抛错，不是用<code>catch()</code>方法去接吗？为什么这里又说 <code>是会触发then方法的第二个参数，即rejected状态的回调函数</code>？😵</p>
<p>那我们就说道说道吧🧐：</p>
<p><code>catch()</code> 方法返回一个<code>Promise</code>，并且处理拒绝的情况。它的行为与调用<code>Promise.prototype.then(undefined, onRejected)</code> 相同。我们显式使用<code>obj.catch(onRejected)</code>，内部实际调用的是<code>obj.then(undefined, onRejected)</code>)</p>
<p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>
<p>◾ 注意看下面的例子 🌰：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Error: test</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，promise抛出一个错误，就被<code>catch()</code>方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;test&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>比较上面两种写法，可以发现<code>reject()</code>方法的作用，等同于抛出错误。这一点很重要，因为我们手写Promise就是用<code>try/catch</code>来处理异常，用的就是上面的思想。</p>
<p>◾ <strong>一般来说，不要在<code>then()</code>方法里面定义 Reject 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123; <span class="comment">//cb</span></span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误，也更接近同步的写法（<code>try/catch</code>）。因此，建议总是使用<code>catch()</code>方法，而不使用<code>then()</code>方法的第二个参数。</p>
<p><strong>回到正题</strong></p>
<p>◾ 我们可以在执行<code>resolve()</code>和<code>reject()</code>之前用<code>try/catch</code>进行判断，在<code>构造函数 constructor</code>里面完善代码，判断生成实例的时候是否有报错 🔍：</p>
<ul>
<li>如果没有报错的话，就按照正常执行<code>resolve()</code>和<code>reject()</code>方法</li>
<li>如果报错的话，就把错误信息传入给<code>reject()</code>方法，并且直接执行<code>reject()</code>方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.PromiseState = myPromise.PENDING;</span><br><span class="line">        <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span>;</span><br><span class="line">+       <span class="keyword">try</span> &#123;</span><br><span class="line">            func(<span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>));</span><br><span class="line">+       &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">+           <span class="built_in">this</span>.reject(error)</span><br><span class="line">+       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">resolve</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.PromiseState = myPromise.FULFILLED;</span><br><span class="line">            <span class="built_in">this</span>.PromiseResult = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.PromiseState = myPromise.REJECTED;</span><br><span class="line">            <span class="built_in">this</span>.PromiseResult = reason;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.FULFILLED) &#123;</span><br><span class="line">            onFulfilled(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.REJECTED) &#123;</span><br><span class="line">            onRejected(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;白嫖不成功&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">promise1.then(</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;fulfiiled:&#x27;</span>, result)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;rejected:&#x27;</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>◾ <strong>注意这里不需要给<code>reject()</code>方法进行<code>this</code>的绑定了，因为这里是直接执行，而不是创建实例后再执行。</strong></p>
<p>◾ 这里考察了<code>this</code>绑定的一个细节🔍：<code>call</code>、<code>apply</code>和<code>bind</code>都可以改变函数体内部 this 的指向，<strong>但是 <code>bind</code> 和 <code>call/apply</code> 有一个很重要的区别：一个函数被 <code>call/apply</code> 的时候，会立即执行函数，但是 <code>bind</code> 会创建一个新函数，不会立即执行。</strong>这就是前面为什么说，<code> this.reject.bind(this)</code>只是作为参数，并没有直接执行的原因了~😀</p>
<p><strong>回到正文</strong></p>
<p>结合前面的讲解，刷新一下控制台，我们可以看到手写这边已经没有报错了👏👏👏:</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/03dddada3cba39cab4631fd454d48bd9d64b0dc24df8f009ac26f20246e4bd97/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f30363163383861623831366634623632383362366439646535666463326265372e706e67"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://camo.githubusercontent.com/03dddada3cba39cab4631fd454d48bd9d64b0dc24df8f009ac26f20246e4bd97/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f30363163383861623831366634623632383362366439646535666463326265372e706e67"
                      alt="在这里插入图片描述"
                ></a></p>
<h2 id="3-参数校验"><a href="#3-参数校验" class="headerlink" title="3. 参数校验"></a>3. 参数校验</h2><p>大家觉得目前代码是不是没问题了？可以进行下一步了？</p>
<p>如果你觉得是的话就又掉坑了~🦁</p>
<p>原生Promise里<strong>规定<code>then</code>方法里面的两个参数如果不是函数的话就要被忽略</strong>，我们就故意在原生代码这里不传入函数作为参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;白嫖不成功&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;rejected:&#x27;</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>运行以后我们发现在这里执行是没有问题的：</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/32ec82d71001e1eec390dbb212a6f654543565a8f639edd905731caafcd4e8a8/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f30306535653966383835383434316239383835633366353964306161326633382e706e67"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://camo.githubusercontent.com/32ec82d71001e1eec390dbb212a6f654543565a8f639edd905731caafcd4e8a8/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f30306535653966383835383434316239383835633366353964306161326633382e706e67"
                      alt="在这里插入图片描述"
                ></a></p>
<p>我们再以同样类似的不传 <strong>函数参数</strong> 的代码应用在 <strong>手写代码</strong> 上面：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;这次一定&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise1.then(</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;rejected:&#x27;</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>大家想想会不会有什么问题？来看看结果会怎样？🧐</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/bd637667e0aba736981044b19cd3b032957de41f438f67c1b08ea7a23f43b879/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32333230333231633264303734333631623239643037396631653334383461342e706e67"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://camo.githubusercontent.com/bd637667e0aba736981044b19cd3b032957de41f438f67c1b08ea7a23f43b879/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32333230333231633264303734333631623239643037396631653334383461342e706e67"
                      alt="在这里插入图片描述"
                ></a></p>
<p>结果就是 <code>Uncaught TypeError: onFulfilled is not a function</code>。浏览器帮你报错了，这不是我们想要的~😥</p>
<p>我们只想要自己来抛出错误，再来看看刚刚的手写<code>then</code>部分：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.FULFILLED) &#123;</span><br><span class="line">        onFulfilled(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.REJECTED) &#123;</span><br><span class="line">        onRejected(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会在里面分别执行成功和拒绝两个参数，可是我们不想修改这里的代码，那么就只能把不是函数的参数改为函数</p>
<p><strong><code>Promise</code> 规范如果 <code>onFulfilled</code> 和 <code>onRejected</code> 不是函数，就忽略他们，所谓“忽略”并不是什么都不干，对于<code>onFulfilled</code>来说“忽略”就是将<code>value</code>原封不动的返回，对于<code>onRejected</code>来说就是返回<code>reason</code>，<code>onRejected</code>因为是错误分支，我们返回<code>reason</code>应该<code>throw</code>一个<code>Error</code>:</strong></p>
<p>这里我们就可以用 <code>条件运算符</code>，我们在进行<code>if</code>判断之前进行预先判断：</p>
<p>▪ 如果<code>onFulfilled</code>参数是一个函数，就把原来的<code>onFulfilled</code>内容重新赋值给它，如果<code>onFulfilled</code>参数不是一个函数，就将<code>value</code>原封不动的返回</p>
<p>▪ 如果<code>onRejected</code>参数是一个函数，就把原来的<code>onRejected</code>内容重新赋值给它，如果<code>onRejected</code>参数不是一个函数，就<code>throw</code>一个<code>Error</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">+       onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">+       onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.FULFILLED) &#123;</span><br><span class="line">            onFulfilled(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.REJECTED) &#123;</span><br><span class="line">            onRejected(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;这次一定&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">promise1.then(</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;rejected:&#x27;</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>查看控制台，发现没有报错了👏👏👏：</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/cb94ec427bf9114195ae2e4d5613fc6f17d6a1db11f0c0288b3837716891eb63/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f30386365636566373961306634373437393866326433363262663432383464302e706e67"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://camo.githubusercontent.com/cb94ec427bf9114195ae2e4d5613fc6f17d6a1db11f0c0288b3837716891eb63/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f30386365636566373961306634373437393866326433363262663432383464302e706e67"
                      alt="在这里插入图片描述"
                ></a></p>
<p><strong>当前实现的完整代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.PromiseState = myPromise.PENDING;</span><br><span class="line">        <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            func(<span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="built_in">this</span>.reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">resolve</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.PromiseState = myPromise.FULFILLED;</span><br><span class="line">            <span class="built_in">this</span>.PromiseResult = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.PromiseState = myPromise.REJECTED;</span><br><span class="line">            <span class="built_in">this</span>.PromiseResult = reason;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.FULFILLED) &#123;</span><br><span class="line">            onFulfilled(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.REJECTED) &#123;</span><br><span class="line">            onRejected(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、实现异步"><a href="#四、实现异步" class="headerlink" title="四、实现异步"></a>四、实现异步</h1><h2 id="1-添加定时器"><a href="#1-添加定时器" class="headerlink" title="1. 添加定时器"></a>1. 添加定时器</h2><p>在对代码进行一些基本修补以后，我们就可以来进行下一个大功能了，也就是Promise的 <strong>异步功能</strong> ✨。</p>
<p>可以说我们在手写的代码里面依旧没有植入异步功能，毕竟最基本的<code>setTimeout</code>我们都没有使用，但是我们必须先了解一下原生Promise的一些<code>运行顺序规则</code>。</p>
<p>在这里我为原生代码添加上步骤信息：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    resolve(<span class="string">&#x27;这次一定&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;fulfilled:&#x27;</span>, result);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;rejected:&#x27;</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>我们配合这段原生Promise代码，结合控制台一起看看</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/02/08/JS-Promise%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/image-20220208150043589.png"
                      class="" title="image-20220208150043589"
                >

<p>输出顺序为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">fulfilled: 这次一定</span><br></pre></td></tr></table></figure>

<ul>
<li>首先执行<code>console.log(1)</code>，输出<code>1</code></li>
<li>接着创建<code>promise实例</code>，输出<code>2</code>，因为这里依旧是同步</li>
<li>然后碰到<code>resolve</code>的时候，修改结果值</li>
<li>到了<code>promise.then</code>会进行异步操作，也就是我们 <strong>需要先把执行栈的内容清空</strong>，于是就执行<code>console.log(3)</code>，输出<code>3</code></li>
<li>接着才会执行<code>promise.then</code>里面的内容，也就是最后输出<code>“fulfilled: 这次一定”</code></li>
</ul>
<p>▪ 我们用同样的测试代码应用在 <strong>手写代码</strong> 上面：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    resolve(<span class="string">&#x27;这次一定&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">promise1.then(</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;fulfilled:&#x27;</span>, result);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;rejected:&#x27;</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>这次我们发现有些不同了😯，输出顺序为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">fulfilled: 这次一定</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/02/08/JS-Promise%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/image-20220208150032763.png"
                      class="" title="image-20220208150032763"
                >

<p><code>1</code> 和 <code>2</code> 都没有问题，问题就是<code>“fulfilled: 这次一定”</code>和<code>3</code>这里的顺序不对</p>
<p>◾ 其实问题很简单，就是我们刚刚说的 <strong>没有设置异步执行</strong> 😶</p>
<p>我们二话不说直接给<code>then</code>方法里面添加<code>setTimeout</code>就可以了😎，<strong>需要在进行<code>if</code>判断以后再添加<code>setTimeout</code>，要不然状态不符合添加异步也是没有意义的</strong>，然后在<code>setTimeout</code>里执行传入的函数参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.FULFILLED) &#123;</span><br><span class="line">+           <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                onFulfilled(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">+           &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.REJECTED) &#123;</span><br><span class="line">+           <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                onRejected(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">+           &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用前面的用例重新测试一下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.FULFILLED) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                onFulfilled(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.REJECTED) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                onRejected(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    resolve(<span class="string">&#x27;这次一定&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">promise1.then(</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;fulfilled:&#x27;</span>, result);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;rejected:&#x27;</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>输出顺序为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">fulfilled: 这次一定</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/84273bdd504e7f7e571f93f4f4e34da04d0fdc69f57e33c928da88b0c1b197af/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f30346565383064303830346134613662613638643434366431326663306133372e706e67"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://camo.githubusercontent.com/84273bdd504e7f7e571f93f4f4e34da04d0fdc69f57e33c928da88b0c1b197af/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f30346565383064303830346134613662613638643434366431326663306133372e706e67"
                      alt="在这里插入图片描述"
                ></a></p>
<p>这次的顺序就比较顺眼了~👏👏👏</p>
<p><strong>在这里我们解决异步的方法是给<code>resolve</code>和<code>reject</code>添加<code>setTimeout</code>，但是为什么要这么做呢？</strong></p>
<p>◾ 这就要讲到 <a target="_blank" rel="noopener" href="https://promisesaplus.com/#notes"><strong><code>Promises/A+</code> 规范</strong></a> 了</p>
<p>规范 <code>2.2.4</code> ：</p>
<blockquote>
<p><code>onFulfilled</code> or <code>onRejected</code> must not be called until the <code>execution context</code> stack contains only platform code. [3.1].</p>
<p>2.2.4 <code>onFulfilled</code> 和 <code>onRejected</code> 只有在<code>执行环境</code>堆栈仅包含平台代码时才可被调用 <code>注1</code></p>
</blockquote>
<p>规范对2.2.4做了注释：</p>
<blockquote>
<p>3.1 Here “platform code” means engine, environment, and promise implementation code. In practice, this requirement ensures that <code>onFulfilled</code> and <code>onRejected</code> execute asynchronously, after the event loop turn in which <code>then</code> is called, and with a fresh stack. This can be implemented with either a “macro-task” mechanism such as setTimeout or <code>setImmediate</code>, or with a “micro-task” mechanism such as MutationObserver or process.nextTick. Since the promise implementation is considered platform code, it may itself contain a task-scheduling queue or “trampoline” in which the handlers are called.</p>
<p><strong>3.1 这里的平台代码指的是引擎、环境以及 promise 的实施代码。实践中要确保 <code>onFulfilled</code> 和 <code>onRejected</code> 方法异步执行，且应该在 <code>then</code> 方法被调用的那一轮事件循环之后的新执行栈中执行。这个事件队列可以采用“宏任务（macro-task）”机制，比如<code>setTimeout</code> 或者 <code>setImmediate</code>； 也可以采用“微任务（micro-task）”机制来实现， 比如 <code>MutationObserver</code> 或者<code>process.nextTick</code>。</strong> 由于 promise 的实施代码本身就是平台代码（译者注： 即都是 JavaScript），故代码自身在处理在处理程序时可能已经包含一个任务调度队列或『跳板』)。</p>
</blockquote>
<p>**这里我们用的就是规范里讲到的 “宏任务” <code>setTimeout</code>**。</p>
<h2 id="2-回调保存"><a href="#2-回调保存" class="headerlink" title="2. 回调保存"></a>2. 回调保存</h2><p>异步的问题真的解决了吗？现在又要进入Promise另一个难点了，大家务必竖起耳朵啦😛</p>
<p>我们来给原生的Promise里添加<code>setTimeout</code>，使得<code>resolve</code>也异步执行，那么就会出现一个问题了，<code>resolve</code>是异步的，<code>then</code>也是异步的，究竟谁会先被调用呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">+   <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;这次一定&#x27;</span>);</span><br><span class="line">+       <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">+   &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;fulfilled:&#x27;</span>, result);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;rejected:&#x27;</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>输出顺序为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">fulfilled: 这次一定</span><br></pre></td></tr></table></figure>

<p>这里涉及到了浏览器的事件循环，<code>promise.then()</code> 和 <code>setTimeout()</code> 都是异步任务，但实际上异步任务之间并不相同，因此他们的执行优先级也有区别。不同的异步任务被分为两类：<code>微任务 (micro task)</code> 和 <code>宏任务 (macro task</code>)。</p>
<ul>
<li><code>setTimeout()</code>属于宏任务</li>
<li><code>promise.then()</code>属于微任务</li>
</ul>
<p>我们只需记住 <strong>当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。</strong></p>
<p><strong>回到正文</strong></p>
<p>我们用同样的代码应用到手写的部分：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;这次一定&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">promise1.then(</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;fulfilled:&#x27;</span>, result);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;rejected:&#x27;</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>可以发现 <code>fulfilled: 这次一定</code> 并没有输出</p>
<p>我们可以先猜测一下，没有输出的原因很可能是因为<code>then</code>方法没有被执行，看看<code>then</code>方法里面是根据条件判断来执行代码的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.FULFILLED) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                onFulfilled(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.REJECTED) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                onRejected(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说很可能没有符合的条件，再换句话说可能没有符合的状态</p>
<p>那么我们就在三个位置分别输出当前的状态，这样分别来判断哪个位置出了问题:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">+       <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>,promise1.PromiseState);</span><br><span class="line">        resolve(<span class="string">&#x27;这次一定&#x27;</span>);</span><br><span class="line">+       <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>,promise1.PromiseState);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">promise1.then(</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">+       <span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>,promise1.PromiseState);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;fulfilled:&#x27;</span>, result);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;rejected:&#x27;</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">A pending</span><br><span class="line">B fulfilled</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>发现只有两组状态被输出，这两组都在<code>console.log(4)</code>前被输出，证明<code>setTimeout</code>里面的状态都被输出了，只有<code>then</code>里面的状态没有被输出</p>
<p>这基本就可以确定是因为<code>then</code>里的状态判断出了问题</p>
<p>这里涉及到事件循环，我们详细解读一下：</p>
<p>▪ <strong>首先</strong>，执行<code>console.log(1)</code>，输出<code>1</code></p>
<p>▪ <strong>第二步</strong>，创建promise，执行函数体里的<code>console.log(2)</code>，输出<code>2</code></p>
<p>▪ <strong>第三步</strong>，遇到<code>setTimeout</code>，<code>setTimeout</code>是宏任务，将<code>setTimeout</code>加入宏任务队列，等待执行</p>
<p>▪ <strong>第四步</strong>，遇到<code>promise.then()</code>，<code>promise.then()</code>是微任务，将<code>promise.then()</code>加入微任务队列，等待执行</p>
<p>▪ <strong>第五步</strong>，执行<code>console.log(3)</code>，输出<code>3</code>，此时当前执行栈已经清空</p>
<p>▪ <strong>第六步</strong>，当前执行栈已经清空，先执行微任务队列的任务 <code>promise.then()</code>，发现promise的状态并没有改变，还是<code>pending</code>，所以没有输出。状态并没有改变的原因是：<code>resolve(&#39;这次一定&#39;)</code>是在<code>setTimeout</code>里的，但此时还没开始执行<code>setTimeout</code>，因为<code>setTimeout</code>是宏任务，宏任务在微任务后面执行</p>
<p>▪ <strong>第七步</strong>，微任务队列已经清空，开始执行宏任务 <code>setTimeout</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;A&#x27;,promise1.PromiseState);</span><br><span class="line">    resolve(&#x27;这次一定&#x27;);</span><br><span class="line">    console.log(&#x27;B&#x27;,promise1.PromiseState);</span><br><span class="line">    console.log(4);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>▪ <strong>第八步</strong>，执行 <code>console.log(&#39;A&#39;,promise1.PromiseState)</code>，此时promise状态还没发生变化，还是<code>pending</code>，所以输出 <code>A pending</code></p>
<p>▪ <strong>第九步</strong>，执行 <code>resolve(&#39;这次一定&#39;);</code>，改变promise的状态为<code>fulfilled</code></p>
<p>▪ <strong>第十步</strong>，执行 <code>console.log(&#39;B&#39;,promise1.PromiseState)</code>，输出 <code>B fulfilled</code></p>
<p>▪ <strong>第十一步</strong>，执行 <code>console.log(4)</code>，输出<code>4</code></p>
<blockquote>
<p>这里暂且认为我们写的promise.then()和原生一样，方便理解</p>
</blockquote>
<p>◾ 分析完上面的代码，我们知道了，因为先执行了<code>then</code>方法，但发现这个时候状态依旧是 <code>pending</code>，而我们手写部分没有定义<code>pending</code>待定状态的时候应该做什么，因此就少了<code>fulfilled: 这次一定</code> 这句话的输出</p>
<p>所以我们就 <strong>直接给<code>then</code>方法里面添加待定状态的情况就可以了</strong>，也就是用<code>if</code>进行判断:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class myPromise &#123;</span><br><span class="line">	...</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        onFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : value =&gt; value;</span><br><span class="line">        onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : reason =&gt; &#123;</span><br><span class="line">            throw reason;</span><br><span class="line">        &#125;;</span><br><span class="line">+       if (this.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">+ 		</span><br><span class="line">+ 		&#125;</span><br><span class="line">        if (this.PromiseState === myPromise.FULFILLED) &#123;</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                onFulfilled(this.PromiseResult);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.PromiseState === myPromise.REJECTED) &#123;</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                onRejected(this.PromiseResult);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>◾ 但是问题来了，当<code>then</code>里面判断到 <code>pending</code> 待定状态时我们要干什么？</p>
<p>因为这个时候<code>resolve</code>或者<code>reject</code>还没获取到任何值，因此我们必须让<code>then</code>里的函数稍后再执行，等<code>resolve</code>执行了以后，再执行<code>then</code></p>
<p>为了保留<code>then</code>里的函数，我们可以创建 <code>数组</code> 来 <strong>保存函数</strong>。</p>
<p>**为什么用 <code>数组</code> 来保存这些回调呢？因为一个promise实例可能会多次 <code>then</code>，也就是经典的 <code>链式调用</code>**，而且数组是先入先出的顺序</p>
<p>在实例化对象的时候就让每个实例都有这两个数组：</p>
<ul>
<li><code>onFulfilledCallbacks</code> ：用来 <strong>保存成功回调</strong></li>
<li><code>onRejectedCallbacks</code> ：用来 <strong>保存失败回调</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.PromiseState = myPromise.PENDING;</span><br><span class="line">        <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span>;</span><br><span class="line">+       <span class="built_in">this</span>.onFulfilledCallbacks = []; <span class="comment">// 保存成功回调</span></span><br><span class="line">+       <span class="built_in">this</span>.onRejectedCallbacks = []; <span class="comment">// 保存失败回调</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            func(<span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="built_in">this</span>.reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>◾ 接着就完善<code>then</code>里面的代码，也就是当判断到状态为 <code>pending</code> 待定时，暂时保存两个回调，也就是说暂且把<code>then</code>里的两个函数参数分别放在两个数组里面：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.PromiseState = myPromise.PENDING;</span><br><span class="line">        <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.onFulfilledCallbacks = []; <span class="comment">// 保存成功回调</span></span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks = []; <span class="comment">// 保存失败回调</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            func(<span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="built_in">this</span>.reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">+           <span class="built_in">this</span>.onFulfilledCallbacks.push(onFulfilled);</span><br><span class="line">+           <span class="built_in">this</span>.onRejectedCallbacks.push(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.FULFILLED) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                onFulfilled(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.REJECTED) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                onRejected(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>◾ 数组里面放完函数以后，就可以完善<code>resolve</code>和<code>reject</code>的代码了</p>
<p><strong>在执行<code>resolve</code>或者<code>reject</code>的时候，遍历自身的<code>callbacks</code>数组</strong>，看看数组里面有没有<code>then</code>那边 <strong>保留</strong> 过来的 <strong>待执行函数</strong>，<strong>然后逐个执行数组里面的函数</strong>，执行的时候会传入相应的参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.PromiseState = myPromise.PENDING;</span><br><span class="line">        <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.onFulfilledCallbacks = []; <span class="comment">// 保存成功回调</span></span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks = []; <span class="comment">// 保存失败回调</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            func(<span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="built_in">this</span>.reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">resolve</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.PromiseState = myPromise.FULFILLED;</span><br><span class="line">            <span class="built_in">this</span>.PromiseResult = result;</span><br><span class="line">+           <span class="built_in">this</span>.onFulfilledCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">+               callback(result)</span><br><span class="line">+           &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.PromiseState = myPromise.REJECTED;</span><br><span class="line">            <span class="built_in">this</span>.PromiseResult = reason;</span><br><span class="line"> +          <span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line"> +              callback(reason)</span><br><span class="line"> +          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.onFulfilledCallbacks.push(onFulfilled);</span><br><span class="line">            <span class="built_in">this</span>.onRejectedCallbacks.push(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.FULFILLED) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                onFulfilled(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.REJECTED) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                onRejected(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完善好代码后，让我们再来测试以下刚才的实例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>, promise1.PromiseState);</span><br><span class="line">        resolve(<span class="string">&#x27;这次一定&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>, promise1.PromiseState);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">promise1.then(</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>, promise1.PromiseState);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;fulfilled:&#x27;</span>, result);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;rejected:&#x27;</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">A pending</span><br><span class="line">C fulfilled</span><br><span class="line">fulfilled: 这次一定</span><br><span class="line">B fulfilled</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p><strong>从上面的结果我们可以看到 <code>fulfilled: 这次一定</code> 打印出来啦，<code>promise1.then()</code>方法也正常执行，打印出了当前的状态：<code>B fulfilled</code></strong></p>
<p><strong>但是</strong>代码输出顺序还是不太对，原生Promise中，<code>fulfilled: 这次一定</code> 是最后输出的</p>
<p>◾ 这里有一个很多人忽略的小细节，**<code>resolve</code> 和 <code>reject</code> 是要在 <code>事件循环末尾</code> 执行的**，因此我们就 <strong>给 <code>resolve</code> 和 <code>reject</code> 里面加上 <code>setTimeout</code></strong> 就可以了</p>
<p><strong>我们在判断完 <code>promise</code> 状态后再加 <code>setTimeout</code> ：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.PromiseState = myPromise.PENDING;</span><br><span class="line">        <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.onFulfilledCallbacks = []; <span class="comment">// 保存成功回调</span></span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks = []; <span class="comment">// 保存失败回调</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            func(<span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="built_in">this</span>.reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">resolve</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">+           <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.PromiseState = myPromise.FULFILLED;</span><br><span class="line">                <span class="built_in">this</span>.PromiseResult = result;</span><br><span class="line">                <span class="built_in">this</span>.onFulfilledCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">                    callback(result)</span><br><span class="line">                &#125;)</span><br><span class="line">+           &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">+           <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.PromiseState = myPromise.REJECTED;</span><br><span class="line">                <span class="built_in">this</span>.PromiseResult = reason;</span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">                    callback(reason)</span><br><span class="line">                &#125;)</span><br><span class="line">+           &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么不像下面这样呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">resolve</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">	 <span class="comment">// bad</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.PromiseState = myPromise.FULFILLED;</span><br><span class="line">            <span class="built_in">this</span>.PromiseResult = result;</span><br><span class="line">            <span class="built_in">this</span>.onFulfilledCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">                callback(result)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">	 <span class="comment">// bad</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.PromiseState = myPromise.REJECTED;</span><br><span class="line">            <span class="built_in">this</span>.PromiseResult = reason;</span><br><span class="line">            <span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">                callback(reason)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为在一个promise里，可能有的人会不注意同时用了<code>resolve()</code> 和 <code>reject()</code> ，像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(&#x27;这次一定&#x27;)</span><br><span class="line">    reject(&#x27;下次一定&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>▪ 如果把 <code>setTimeout</code> 放到 <code>if</code> 判断之前，那岂不是就算状态不满足条件，我们也要开启一个定时器，上面的情况，同时用了<code>resolve()</code> 和 <code>reject()</code>，那我们是不是要同时开启两个定时器？如果在一个promise里多次使用 <code>resolve()</code> 和 <code>reject()</code> 方法，那岂不是要开启更多的无用的定时器？</p>
<p>▪ 如果先判断状态再添加定时器，这样我们就 <strong>只会满足条件后才开启一个定时器</strong>，相比上面的情况，这样的 <strong>开销</strong> 就小了很多</p>
<p>聊完细节，我们回到正文，检验一下这次是否能行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.PromiseState = myPromise.PENDING;</span><br><span class="line">        <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.onFulfilledCallbacks = []; <span class="comment">// 保存成功回调</span></span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks = []; <span class="comment">// 保存失败回调</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            func(<span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="built_in">this</span>.reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">resolve</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.PromiseState = myPromise.FULFILLED;</span><br><span class="line">                <span class="built_in">this</span>.PromiseResult = result;</span><br><span class="line">                <span class="built_in">this</span>.onFulfilledCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">                    callback(result)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.PromiseState = myPromise.REJECTED;</span><br><span class="line">                <span class="built_in">this</span>.PromiseResult = reason;</span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">                    callback(reason)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.onFulfilledCallbacks.push(onFulfilled);</span><br><span class="line">            <span class="built_in">this</span>.onRejectedCallbacks.push(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.FULFILLED) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                onFulfilled(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.REJECTED) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                onRejected(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>, promise1.PromiseState);</span><br><span class="line">        resolve(<span class="string">&#x27;这次一定&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>, promise1.PromiseState);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">promise1.then(</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>, promise1.PromiseState);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;fulfilled:&#x27;</span>, result);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;rejected:&#x27;</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>输出顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">A pending</span><br><span class="line">B pending</span><br><span class="line">4</span><br><span class="line">C fulfilled</span><br><span class="line">fulfilled: 这次一定</span><br></pre></td></tr></table></figure>

<p><strong>可以看到最后输出 <code>fulfilled: 这次一定</code> ，和原生Promise顺序一致！</strong></p>
<p>到这里我们已经完成了 <strong>promise的回调保存</strong>，已经越来越接近胜利了😺</p>
<h2 id="3-验证-then-方法多次调用"><a href="#3-验证-then-方法多次调用" class="headerlink" title="3. 验证 then 方法多次调用"></a>3. 验证 then 方法多次调用</h2><p>Promise 的 then 方法可以被多次调用。</p>
<p>用一个 🌰 ，来验证一下我们写的promise <code>then</code> 方法是否可以多次调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.PromiseState = myPromise.PENDING;</span><br><span class="line">        <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.onFulfilledCallbacks = []; <span class="comment">// 保存成功回调</span></span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks = []; <span class="comment">// 保存失败回调</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            func(<span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="built_in">this</span>.reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">resolve</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.PromiseState = myPromise.FULFILLED;</span><br><span class="line">                <span class="built_in">this</span>.PromiseResult = result;</span><br><span class="line">                <span class="built_in">this</span>.onFulfilledCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">                    callback(result)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.PromiseState = myPromise.REJECTED;</span><br><span class="line">                <span class="built_in">this</span>.PromiseResult = reason;</span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">                    callback(reason)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.onFulfilledCallbacks.push(onFulfilled);</span><br><span class="line">            <span class="built_in">this</span>.onRejectedCallbacks.push(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.FULFILLED) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                onFulfilled(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.REJECTED) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                onRejected(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;resolve&#x27;</span>, value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>运行上面 🌰，输出结果👇</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">resolve success</span><br><span class="line">2</span><br><span class="line">resolve success</span><br><span class="line">3</span><br><span class="line">resolve success</span><br></pre></td></tr></table></figure>

<p>所有 <code>then</code> 中的回调函数都已经执行 😎</p>
<p>说明我们当前的代码，已经可以实现 <code>then</code> 方法的多次调用✨</p>
<p>👏👏👏 完美，继续</p>
<h1 id="五、实现-then-方法的链式调用"><a href="#五、实现-then-方法的链式调用" class="headerlink" title="五、实现 then 方法的链式调用"></a>五、实现 then 方法的链式调用</h1><p><strong>我们常常用到 <code>new Promise().then().then()</code>，这就是链式调用，用来解决回调地狱</strong></p>
<p>举个例子 🌰</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">10</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;fulfilled&#x27;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * res</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;fulfilled&#x27;</span>, res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>输出👇：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fulfilled 100</span><br><span class="line">fulfilled 200</span><br></pre></td></tr></table></figure>

<p>再举一个例子 🌰 ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">100</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;fulfilled&#x27;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve(<span class="number">3</span> * res))</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;fulfilled&#x27;</span>, res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>输出👇：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fulfilled 100</span><br><span class="line">fulfilled 300</span><br></pre></td></tr></table></figure>

<p>我们先试一下当前的<code>myPromise</code>是否可以实现链式调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.PromiseState = myPromise.PENDING;</span><br><span class="line">        <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.onFulfilledCallbacks = []; <span class="comment">// 保存成功回调</span></span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks = []; <span class="comment">// 保存失败回调</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            func(<span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="built_in">this</span>.reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">resolve</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.PromiseState = myPromise.FULFILLED;</span><br><span class="line">                <span class="built_in">this</span>.PromiseResult = result;</span><br><span class="line">                <span class="built_in">this</span>.onFulfilledCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">                    callback(result)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.PromiseState = myPromise.REJECTED;</span><br><span class="line">                <span class="built_in">this</span>.PromiseResult = reason;</span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">                    callback(reason)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.onFulfilledCallbacks.push(onFulfilled);</span><br><span class="line">            <span class="built_in">this</span>.onRejectedCallbacks.push(onRejected);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.FULFILLED) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                onFulfilled(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.REJECTED) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                onRejected(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">10</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;fulfilled&#x27;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * res</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;fulfilled&#x27;</span>, res)</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>

<p>毫无疑问在控制台里面是会报错的，提示 <code>then</code> 方法没有定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught TypeError: Cannot read property &#x27;then&#x27; of undefined</span><br></pre></td></tr></table></figure>

<p><strong><code>Promise.prototype.then()</code> 方法返回一个新的Promise实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</strong></p>
<h2 id="1-Promises-A-规范的理解"><a href="#1-Promises-A-规范的理解" class="headerlink" title="1. Promises/A+ 规范的理解"></a>1. Promises/A+ 规范的理解</h2><p>◾ <strong>想要实现<code>then</code>方法的链式调用，就必须彻底搞懂<code>then</code>方法，这里我们参考 <a target="_blank" rel="noopener" href="https://promisesaplus.com/#notes">*<em><code>Promises/A+</code> 规范*</em></a> 👇</strong></p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/958775fa09e2ac56c8a5d8a9d52914173522ff234a3cbef3a398f4a781201014/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f64343331343835656136313034333765393937633666646135633661633464662e706e67"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://camo.githubusercontent.com/958775fa09e2ac56c8a5d8a9d52914173522ff234a3cbef3a398f4a781201014/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f64343331343835656136313034333765393937633666646135633661633464662e706e67"
                      alt="在这里插入图片描述"
                ></a></p>
<p><strong>规范在<code>2.2.7</code>中这样描述 👇：</strong></p>
<p>◾ <strong>2.2.7 then 方法必须返回一个 promise 对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise2 = promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>2.2.7.1</strong> 如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 返回一个值 <code>x</code> ，则运行下面的 <strong>Promise 解决过程：<code>[[Resolve]](promise2, x)</code></strong></li>
<li><strong>2.2.7.2</strong> 如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 抛出一个异常 <code>e</code> ，则 <code>promise2</code> 必须拒绝执行，并返回拒因 <code>e</code></li>
<li><strong>2.2.7.3</strong> 如果 <code>onFulfilled</code> 不是函数且 <code>promise1</code> 成功执行， <code>promise2</code> 必须成功执行并返回相同的值</li>
<li><strong>2.2.7.4</strong> 如果 <code>onRejected</code> 不是函数且 <code>promise1</code> 拒绝执行， <code>promise2</code> 必须拒绝执行并返回相同的据因</li>
</ul>
<p>理解上面的<code>“返回”</code>部分非常重要，即：<strong>不论 promise1 被 reject 还是被 resolve 时 promise2 都会执行 Promise 解决过程：<code>[[Resolve]](promise2, x)</code>，只有出现异常时才会被 rejected。</strong></p>
<p>注意 <strong>2.2.7.1</strong> ：</p>
<blockquote>
<p>If either onFulfilled or onRejected returns a value x, <strong><code>run the Promise Resolution Procedure [[Resolve]](promise2, x).</code></strong></p>
<p>即：如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 返回一个值 <code>x</code> ，则运行下面的 <strong>Promise 解决过程：<code>[[Resolve]](promise2, x)</code></strong></p>
</blockquote>
<p>规范在 <strong>2.3</strong> 中详细描述 <strong>Promise 解决过程</strong> <code>The Promise Resolution Procedure</code> 👇</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/0b8d65a23570678e11739d565f0fb7acb4d5120c11cf8c9227f63126939382ab/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f34386234363938623539653434323736623438373236643134313064356265652e706e67"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://camo.githubusercontent.com/0b8d65a23570678e11739d565f0fb7acb4d5120c11cf8c9227f63126939382ab/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f34386234363938623539653434323736623438373236643134313064356265652e706e67"
                      alt="在这里插入图片描述"
                ></a></p>
<p>译过来 👇：</p>
<p>◾ <strong>2.3 Promise 解决过程</strong></p>
<p><strong>Promise 解决过程</strong> 是一个抽象的操作，其需输入一个 <code>promise</code> 和一个值，我们表示为 <code>[[Resolve]](promise, x)</code>，如果 <code>x</code> 有 <code>then</code> 方法且看上去像一个 <code>Promise</code> ，解决程序即尝试使 <code>promise</code> 接受 <code>x</code> 的状态；否则其用 <code>x</code> 的值来执行 <code>promise</code> 。</p>
<p>这种 <code>thenable</code> 的特性使得 <code>Promise</code> 的实现更具有通用性：<strong>只要其暴露出一个遵循 <code>Promises/A+</code> 协议的 <code>then</code> 方法即可；这同时也使遵循 <code>Promises/A+</code> 规范的实现可以与那些不太规范但可用的实现能良好共存。</strong></p>
<p><strong>运行 <code>[[Resolve]](promise, x)</code> 需遵循以下步骤：</strong></p>
<p>▪ <strong>2.3.1 <code>x</code> 与 promise 相等</strong></p>
<p>如果 <code>promise</code> 和 <code>x</code> 指向同一对象，以 <code>TypeError</code> 为据因拒绝执行 <code>promise</code></p>
<p>▪ <strong>2.3.2 <code>x</code> 为 Promise</strong></p>
<p>如果 <code>x</code> 为 Promise ，则使 <code>promise</code> 接受 <code>x</code> 的状态</p>
<ul>
<li>2.3.2.1 如果 <code>x</code> 处于等待态， <code>promise</code> 需保持为等待态直至 <code>x</code> 被执行或拒绝</li>
<li>2.3.2.2 如果 <code>x</code> 处于执行态，用相同的值执行 <code>promise</code></li>
<li>2.3.2.3 如果 <code>x</code> 处于拒绝态，用相同的据因拒绝 <code>promise</code></li>
</ul>
<p>▪ <strong>2.3.3 <code>x</code> 为对象或函数</strong></p>
<p>如果 x 为对象或者函数：</p>
<ul>
<li>2.3.3.1 把 <code>x.then</code> 赋值给 <code>then</code></li>
<li>2.3.3.2 如果取 <code>x.then</code> 的值时抛出错误 <code>e</code> ，则以 <code>e</code> 为据因拒绝 <code>promise</code></li>
<li>2.3.3.3 如果 <code>then</code> 是函数，将 <code>x</code> 作为函数的作用域 <code>this</code> 调用之。传递两个回调函数作为参数，第一个参数叫做 <code>resolvePromise</code> ，第二个参数叫做 <code>rejectPromise</code>:<ul>
<li>2.3.3.3.1 如果 <code>resolvePromise</code> 以值 <code>y</code> 为参数被调用，则运行 <code>[[Resolve]](promise, y)</code></li>
<li>2.3.3.3.2 如果 <code>rejectPromise</code> 以据因 <code>r</code> 为参数被调用，则以据因 <code>r</code> 拒绝 <code>promise</code></li>
<li>2.3.3.3.3 如果 <code>resolvePromise</code> 和 <code>rejectPromise</code> 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用</li>
<li>2.3.3.3.4 如果调用 <code>then</code> 方法抛出了异常 <code>e</code>：<ul>
<li>2.3.3.3.4.1 如果 <code>resolvePromise</code> 或 <code>rejectPromise</code> 已经被调用，则忽略之</li>
<li>2.3.3.3.4.2 否则以 <code>e</code> 为据因拒绝 <code>promise</code></li>
</ul>
</li>
<li>2.3.3.4 如果 <code>then</code> 不是函数，以 <code>x</code> 为参数执行 <code>promise</code></li>
</ul>
</li>
</ul>
<p><strong>▪ 2.3.4 如果 <code>x</code> 不为对象或者函数，以 <code>x</code> 为参数执行 <code>promise</code></strong></p>
<p>如果一个 <code>promise</code> 被一个循环的 <code>thenable</code> 链中的对象解决，而 <code>[[Resolve]](promise, thenable)</code> 的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励施者检测这样的递归是否存在，若检测到存在则以一个可识别的 <code>TypeError</code> 为据因来拒绝 <code>promise</code>。</p>
<h2 id="2-Promises-A-规范的总结"><a href="#2-Promises-A-规范的总结" class="headerlink" title="2. Promises/A+ 规范的总结"></a>2. Promises/A+ 规范的总结</h2><p>基于规范的描述，我们得到以下几点：</p>
<p><strong>◾ 1.</strong> <code>then</code>方法本身会返回一个新的<code>Promise</code>对象，返回一个新的Promise以后它就有自己的<code>then</code>方法，这样就能实现无限的链式</p>
<p><strong>◾ 2.</strong> 不论 <code>promise1</code> 被 <code>resolve()</code> 还是被 <code>reject()</code> 时 <code>promise2</code> 都会执行 <strong><code>Promise 解决过程：[[Resolve]](promise2, x)</code></strong></p>
<p>在手写这里我们把这个 <strong><code>Promise 解决过程：[[Resolve]](promise2, x)</code></strong> 命名为 <code>resolvePromise()</code> 方法，参数为 <code>(promise2, x, resolve, reject)</code> 即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function resolvePromise(promise2, x, resolve, reject) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>resolvePromise()</code>各参数的意义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 对resolve()、reject() 进行改造增强 针对resolve()和reject()中不同值情况 进行处理</span><br><span class="line"> * @param  &#123;promise&#125; promise2 promise1.then方法返回的新的promise对象</span><br><span class="line"> * @param  &#123;[type]&#125; x         promise1中onFulfilled或onRejected的返回值</span><br><span class="line"> * @param  &#123;[type]&#125; resolve   promise2的resolve方法</span><br><span class="line"> * @param  &#123;[type]&#125; reject    promise2的reject方法</span><br><span class="line"> */</span><br><span class="line">function resolvePromise(promise2, x, resolve, reject) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>其实，这个<code>resolvePromise(promise2, x, resolve, reject)</code> 即 <code>Promise 解决过程：[[Resolve]](promise2, x)</code> 就是对<code>resolve()、reject()</code> 进行<strong>改造增强</strong>， 针对<code>resolve()</code>和<code>reject()</code>中不同值情况 进行处理。</p>
<p><code>resolve()</code>和<code>reject()</code> 返回的 <code>x</code> 值的几种情况：</p>
<ol>
<li>普通值</li>
<li>Promise对象</li>
<li>thenable对象/函数</li>
</ol>
<p><strong>下面我们就根据总结的两点，结合 <code>Promises/A+ 规范</code> 来实现 <code>then</code> 方法的链式调用 💪💪💪</strong></p>
<h2 id="3-then-方法返回一个新的Promise"><a href="#3-then-方法返回一个新的Promise" class="headerlink" title="3. then 方法返回一个新的Promise"></a>3. then 方法返回一个新的Promise</h2><p>◾ <strong>2.2.7规范 then 方法必须返回一个 promise 对象</strong></p>
<p>我们在<code>then</code>方法里面返回一个 <code>新的手写Promise实例</code>，再把原来的代码复制上去：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class myPromise &#123;</span><br><span class="line">	...</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        onFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : value =&gt; value;</span><br><span class="line">        onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : reason =&gt; &#123;</span><br><span class="line">            throw reason;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">+       const promise2 = new myPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">            if (this.PromiseState === myPromise.FULFILLED) &#123;</span><br><span class="line">                setTimeout(() =&gt; &#123;</span><br><span class="line">                    onFulfilled(this.PromiseResult);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; else if (this.PromiseState === myPromise.REJECTED) &#123;</span><br><span class="line">                setTimeout(() =&gt; &#123;</span><br><span class="line">                    onRejected(this.PromiseResult);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; else if (this.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">                this.onFulfilledCallbacks.push(onFulfilled);</span><br><span class="line">                this.onRejectedCallbacks.push(onRejected);</span><br><span class="line">            &#125;</span><br><span class="line">+       &#125;)</span><br><span class="line">        </span><br><span class="line">+       return promise2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>◾ 2.2.7.1规范</strong> 如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 返回一个值 <code>x</code> ，则运行下面的 <strong>Promise 解决过程：<code>[[Resolve]](promise2, x)</code></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : +<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> promise2 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.FULFILLED) &#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">+                   <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">+                   resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.REJECTED) &#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">+                   <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">+                   resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.onFulfilledCallbacks.push(onFulfilled);</span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.push(onRejected);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> promise2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+<span class="comment">/**</span></span><br><span class="line"><span class="comment">+ * 对resolve()、reject() 进行改造增强 针对resolve()和reject()中不同值情况 进行处理</span></span><br><span class="line"><span class="comment">+ * <span class="doctag">@param  <span class="type">&#123;promise&#125;</span> </span>promise2 promise1.then方法返回的新的promise对象</span></span><br><span class="line"><span class="comment">+ * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>x         promise1中onFulfilled或onRejected的返回值</span></span><br><span class="line"><span class="comment">+ * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>resolve   promise2的resolve方法</span></span><br><span class="line"><span class="comment">+ * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>reject    promise2的reject方法</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+ <span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>我们在 <code>myPromise</code> 类外面声明了一个 <strong>Promise 解决过程</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function resolvePromise(promise2, x, resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>resolvePromise()</code> 具体方法我们后面会补充~</strong></p>
<p><strong>◾ 2.2.7.2 如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 抛出一个异常 <code>e</code> ，则 <code>promise2</code> 必须拒绝执行，并返回拒因 <code>e</code></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> promise2 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.FULFILLED) &#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">+                   <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">+                   &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">+                       reject(e); <span class="comment">// 捕获前面onFulfilled中抛出的异常</span></span><br><span class="line">+                   &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.REJECTED) &#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">+                   <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">+                   &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">+                       reject(e)</span><br><span class="line">+                   &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.onFulfilledCallbacks.push(onFulfilled);</span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.push(onRejected);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> promise2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对resolve()、reject() 进行改造增强 针对resolve()和reject()中不同值情况 进行处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;promise&#125;</span> </span>promise2 promise1.then方法返回的新的promise对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>x         promise1中onFulfilled或onRejected的返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>resolve   promise2的resolve方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>reject    promise2的reject方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>◾ <code>fulfilled</code> 和 <code>rejected</code> 状态处理完，不要忘了 <code>pending</code> 状态的情况</strong></p>
<p>我们在 <code>pending</code> 状态保存的 <code>resolve()</code> 和 <code>reject()</code> 回调也要符合 <code>2.2.7.1 和 2.2.7.2 规范</code>：</p>
<blockquote>
<p>如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 返回一个值 <code>x</code> ，则运行 Promise 解决过程：<code>[[Resolve]](promise2, x)</code></p>
</blockquote>
<blockquote>
<p>如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 抛出一个异常 <code>e</code> ，则 <code>promise2</code> 必须拒绝执行，并返回拒因 <code>e</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> promise2 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.FULFILLED) &#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e); <span class="comment">// 捕获前面onFulfilled中抛出的异常</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.REJECTED) &#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">+               <span class="built_in">this</span>.onFulfilledCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">+                   <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">+                       <span class="keyword">try</span> &#123;</span><br><span class="line">+                           <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">+                           resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">+                       &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">+                           reject(e);</span><br><span class="line">+                       &#125;</span><br><span class="line">+                   &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">+                   <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">+                       <span class="keyword">try</span> &#123;</span><br><span class="line">+                           <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">+                           resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">+                       &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">+                           reject(e);</span><br><span class="line">+                       &#125;</span><br><span class="line">+                   &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> promise2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对resolve()、reject() 进行改造增强 针对resolve()和reject()中不同值情况 进行处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;promise&#125;</span> </span>promise2 promise1.then方法返回的新的promise对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>x         promise1中onFulfilled或onRejected的返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>resolve   promise2的resolve方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>reject    promise2的reject方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>搞定 <code>then</code> 方法 😎</p>
<p>下面我们开始着手写 <strong>promise 解决过程 <code>resolvePromise(promise2, x, resolve, reject)</code></strong></p>
<h1 id="六、实现-resolvePromise-方法"><a href="#六、实现-resolvePromise-方法" class="headerlink" title="六、实现 resolvePromise 方法"></a>六、实现 resolvePromise 方法</h1><p><strong>◾ 2.3.1 如果 <code>promise</code> 和 <code>x</code> 指向同一对象，以 <code>TypeError</code> 为据因拒绝执行 <code>promise</code></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> promise2 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.FULFILLED) &#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e); <span class="comment">// 捕获前面onFulfilled中抛出的异常</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.REJECTED) &#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.onFulfilledCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> promise2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对resolve()、reject() 进行改造增强 针对resolve()和reject()中不同值情况 进行处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;promise&#125;</span> </span>promise2 promise1.then方法返回的新的promise对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>x         promise1中onFulfilled或onRejected的返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>resolve   promise2的resolve方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>reject    promise2的reject方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 如果从onFulfilled或onRejected中返回的 x 就是promise2，会导致循环引用报错</span></span><br><span class="line">+   <span class="keyword">if</span> (x === promise2) &#123;</span><br><span class="line">+       <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise&#x27;</span>));</span><br><span class="line">+   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如下面这种情况👇</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(100)</span><br><span class="line">&#125;)</span><br><span class="line">const p1 = promise.then(value =&gt; &#123;</span><br><span class="line">  console.log(value)</span><br><span class="line">  return p1</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用原生 Promise 执行这个代码，会报类型错误：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/02/08/JS-Promise%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/image-20220208160619270.png"
                      class="" title="image-20220208160619270"
                >

<p><strong>◾ 2.3.2 如果 <code>x</code> 为 Promise ，则使 <code>promise</code> 接受 <code>x</code> 的状态</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对resolve()、reject() 进行改造增强 针对resolve()和reject()中不同值情况 进行处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;promise&#125;</span> </span>promise2 promise1.then方法返回的新的promise对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>x         promise1中onFulfilled或onRejected的返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>resolve   promise2的resolve方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>reject    promise2的reject方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x === promise2) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.3.2 如果 x 为 Promise ，则使 promise2 接受 x 的状态</span></span><br><span class="line">+   <span class="keyword">if</span> (x <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">+       <span class="keyword">if</span> (x.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">+           <span class="comment">/**</span></span><br><span class="line"><span class="comment">+            * 2.3.2.1 如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝</span></span><br><span class="line"><span class="comment">+            *         注意&quot;直至 x 被执行或拒绝&quot;这句话，</span></span><br><span class="line"><span class="comment">+            *         这句话的意思是：x 被执行x，如果执行的时候拿到一个y，还要继续解析y</span></span><br><span class="line"><span class="comment">+            */</span></span><br><span class="line">+           x.then(<span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">+               resolvePromise(promise2, y, resolve, reject)</span><br><span class="line">+           &#125;, reject);</span><br><span class="line">+       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x.PromiseState === myPromise.FULFILLED) &#123;</span><br><span class="line">+           <span class="comment">// 2.3.2.2 如果 x 处于执行态，用相同的值执行 promise</span></span><br><span class="line">+           resolve(x.PromiseResult);</span><br><span class="line">+       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x.PromiseState === myPromise.REJECTED) &#123;</span><br><span class="line">+           <span class="comment">// 2.3.2.3 如果 x 处于拒绝态，用相同的据因拒绝 promise</span></span><br><span class="line">+           reject(x.PromiseResult);</span><br><span class="line">+       &#125;</span><br><span class="line">+   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>马上就要成功啦😸，还有最后一条😎</p>
<p>◾ 2.3.3 如果 <code>x</code> 为对象或者函数</p>
<p><strong>◾ 2.3.4 如果 <code>x</code> 不为对象或者函数，以 <code>x</code> 为参数执行 <code>promise</code></strong></p>
<p>在判断<code>x</code>是对象或函数时，<code>x</code> 不能是 <code>null</code>，因为 <code>typeof null</code>的值也为 <code>object</code></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/02/08/JS-Promise%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/image-20220208160738109.png"
                      class="" title="image-20220208160738109"
                >

<p>我们应该显式的声明 <code>x != null</code>，这样 当 <code>x</code> 为 <code>null</code> 时，直接执行<code>resolve(x)</code>，否则，如果不这样不声明，<code>x</code> 为 <code>null</code> 时就会走到<code>catch</code>然后<code>reject</code>，这不是我们要的，所以需要检测下<code>null</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (x != null &amp;&amp; ((typeof x === &#x27;object&#x27; || (typeof x === &#x27;function&#x27;))))</span><br></pre></td></tr></table></figure>

<p><strong>◾ 2.3.3 和 2.3.4 规范实现如下：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对resolve()、reject() 进行改造增强 针对resolve()和reject()中不同值情况 进行处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;promise&#125;</span> </span>promise2 promise1.then方法返回的新的promise对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>x         promise1中onFulfilled或onRejected的返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>resolve   promise2的resolve方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>reject    promise2的reject方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x === promise2) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.3.2 如果 x 为 Promise ，则使 promise2 接受 x 的状态</span></span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 2.3.2.1 如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝</span></span><br><span class="line"><span class="comment">             *         注意&quot;直至 x 被执行或拒绝&quot;这句话，</span></span><br><span class="line"><span class="comment">             *         这句话的意思是：x 被执行x，如果执行的时候拿到一个y，还要继续解析y</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            x.then(<span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">                resolvePromise(promise2, y, resolve, reject)</span><br><span class="line">            &#125;, reject);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x.PromiseState === myPromise.FULFILLED) &#123;</span><br><span class="line">            <span class="comment">// 2.3.2.2 如果 x 处于执行态，用相同的值执行 promise</span></span><br><span class="line">            resolve(x.PromiseResult);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x.PromiseState === myPromise.REJECTED) &#123;</span><br><span class="line">            <span class="comment">// 2.3.2.3 如果 x 处于拒绝态，用相同的据因拒绝 promise</span></span><br><span class="line">            reject(x.PromiseResult);</span><br><span class="line">        &#125;</span><br><span class="line">+   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; ((<span class="keyword">typeof</span> x === <span class="string">&#x27;object&#x27;</span> || (<span class="keyword">typeof</span> x === <span class="string">&#x27;function&#x27;</span>)))) &#123;</span><br><span class="line">+       <span class="comment">// 2.3.3 如果 x 为对象或函数</span></span><br><span class="line">+       <span class="keyword">try</span> &#123;</span><br><span class="line">+           <span class="comment">// 2.3.3.1 把 x.then 赋值给 then</span></span><br><span class="line">+           <span class="keyword">var</span> then = x.then;</span><br><span class="line">+       &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">+           <span class="comment">// 2.3.3.2 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise</span></span><br><span class="line">+           <span class="keyword">return</span> reject(e);</span><br><span class="line">+       &#125;</span><br><span class="line">+</span><br><span class="line">+       <span class="comment">/**</span></span><br><span class="line"><span class="comment">+        * 2.3.3.3 </span></span><br><span class="line"><span class="comment">+        * 如果 then 是函数，将 x 作为函数的作用域 this 调用之。</span></span><br><span class="line"><span class="comment">+        * 传递两个回调函数作为参数，</span></span><br><span class="line"><span class="comment">+        * 第一个参数叫做 `resolvePromise` ，第二个参数叫做 `rejectPromise`</span></span><br><span class="line"><span class="comment">+        */</span></span><br><span class="line">+       <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">+           <span class="comment">// 2.3.3.3.3 如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用</span></span><br><span class="line">+           <span class="keyword">let</span> called = <span class="literal">false</span>; <span class="comment">// 避免多次调用</span></span><br><span class="line">+           <span class="keyword">try</span> &#123;</span><br><span class="line">+               then.call(</span><br><span class="line">+                   x,</span><br><span class="line">+                   <span class="comment">// 2.3.3.3.1 如果 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y)</span></span><br><span class="line">+                   <span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">+                       <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">+                       called = <span class="literal">true</span>;</span><br><span class="line">+                       resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">+                   &#125;,</span><br><span class="line">+                   <span class="comment">// 2.3.3.3.2 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise</span></span><br><span class="line">+                   <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">+                       <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">+                       called = <span class="literal">true</span>;</span><br><span class="line">+                       reject(r);</span><br><span class="line">+                   &#125;</span><br><span class="line">+               )</span><br><span class="line">+           &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">+               <span class="comment">/**</span></span><br><span class="line"><span class="comment">+                * 2.3.3.3.4 如果调用 then 方法抛出了异常 e</span></span><br><span class="line"><span class="comment">+                * 2.3.3.3.4.1 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之</span></span><br><span class="line"><span class="comment">+                */</span></span><br><span class="line">+               <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">+               called = <span class="literal">true</span>;</span><br><span class="line">+</span><br><span class="line">+               <span class="comment">/**</span></span><br><span class="line"><span class="comment">+                * 2.3.3.3.4.2 否则以 e 为据因拒绝 promise</span></span><br><span class="line"><span class="comment">+                */</span></span><br><span class="line">+               reject(e);</span><br><span class="line">+           &#125;</span><br><span class="line">+       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+           <span class="comment">// 2.3.3.4 如果 then 不是函数，以 x 为参数执行 promise</span></span><br><span class="line">+           resolve(x);</span><br><span class="line">+       &#125;</span><br><span class="line">+   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+       <span class="comment">// 2.3.4 如果 x 不为对象或者函数，以 x 为参数执行 promise</span></span><br><span class="line">+       <span class="keyword">return</span> resolve(x);</span><br><span class="line">+   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>打完收工✨✨✨✨</strong></p>
<p><strong><code>resolvePromise()</code>方法 完整代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对resolve()、reject() 进行改造增强 针对resolve()和reject()中不同值情况 进行处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;promise&#125;</span> </span>promise2 promise1.then方法返回的新的promise对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>x         promise1中onFulfilled或onRejected的返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>resolve   promise2的resolve方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>reject    promise2的reject方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x === promise2) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.3.2 如果 x 为 Promise ，则使 promise2 接受 x 的状态</span></span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 2.3.2.1 如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝</span></span><br><span class="line"><span class="comment">             *         注意&quot;直至 x 被执行或拒绝&quot;这句话，</span></span><br><span class="line"><span class="comment">             *         这句话的意思是：x 被执行x，如果执行的时候拿到一个y，还要继续解析y</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            x.then(<span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">                resolvePromise(promise2, y, resolve, reject)</span><br><span class="line">            &#125;, reject);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x.PromiseState === myPromise.FULFILLED) &#123;</span><br><span class="line">            <span class="comment">// 2.3.2.2 如果 x 处于执行态，用相同的值执行 promise</span></span><br><span class="line">            resolve(x.PromiseResult);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x.PromiseState === myPromise.REJECTED) &#123;</span><br><span class="line">            <span class="comment">// 2.3.2.3 如果 x 处于拒绝态，用相同的据因拒绝 promise</span></span><br><span class="line">            reject(x.PromiseResult);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; ((<span class="keyword">typeof</span> x === <span class="string">&#x27;object&#x27;</span> || (<span class="keyword">typeof</span> x === <span class="string">&#x27;function&#x27;</span>)))) &#123;</span><br><span class="line">        <span class="comment">// 2.3.3 如果 x 为对象或函数</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2.3.3.1 把 x.then 赋值给 then</span></span><br><span class="line">            <span class="keyword">var</span> then = x.then;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">// 2.3.3.2 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise</span></span><br><span class="line">            <span class="keyword">return</span> reject(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2.3.3.3 </span></span><br><span class="line"><span class="comment">         * 如果 then 是函数，将 x 作为函数的作用域 this 调用之。</span></span><br><span class="line"><span class="comment">         * 传递两个回调函数作为参数，</span></span><br><span class="line"><span class="comment">         * 第一个参数叫做 `resolvePromise` ，第二个参数叫做 `rejectPromise`</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.3.3.3.3 如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用</span></span><br><span class="line">            <span class="keyword">let</span> called = <span class="literal">false</span>; <span class="comment">// 避免多次调用</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                then.call(</span><br><span class="line">                    x,</span><br><span class="line">                    <span class="comment">// 2.3.3.3.1 如果 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y)</span></span><br><span class="line">                    <span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                        called = <span class="literal">true</span>;</span><br><span class="line">                        resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="comment">// 2.3.3.3.2 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise</span></span><br><span class="line">                    <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                        called = <span class="literal">true</span>;</span><br><span class="line">                        reject(r);</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 2.3.3.3.4 如果调用 then 方法抛出了异常 e</span></span><br><span class="line"><span class="comment">                 * 2.3.3.3.4.1 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                called = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 2.3.3.3.4.2 否则以 e 为据因拒绝 promise</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2.3.3.4 如果 then 不是函数，以 x 为参数执行 promise</span></span><br><span class="line">            resolve(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 2.3.4 如果 x 不为对象或者函数，以 x 为参数执行 promise</span></span><br><span class="line">        <span class="keyword">return</span> resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七、完整的-Promises-A-实现"><a href="#七、完整的-Promises-A-实现" class="headerlink" title="七、完整的 Promises/A+ 实现"></a>七、完整的 Promises/A+ 实现</h1><p>到这里我们的<code>myPromsie</code>已经完成了 <strong>Promises/A+ 规范</strong> 😸</p>
<blockquote>
<p>ES6的官方Promise还有很多API，但这些都不在Promises/A+里面</p>
</blockquote>
<p>这里为大家提供了两个完整的 Promises/A+ 实现版本：</p>
<h2 id="1-清爽简洁-无注释版"><a href="#1-清爽简洁-无注释版" class="headerlink" title="1. 清爽简洁 无注释版"></a>1. 清爽简洁 无注释版</h2><p><strong>完整的 Promises/A+ 实现 <code>(清爽简洁 无注释版)</code>：</strong></p>
<p><em>完整版的代码较长，这里如果看不清楚的可以去我的GitHub上看，我专门维护了一个 手写 Promsie 的仓库</em>：<a class="link"   target="_blank" rel="noopener" href="https://github.com/yuanyuanbyte/Promise%E2%80%8D" >https://github.com/yuanyuanbyte/Promise‍<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.PromiseState = myPromise.PENDING;</span><br><span class="line">        <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.onFulfilledCallbacks = [];</span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks = [];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            func(<span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="built_in">this</span>.reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">resolve</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.PromiseState = myPromise.FULFILLED;</span><br><span class="line">                <span class="built_in">this</span>.PromiseResult = result;</span><br><span class="line">                <span class="built_in">this</span>.onFulfilledCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">                    callback(result)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.PromiseState = myPromise.REJECTED;</span><br><span class="line">                <span class="built_in">this</span>.PromiseResult = reason;</span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">                    callback(reason)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> promise2 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.FULFILLED) &#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.REJECTED) &#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.onFulfilledCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> promise2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x === promise2) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            x.then(<span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">                resolvePromise(promise2, y, resolve, reject)</span><br><span class="line">            &#125;, reject);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x.PromiseState === myPromise.FULFILLED) &#123;</span><br><span class="line">            resolve(x.PromiseResult);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x.PromiseState === myPromise.REJECTED) &#123;</span><br><span class="line">            reject(x.PromiseResult);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; ((<span class="keyword">typeof</span> x === <span class="string">&#x27;object&#x27;</span> || (<span class="keyword">typeof</span> x === <span class="string">&#x27;function&#x27;</span>)))) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> then = x.then;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">return</span> reject(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> called = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                then.call(</span><br><span class="line">                    x,</span><br><span class="line">                    <span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                        called = <span class="literal">true</span>;</span><br><span class="line">                        resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                        called = <span class="literal">true</span>;</span><br><span class="line">                        reject(r);</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                called = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-按步分析-注释加持版"><a href="#2-按步分析-注释加持版" class="headerlink" title="2. 按步分析 注释加持版"></a>2. 按步分析 注释加持版</h2><p><strong>完整的 Promises/A+ 实现 <code>(按步分析 注释加持版)</code>：</strong></p>
<p><em>完整版的代码较长，这里如果看不清楚的可以去我的GitHub上看，我专门维护了一个 手写 Promsie 的仓库</em>：<a class="link"   target="_blank" rel="noopener" href="https://github.com/yuanyuanbyte/Promise%E2%80%8D" >https://github.com/yuanyuanbyte/Promise‍<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为了统一用static创建静态属性，用来管理状态</span></span><br><span class="line">    <span class="keyword">static</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数：通过new命令生成对象实例时，自动调用类的构造函数</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123; <span class="comment">// 给类的构造方法constructor添加一个参数func</span></span><br><span class="line">        <span class="built_in">this</span>.PromiseState = myPromise.PENDING; <span class="comment">// 指定Promise对象的状态属性 PromiseState，初始值为pending</span></span><br><span class="line">        <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span>; <span class="comment">// 指定Promise对象的结果 PromiseResult</span></span><br><span class="line">        <span class="built_in">this</span>.onFulfilledCallbacks = []; <span class="comment">// 保存成功回调</span></span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks = []; <span class="comment">// 保存失败回调</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * func()传入resolve和reject，</span></span><br><span class="line"><span class="comment">             * resolve()和reject()方法在外部调用，这里需要用bind修正一下this指向</span></span><br><span class="line"><span class="comment">             * new 对象实例时，自动执行func()</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            func(<span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="comment">// 生成实例时(执行resolve和reject)，如果报错，就把错误信息传入给reject()方法，并且直接执行reject()方法</span></span><br><span class="line">            <span class="built_in">this</span>.reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">resolve</span>(<span class="params">result</span>)</span> &#123; <span class="comment">// result为成功态时接收的终值</span></span><br><span class="line">        <span class="comment">// 只能由pedning状态 =&gt; fulfilled状态 (避免调用多次resolve reject)</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 为什么resolve和reject要加setTimeout?</span></span><br><span class="line"><span class="comment">             * 2.2.4规范 onFulfilled 和 onRejected 只允许在 execution context 栈仅包含平台代码时运行.</span></span><br><span class="line"><span class="comment">             * 注1 这里的平台代码指的是引擎、环境以及 promise 的实施代码。实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。</span></span><br><span class="line"><span class="comment">             * 这个事件队列可以采用“宏任务（macro-task）”机制，比如setTimeout 或者 setImmediate； 也可以采用“微任务（micro-task）”机制来实现， 比如 MutationObserver 或者process.nextTick。 </span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.PromiseState = myPromise.FULFILLED;</span><br><span class="line">                <span class="built_in">this</span>.PromiseResult = result;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 在执行resolve或者reject的时候，遍历自身的callbacks数组，</span></span><br><span class="line"><span class="comment">                 * 看看数组里面有没有then那边 保留 过来的 待执行函数，</span></span><br><span class="line"><span class="comment">                 * 然后逐个执行数组里面的函数，执行的时候会传入相应的参数</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="built_in">this</span>.onFulfilledCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">                    callback(result)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123; <span class="comment">// reason为拒绝态时接收的终值</span></span><br><span class="line">        <span class="comment">// 只能由pedning状态 =&gt; rejected状态 (避免调用多次resolve reject)</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.PromiseState = myPromise.REJECTED;</span><br><span class="line">                <span class="built_in">this</span>.PromiseResult = reason;</span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">                    callback(reason)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * [注册fulfilled状态/rejected状态对应的回调函数] </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;function&#125;</span> </span>onFulfilled  fulfilled状态时 执行的函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;function&#125;</span> </span>onRejected  rejected状态时 执行的函数 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns <span class="type">&#123;function&#125;</span> </span>newPromsie  返回一个新的promise对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数校验：Promise规定then方法里面的两个参数如果不是函数的话就要被忽略</span></span><br><span class="line"><span class="comment">         * 所谓“忽略”并不是什么都不干，</span></span><br><span class="line"><span class="comment">         * 对于onFulfilled来说“忽略”就是将value原封不动的返回，</span></span><br><span class="line"><span class="comment">         * 对于onRejected来说就是返回reason，</span></span><br><span class="line"><span class="comment">         *     onRejected因为是错误分支，我们返回reason应该throw一个Error</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2.7规范 then 方法必须返回一个 promise 对象</span></span><br><span class="line">        <span class="keyword">let</span> promise2 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.FULFILLED) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 为什么这里要加定时器setTimeout？</span></span><br><span class="line"><span class="comment">                 * 2.2.4规范 onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用 注1</span></span><br><span class="line"><span class="comment">                 * 这里的平台代码指的是引擎、环境以及 promise 的实施代码。</span></span><br><span class="line"><span class="comment">                 * 实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。</span></span><br><span class="line"><span class="comment">                 * 这个事件队列可以采用“宏任务（macro-task）”机制，比如setTimeout 或者 setImmediate； 也可以采用“微任务（micro-task）”机制来实现， 比如 MutationObserver 或者process.nextTick。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 2.2.7.1规范 如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程：[[Resolve]](promise2, x)，即运行resolvePromise()</span></span><br><span class="line">                        <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        <span class="comment">// 2.2.7.2 如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e</span></span><br><span class="line">                        reject(e); <span class="comment">// 捕获前面onFulfilled中抛出的异常</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.REJECTED) &#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">                <span class="comment">// pending 状态保存的 resolve() 和 reject() 回调也要符合 2.2.7.1 和 2.2.7.2 规范</span></span><br><span class="line">                <span class="built_in">this</span>.onFulfilledCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.PromiseResult);</span><br><span class="line">                            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> promise2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对resolve()、reject() 进行改造增强 针对resolve()和reject()中不同值情况 进行处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;promise&#125;</span> </span>promise2 promise1.then方法返回的新的promise对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>x         promise1中onFulfilled或onRejected的返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>resolve   promise2的resolve方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>reject    promise2的reject方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 2.3.1规范 如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise</span></span><br><span class="line">    <span class="keyword">if</span> (x === promise2) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.3.2规范 如果 x 为 Promise ，则使 promise2 接受 x 的状态</span></span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x.PromiseState === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 2.3.2.1 如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝</span></span><br><span class="line"><span class="comment">             *         注意&quot;直至 x 被执行或拒绝&quot;这句话，</span></span><br><span class="line"><span class="comment">             *         这句话的意思是：x 被执行x，如果执行的时候拿到一个y，还要继续解析y</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            x.then(<span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">                resolvePromise(promise2, y, resolve, reject)</span><br><span class="line">            &#125;, reject);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x.PromiseState === myPromise.FULFILLED) &#123;</span><br><span class="line">            <span class="comment">// 2.3.2.2 如果 x 处于执行态，用相同的值执行 promise</span></span><br><span class="line">            resolve(x.PromiseResult);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x.PromiseState === myPromise.REJECTED) &#123;</span><br><span class="line">            <span class="comment">// 2.3.2.3 如果 x 处于拒绝态，用相同的据因拒绝 promise</span></span><br><span class="line">            reject(x.PromiseResult);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; ((<span class="keyword">typeof</span> x === <span class="string">&#x27;object&#x27;</span> || (<span class="keyword">typeof</span> x === <span class="string">&#x27;function&#x27;</span>)))) &#123;</span><br><span class="line">        <span class="comment">// 2.3.3 如果 x 为对象或函数</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2.3.3.1 把 x.then 赋值给 then</span></span><br><span class="line">            <span class="keyword">var</span> then = x.then;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">// 2.3.3.2 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise</span></span><br><span class="line">            <span class="keyword">return</span> reject(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2.3.3.3 </span></span><br><span class="line"><span class="comment">         * 如果 then 是函数，将 x 作为函数的作用域 this 调用之。</span></span><br><span class="line"><span class="comment">         * 传递两个回调函数作为参数，</span></span><br><span class="line"><span class="comment">         * 第一个参数叫做 `resolvePromise` ，第二个参数叫做 `rejectPromise`</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.3.3.3.3 如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用</span></span><br><span class="line">            <span class="keyword">let</span> called = <span class="literal">false</span>; <span class="comment">// 避免多次调用</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                then.call(</span><br><span class="line">                    x,</span><br><span class="line">                    <span class="comment">// 2.3.3.3.1 如果 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y)</span></span><br><span class="line">                    <span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                        called = <span class="literal">true</span>;</span><br><span class="line">                        resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="comment">// 2.3.3.3.2 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise</span></span><br><span class="line">                    <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                        called = <span class="literal">true</span>;</span><br><span class="line">                        reject(r);</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 2.3.3.3.4 如果调用 then 方法抛出了异常 e</span></span><br><span class="line"><span class="comment">                 * 2.3.3.3.4.1 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                called = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 2.3.3.3.4.2 否则以 e 为据因拒绝 promise</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2.3.3.4 如果 then 不是函数，以 x 为参数执行 promise</span></span><br><span class="line">            resolve(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 2.3.4 如果 x 不为对象或者函数，以 x 为参数执行 promise</span></span><br><span class="line">        <span class="keyword">return</span> resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="八、Promises-A-测试"><a href="#八、Promises-A-测试" class="headerlink" title="八、Promises/A+ 测试"></a>八、Promises/A+ 测试</h1><p>如何证明我们写的<code>myPromise</code>就符合 <strong>Promises/A+</strong> 规范呢？</p>
<p>跑一下 Promise A+ 测试 就好啦~</p>
<h2 id="1-安装官方测试工具"><a href="#1-安装官方测试工具" class="headerlink" title="1. 安装官方测试工具"></a>1. 安装官方测试工具</h2><p>我们使用Promises/A+官方的测试工具 <a class="link"   target="_blank" rel="noopener" href="https://github.com/promises-aplus/promises-tests" >promises-aplus-tests<i class="fas fa-external-link-alt"></i></a> 来对我们的<code>myPromise</code>进行测试</p>
<p><strong>安装 <code>promises-aplus-tests</code>:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install promises-aplus-tests -D</span><br></pre></td></tr></table></figure>

<p><strong>安装完测试工具后的项目目录：</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/02/08/JS-Promise%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/1.png"
                      class=""
                >

<h2 id="2-使用-CommonJS-对外暴露-myPromise-类"><a href="#2-使用-CommonJS-对外暴露-myPromise-类" class="headerlink" title="2. 使用 CommonJS 对外暴露 myPromise 类"></a>2. 使用 CommonJS 对外暴露 myPromise 类</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123; </span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ <span class="built_in">module</span>.exports = myPromise;</span><br></pre></td></tr></table></figure>

<h2 id="3-实现静态方法-deferred"><a href="#3-实现静态方法-deferred" class="headerlink" title="3. 实现静态方法 deferred"></a>3. 实现静态方法 deferred</h2><p>要使用 <code>promises-aplus-tests</code> 这个工具测试，必须实现一个静态方法<code>deferred()</code>，官方对这个方法的定义如下:</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/02/08/JS-Promise%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f38323263326466356230323934623535393964303339313335383034623730662e706e67.png"
                      class=""
                >

<p>意思就是：</p>
<p>我们要给自己手写的<code>myPromise</code>上实现一个静态方法<code>deferred()</code>，该方法要返回一个包含<code>&#123; promise, resolve, reject &#125;</code>的对象：</p>
<ul>
<li><code>promise</code> 是一个处于<code>pending</code>状态的 Promsie。</li>
<li><code>resolve(value)</code> 用<code>value</code>解决上面那个<code>promise</code></li>
<li><code>reject(reason)</code> 用<code>reason</code>拒绝上面那个<code>promise</code></li>
</ul>
<p><strong><code>deferred()</code>的实现如下：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123; </span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+  myPromise.deferred = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">+      <span class="keyword">let</span> result = &#123;&#125;;</span><br><span class="line">+      result.promise = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">+          result.resolve = resolve;</span><br><span class="line">+          result.reject = reject;</span><br><span class="line">+      &#125;);</span><br><span class="line">+      <span class="keyword">return</span> result;</span><br><span class="line">+  &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = myPromise;</span><br></pre></td></tr></table></figure>

<h2 id="4-配置-package-json"><a href="#4-配置-package-json" class="headerlink" title="4. 配置 package.json"></a>4. 配置 package.json</h2><p>我们实现了<code>deferred </code>方法，也通过 CommonJS 对外暴露了<code>myPromise</code>，最后配置一下<code>package.json</code>就可以跑测试啦~😺</p>
<p>新建一个 <code>package.json</code> ，<strong>配置如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;promises-aplus-tests&quot;: &quot;^2.1.2&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;promises-aplus-tests myPromise&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>项目目录：</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/02/08/JS-Promise%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/68747470733a2f2f696d672d626c6f672e6373646e696d671.png"
                      class=""
                >

<h2 id="5-完美通过官方872个测试用例"><a href="#5-完美通过官方872个测试用例" class="headerlink" title="5. 完美通过官方872个测试用例"></a>5. 完美通过官方872个测试用例</h2><p><strong>执行测试命令：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run test</span><br></pre></td></tr></table></figure>

<p>Promises/A+ 官方测试总共872用例，我们手写的Promise完美通过了所有用例 🎉🎉🎉:</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2022/02/08/JS-Promise%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/image-20220208161458663.png"
                      class="" title="image-20220208161458663"
                >

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>Post title：JS深入学习(20)：Promise的模拟实现</li>
        <li>Post author：Sunburst7</li>
        <li>Create time：2022-02-08 15:24:04</li>
        <li>
            Post link：https://sunburst7.github.io/2022/02/08/JS-Promise的模拟实现/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/JavaScript/">#JavaScript</a>&nbsp;
                    </li>
                
                    <li class="tag-item">
                        <a href="/tags/%E5%89%8D%E7%AB%AF/">#前端</a>&nbsp;
                    </li>
                
                    <li class="tag-item">
                        <a href="/tags/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/">#模拟实现</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2022/02/10/JS-Proxy/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">JS深入学习(21)：Proxy与Reflect</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2022/02/05/leetcode-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">leetcode(8)所有可能的路径</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2021</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Sunburst7</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%AE%9A%E4%B9%89%E5%88%9D%E5%A7%8B%E7%BB%93%E6%9E%84"><span class="nav-text">一、定义初始结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0-resolve-%E5%92%8C-reject"><span class="nav-text">二、实现 resolve 和 reject</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%AE%A1%E7%90%86%E7%8A%B6%E6%80%81%E5%92%8C%E7%BB%93%E6%9E%9C"><span class="nav-text">1. 管理状态和结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-this-%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98"><span class="nav-text">2. this 指向问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%AE%9E%E7%8E%B0-then-%E6%96%B9%E6%B3%95"><span class="nav-text">三、实现 then 方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%8A%B6%E6%80%81%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="nav-text">1. 状态不可变</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%89%A7%E8%A1%8C%E5%BC%82%E5%B8%B8-throw"><span class="nav-text">2. 执行异常 throw</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C"><span class="nav-text">3. 参数校验</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5"><span class="nav-text">四、实现异步</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%B7%BB%E5%8A%A0%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-text">1. 添加定时器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%9B%9E%E8%B0%83%E4%BF%9D%E5%AD%98"><span class="nav-text">2. 回调保存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E9%AA%8C%E8%AF%81-then-%E6%96%B9%E6%B3%95%E5%A4%9A%E6%AC%A1%E8%B0%83%E7%94%A8"><span class="nav-text">3. 验证 then 方法多次调用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%AE%9E%E7%8E%B0-then-%E6%96%B9%E6%B3%95%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="nav-text">五、实现 then 方法的链式调用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Promises-A-%E8%A7%84%E8%8C%83%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-text">1. Promises&#x2F;A+ 规范的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Promises-A-%E8%A7%84%E8%8C%83%E7%9A%84%E6%80%BB%E7%BB%93"><span class="nav-text">2. Promises&#x2F;A+ 规范的总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-then-%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84Promise"><span class="nav-text">3. then 方法返回一个新的Promise</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%AE%9E%E7%8E%B0-resolvePromise-%E6%96%B9%E6%B3%95"><span class="nav-text">六、实现 resolvePromise 方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E5%AE%8C%E6%95%B4%E7%9A%84-Promises-A-%E5%AE%9E%E7%8E%B0"><span class="nav-text">七、完整的 Promises&#x2F;A+ 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%B8%85%E7%88%BD%E7%AE%80%E6%B4%81-%E6%97%A0%E6%B3%A8%E9%87%8A%E7%89%88"><span class="nav-text">1. 清爽简洁 无注释版</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%8C%89%E6%AD%A5%E5%88%86%E6%9E%90-%E6%B3%A8%E9%87%8A%E5%8A%A0%E6%8C%81%E7%89%88"><span class="nav-text">2. 按步分析 注释加持版</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81Promises-A-%E6%B5%8B%E8%AF%95"><span class="nav-text">八、Promises&#x2F;A+ 测试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%AE%89%E8%A3%85%E5%AE%98%E6%96%B9%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="nav-text">1. 安装官方测试工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8-CommonJS-%E5%AF%B9%E5%A4%96%E6%9A%B4%E9%9C%B2-myPromise-%E7%B1%BB"><span class="nav-text">2. 使用 CommonJS 对外暴露 myPromise 类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%AE%9E%E7%8E%B0%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-deferred"><span class="nav-text">3. 实现静态方法 deferred</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E9%85%8D%E7%BD%AE-package-json"><span class="nav-text">4. 配置 package.json</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%AE%8C%E7%BE%8E%E9%80%9A%E8%BF%87%E5%AE%98%E6%96%B9872%E4%B8%AA%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="nav-text">5. 完美通过官方872个测试用例</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/code-copy.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/lazyload.js"></script>


<div class="post-scripts">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/toc.js"></script>
    
</div>



</body>
</html>
