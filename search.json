[{"title":"JS深入学习(7)：call和apply的模拟实现","url":"/2022/01/20/JS-call%E5%92%8Capply%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/","content":"本节将要尝试自己实现call()函数与apply()函数。\n1 call回顾一下call()方法，call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法：\nvar foo = &#123;    value: 1&#125;;function bar() &#123;    console.log(this.value);&#125;bar.call(foo); // 1\n\n注意两点：\n\ncall 改变了 this 的指向，指向到 foo\nbar 函数执行了\n\n1.1 version1试想当调用 call 的时候，把 foo 对象改造成如下：\nvar foo = &#123;    value: 1,    bar: function() &#123;        console.log(this.value)    &#125;&#125;;foo.bar(); // 1\n\n这个时候 this 就指向了 foo，但是这样却给 foo 对象本身添加了一个属性，不过也不用担心，我们用 delete 再删除它即可。所以我们模拟的步骤可以分为：\n\n将函数设为对象的属性：foo.func = bar\n执行该函数：foo.func()\n删除该函数：delete foo.func\n\nFunction.prototype.call_1 = function(context) &#123;    // 首先要获取调用call的函数，用this可以获取    context.func = this;    context.func();    delete context.func;&#125;// 测试一下var foo = &#123;    value: 1&#125;;function bar() &#123;    console.log(this.value);&#125;bar.call_1(foo); // 1\n\n1.2 verison2第一版是由问题的，call()函数是可以传递参数给将要执行的函数，而且传入的参数并不确定：\nvar foo = &#123;    value: 1&#125;;function bar(name, age) &#123;    console.log(name)    console.log(age)    console.log(this.value);&#125;bar.call(foo, &#x27;kevin&#x27;, 18);// kevin// 18// 1\n\n我们可以通过函数的Arguments取得函数的形参，取出第二个到最后一个参数，然后放到一个数组里。因为Arguments是类数组对象，直接for循环遍历。接着要把这个参数数组放到要执行的函数的参数里面去：\n这里给出冴羽大佬的实现方式与我的ES6的实现方式：\n\n冴羽大佬的核心是使用eval()方法执行函数，eval()方法就是一个完整的ECMAScript 解释器，它接收一个参数，即一个要执行的ECMAScript（JavaScript）字符串。因此传入的必须是参数的引用，因为原值(Kevin)会被当成是引用而报错ReferenceError\nES6中可以使用解构运算符把参数一个个作为形参传递进去\n\nFunction.prototype.call_2 = function(context) &#123;    context.fn = this;    var args = [];    for(var i = 1, len = arguments.length; i &lt; len; i++) &#123;        args.push(&#x27;arguments[&#x27; + i + &#x27;]&#x27;);    &#125;    eval(&#x27;context.fn(&#x27; + args +&#x27;)&#x27;);    delete context.fn;&#125;Function.prototype.call_2_1 = function(context) &#123;    context.fn = this;    var args = [];    for(var i = 1, len = arguments.length; i &lt; len; i++) &#123;        args.push(arguments[i]);        // args.push(&#x27;arguments[&#x27; + i + &#x27;]&#x27;);    &#125;    // eval(&#x27;context.fn(&#x27; + args +&#x27;)&#x27;);    context.fn(...args);    delete context.fn;&#125;// 测试一下var foo = &#123;    value: 1&#125;;function bar(name, age) &#123;    console.log(name)    console.log(age)    console.log(this.value);&#125;bar.call_2(foo, &#x27;kevin&#x27;,18); bar.call_2_1(foo, &#x27;kevin&#x27;,18); // kevin// 18// 1\n\n1.3 version3模拟代码已经完成 80%，还有两个小点要注意：\n\nthis 参数可以传 null，当为 null 的时候，视为指向 window\n函数是可以有返回值的！\n\n// 第三版Function.prototype.call_3 = function (context) &#123;    var context = context || window;    context.fn = this;    var args = [];    for(var i = 1, len = arguments.length; i &lt; len; i++) &#123;        args.push(&#x27;arguments[&#x27; + i + &#x27;]&#x27;);    &#125;    var result = eval(&#x27;context.fn(&#x27; + args +&#x27;)&#x27;);    delete context.fn    return result;&#125;// 测试一下var value = 2;var obj = &#123;    value: 1&#125;function bar(name, age) &#123;    console.log(this.value);    return &#123;        value: this.value,        name: name,        age: age    &#125;&#125;bar.call_3(null); // 2console.log(bar.call_3(obj, &#x27;kevin&#x27;, 18));// 1// Object &#123;//    value: 1,//    name: &#x27;kevin&#x27;,//    age: 18// &#125;\n\n2 applyapply()方法与call()方法类似，区别在于，方法接收两个参数：函数内 this 的值和一个参数数组。第二个参数可以是 Array 的实例，但也可以是arguments 对象。\n在这里同样给出两个版本：\nFunction.prototype.apply_1 = function (context, arr) &#123;    var context = Object(context) || window;    context.fn = this;    var result;    if (!arr) &#123;        result = context.fn();    &#125;    else &#123;        var args = [];        for (var i = 0, len = arr.length; i &lt; len; i++) &#123;            args.push(&#x27;arr[&#x27; + i + &#x27;]&#x27;);        &#125;        result = eval(&#x27;context.fn(&#x27; + args + &#x27;)&#x27;)    &#125;    delete context.fn    return result;&#125;Function.prototype.apply_2 = function (context, arr) &#123;    var context = Object(context) || window;    context.fn = this;    var result;    if (!arr) &#123;        result = context.fn();    &#125;    else &#123;        result = context.fn(...arr)    &#125;    delete context.fn    return result;&#125;// 测试一下var value = 2;var obj = &#123;    value: 1&#125;function bar(name, age) &#123;    console.log(this.value);    return &#123;        value: this.value,        name: name,        age: age    &#125;&#125;bar.apply_2(null); // 2console.log(bar.apply_2(obj, [&#x27;kevin&#x27;,18]));\n\n","categories":["JavaScript"],"tags":["JavaScript","前端","模拟实现"]},{"title":"JS深入学习(4)：作用域","url":"/2022/01/16/JS-%E4%BD%9C%E7%94%A8%E5%9F%9F/","content":"拿一个经典的例子引入：\nvar value = 1;function foo() &#123;    console.log(value);&#125;function bar() &#123;    var value = 2;    foo();&#125;bar();// 结果是 ???\n\n读者决策控制台的输出是?，实际上是1而不是2，是不是出乎意料。这就要靠JS作用域来解释这个现象。\n1 词法作用域作用域是指程序源代码中定义变量的区域。作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。\n在编程语言中，作用域一般有两种工作模式。一种是应用最为普遍的词法作用域，另外一种叫做动态作用域。JavaScript 采用**词法作用域(lexical scoping)**，也就是静态作用域。\n词法作用域一句话解释：函数的作用域在函数定义的时决定。还是拿开头的例子解释：\nvar value = 1;function foo() &#123;    console.log(value);&#125;function bar() &#123;    var value = 2;    foo();&#125;bar();// 结果是 ???\n\n如果是动态作用域，当执行到foo()函数时，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。\n而词法作用域下，执行 foo() 函数，先从 foo() 函数内部查找是否有局部变量 value，如果没有，就在函数声明的位置，查找 value的值等于 1，所以结果会打印 1。\n这里的位置是一个比较笼统的概念，之后会专门解释一个执行上下文的概念。\n2 参考【1】JavaScript高级程序设计（第四版）\n【2】JavaScript深入之词法作用域和动态作用域 · Issue #3 · mqyqingfeng/Blog (github.com)\n【3】JavaScript词法作用域 - 知乎 (zhihu.com)\n","categories":["JavaScript"],"tags":["JavaScript","前端"]},{"title":"leetcode-三数之和","url":"/2022/01/20/leetcode-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","content":"给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。\n注意：答案中不可以包含重复的三元组。\n示例 1：\n输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]\n\n示例 2：\n输入：nums = []输出：[]\n\n示例 3：\n输入：nums = [0]输出：[]\n\n提示：\n\n0 &lt;= nums.length &lt;= 3000\n-105 &lt;= nums[i] &lt;= 105\n\n1 思路本题最简单的想法就是通过三层循环来寻找满足条件的数组，再去重，其时间复杂度为，一定会超时，所以我们需要想办法缩减搜索空间，😧😧好难想呀：\n将数组先排序，满足条件的题解(a, b, c)有的特点，当第二重循环往后枚举一个元素b’时，由于那么满足的 c’一定有，即在数组中一定出现在 c 的左侧。也就是说，我们可以从小到大枚举 b，同时从大到小枚举 c，即第二重循环和第三重循环实际上是并列的关系。\n利用两个指针表示上面的遍历过程。注意：当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从减少至O(N)。\n为了防止重复，对于每一重循环而言，相邻两次枚举的元素不能相同，否则也会造成重复。举个例子，如果排完序的数组为[0, 1, 2, 2, 2, 3]，我们使用三重循环枚举到的第一个三元组为 (0, 1, 2)，如果第三重循环继续枚举下一个元素，那么仍然是三元组 (0, 1, 2)，产生了重复。因此我们需要将第三重循环「跳到」下一个不相同的元素，即数组中的最后一个元素 3，枚举三元组 (0, 1, 3)。\n2 代码实现/** * @param {number[]} nums * @return {number[][]} */var threeSum = function(nums) {    nums = nums.sort(function(a, b){return a-b});// 排序    var res = [];    if(nums.length &lt;3)        return res;        for(let i=0;i&lt;nums.length;i++){        if(nums[i]&gt;0)            break;        if(nums[i] === nums[i-1])//去除上一轮循环的重复情况            continue;        let target = -nums[i];        // 初始化双指针        let second = i+1;        let third= nums.length-1;        while(second &lt; third){            if(nums[second] + nums[third] === target){                res.push([nums[i],nums[second],nums[third]]);                while(nums[second] === nums[second+1])second++;                while(nums[third] === nums[third-1])third--;                second++;//跳转到不同的值                third--;//跳转到不同的值            }else if(nums[second] + nums[third] &lt; target){                second++;            }else{                third--;            }                   }    }    return res;};\n\n3 复杂度分析\n时间复杂度：，其中 N 是数组的长度。\n空间复杂度：除去存储答案的空间，空间复杂度与排序的方法有关\n\n\n","categories":["LeetCode","双指针"],"tags":["JavaScript","LeetCode","双指针","缩减搜索空间"]},{"title":"leetcode(1)整数除法","url":"/2022/01/12/leetcode-%E6%95%B4%E6%95%B0%E9%99%A4%E6%B3%95/","content":"刷题第一天，果然万事开头难呀，第一天就来一个狠角色😢😢，简单的方法一直超时⌛⌛，看了题解才解决，果然还是有点菜。上题目：\n给定两个整数 a 和 b ，求它们的除法的商 a/b ，要求不得使用乘号 '*'、除号 '/' 以及求余符号 '%' 。注意：\n\n整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2\n\n\n假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231−1]。本题中，如果除法结果溢出，则返回 231 − 1\n\n 示例 1：\n输入：a = 15, b = 2输出：7解释：15/2 = truncate(7.5) = 7\n\n示例 2：\n输入：a = 7, b = -3输出：-2解释：7/-3 = truncate(-2.33333..) = -2\n\n示例 3：\n输入：a = 0, b = 1输出：0\n\n示例 4：\n输入：a = 1, b = 1输出：1\n\n1 思路先考虑边界情况：如果除法结果溢出，那么我们需要返回  作为答案。因此在编码之前，我们可以首先对于溢出或者容易出错的边界情况进行讨论：\n\n当被除数为 32 位有符号整数的最小值时：\n如果除数为 1，那么我们可以直接返回答案；\n如果除数为 −1，那么答案为 ，产生了溢出。此时我们需要返回 。\n\n\n当除数为 32 位有符号整数的最小值  时：\n如果被除数同样为 ，那么我们可以直接返回答案 1；\n对于其余的情况，我们返回答案 0。\n\n\n当被除数为 0 时，我们可以直接返回答案 0。\n\n如果我们将被除数和除数都变为正数，那么可能会导致溢出。例如当被除数为 -2^{31}−1时，它的相反数 2^{31}产生了溢出。因此，我们可以考虑将被除数和除数都变为负数，这样就不会有溢出的问题，在编码时只需要考虑 1 种情况了。\n根据讨论，我们记被除数为 X，除数为 Y，并且 X 和 Y 都是负数。我们需要找出 X/Y 的结果 Z。Z 一定是正数或 0。根据除法以及余数的定义，我们可以将其改成乘法的等价形式，即：\n如果只用减法来模拟除法（减去一个除数，商+1，直到被除数小于除数）的方法，整个算法的时间复杂度为，为了优化算法，采用近似二分查找的方式：按照除数x2的幂次扩大除数，直到大于被除数。保留之前的所有中间结果，再反向遍历之前的中间结果(除数x2的幂次)，每次都减去该值，商加上该幂次，直到无法再减去。负数整个过程取反，以-15/-2为例：\n\n初始数组为[-2]，商=0\n，-15-(-4)&lt;0$，将-4添加到数组中[-2,-4]\n，-15-(-8)&lt;0$，将-8添加到数组中[-2,-4,-8]\n，-15-(-16)&gt;0$，进入反向遍历\n-15&lt;-8，商+(1&lt;&lt;2=4)=4，-15-(-8)=-7\n-7&lt;-4，商+(1&lt;&lt;1=2)=6，-7-(-4)=-3\n-3&lt;-2，商+(1&lt;&lt;0)=7，-3-(-2)=-1\n除数与被除数都是负数，输出商为7\n\n2 代码实现用JS编写：\nvar divide = function(dividend, divisor) {    const MAX_VALUE = 2 ** 31 - 1, MIN_VALUE = -(2 ** 31);    // 考虑被除数为最小值的情况    if (dividend === MIN_VALUE) {        if (divisor === 1) {            return MIN_VALUE;        }        if (divisor === -1) {            return MAX_VALUE;        }    }    // 考虑除数为最小值的情况    if (divisor === MIN_VALUE) {        return dividend === MIN_VALUE ? 1 : 0;    }    // 考虑被除数为 0 的情况    if (dividend === 0) {        return 0;    }        // 一般情况，使用类二分查找    // 将所有的正数取相反数，这样就只需要考虑一种情况    let rev = false;    if (dividend &gt; 0) {        dividend = -dividend;        rev = !rev;    }    if (divisor &gt; 0) {        divisor = -divisor;        rev = !rev;    }    const arr = [divisor];    let index = 0;    // 注意溢出    while (arr[index] &gt;= dividend - arr[index]) {        arr.push(arr[index] + arr[index]);        ++index;    }    let ans = 0;    for (let i = arr.length - 1; i &gt;= 0; --i) {        if (arr[i] &gt;= dividend) {            ans += 1 &lt;&lt; i;            dividend -= arr[i];        }    }    return rev ? -ans : ans;};\n\n3 复杂度分析\n时间复杂度：：时间复杂度即为二分查找的时间，由于保存了中间过程，比其他的算法快上不少\n空间复杂度：：数组保存中间过程\n\n\n\n","categories":["LeetCode"],"tags":["JavaScript","LeetCode"]},{"title":"leetcode(2)两数相加","url":"/2022/01/13/leetcode-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","content":"今天是刷题的第二天😘😘，这道题不难，中间被双指针绕的有点晕。话不读说直接看题目：\n给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n示例 1：\n\n\n输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807\n\n示例 2：\n输入：l1 = [0], l2 = [0]输出：[0]\n\n示例 3：\n输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1]\n\n1 思路主要思路为：我们同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个 0。\n对于链表的遍历，一般只需要一个指针即可，而对于添加链表则需要两个指针一前一后：\n\n前指针指向当前节点\n后指针指向本次新加入的节点\n\n同时我们还需要保留头指针用于输出。本题还需注意在个链表都遍历完后还需要判断一下是否有进位。\n2 代码实现/** * Definition for singly-linked list. * function ListNode(val, next) { *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * } *//** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */var addTwoNumbers = function(l1, l2) {    let res = new ListNode(0,null);// 初始化头指针    if(l1.val === 0 &amp;&amp; l2.val === 0 &amp;&amp; l1.next===null &amp;&amp; l2.next===null)// 特殊情况直接输出        return res;    let carry = false;// 用于表示上一轮是否有进位 js中flase=0，true=1    let ptr = null;// 当前节点    while(l1 !== null || l2 !== null){        // 当一方链表为空时构造一个val=0的节点        if(l1 === null)            l1 = new ListNode(0,null);        if(l2 === null)            l2 = new ListNode(0,null);\t\t// 新节点        let newptr = new ListNode(0,null);        let sum = l1.val+l2.val+carry;        // 判断是否溢出        if(sum &gt;= 10){            carry = true;            sum -=10;        }else{            carry = false;        }        // 节点赋值        newptr.val = sum;        newptr.next = null;        if(ptr === null)// 第一轮            res = newptr;//设置起始指针        else            ptr.next = newptr;// 设置下一节点                ptr = newptr;// 当前指针右移\t\t        l1 = l1.next;        l2 = l2.next;    }    if(carry === true){// 最后考虑是否有进位        let newptr = new ListNode(1,null);        ptr.next = newptr;    }    return res;};\n\n3 复杂度分析\n时间复杂度：，其中 m 和 n 分别为两个链表的长度。我们要遍历两个链表的全部位置，而处理每个位置只需要 O(1) 的时间。\n空间复杂度：，主要保存两个指针以及一些中间变量。\n\n🎉🎉还可以：\n\n","categories":["LeetCode","链表"],"tags":["JavaScript","LeetCode","链表"]},{"title":"leetcode-最长公共前缀","url":"/2022/01/19/leetcode-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/","content":"编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 \"\"。\n 示例 1：\n输入：strs = [\"flower\",\"flow\",\"flight\"]输出：\"fl\"\n\n示例 2：\n输入：strs = [\"dog\",\"racecar\",\"car\"]输出：\"\"解释：输入不存在公共前缀。\n\n提示：\n\n1 &lt;= strs.length &lt;= 200\n0 &lt;= strs[i].length &lt;= 200\nstrs[i] 仅由小写英文字母组成\n\n一 思路这题轻松拿下😘😘，但是看了题解发现有更好的思路没有想到😢😢。先介绍我的思路：\n纵向扫描：从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，当前列之前的部分为最长公共前缀。\n\n\n但是此题还有一种常见的思路就是分治法，将问题的规模进行divide，每次将数组二分，这样就得到了两个子问题，每个子问题是原问题的1/2规模。\n在求解到每个子问题的最长匹配后收集答案，选出公共的部分。\n\n\n二 代码实现纵向扫描：\n/** * @param {string[]} strs * @return {string} */var longestCommonPrefix = function(strs) {    let res = '';// 记录答案    let ptr = 0;// 遍历指针    let flag = true;// 标记是否结束    while(flag){        let char = strs[0][ptr];        if(char === undefined)// 当遍历超过字符串长度            break;        for(let i=1;i&lt;strs.length;i++){            if(strs[i][ptr] !== char){                flag = false;                break;            }            }        if(flag === true){            res += char;            ptr++;        }else{            break;        }    }    return res;};\n\n分治法（官方）：\nclass Solution {public:    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) {        if (!strs.size()) {            return \"\";        }        else {            return longestCommonPrefix(strs, 0, strs.size() - 1);        }    }    string longestCommonPrefix(const vector&lt;string&gt;&amp; strs, int start, int end) {        if (start == end) {            return strs[start];        }        else {            int mid = (start + end) / 2;            string lcpLeft = longestCommonPrefix(strs, start, mid);// divide            string lcpRight = longestCommonPrefix(strs, mid + 1, end);            return commonPrefix(lcpLeft, lcpRight);// combine        }    }    string commonPrefix(const string&amp; lcpLeft, const string&amp; lcpRight) {        int minLength = min(lcpLeft.size(), lcpRight.size());        for (int i = 0; i &lt; minLength; ++i) {            if (lcpLeft[i] != lcpRight[i]) {                return lcpLeft.substr(0, i);            }        }        return lcpLeft.substr(0, minLength);    }};\n\n三 复杂度分析\n时间复杂度分析：\n纵向扫描：，其中 m 是字符串数组中的字符串的平均长度，n 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。\n分治：递推式是，由主定理得\n\n\n空间复杂度分析：\n\n\n","categories":["LeetCode","分治"],"tags":["JavaScript","LeetCode","分治"]},{"title":"leetcode(3)最长回文串","url":"/2022/01/14/leetcode-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/","content":"给你一个字符串 s，找到 s 中最长的回文子串。\n示例 1：\n输入：s = \"babad\"输出：\"bab\"解释：\"aba\" 同样是符合题意的答案。\n\n示例 2：\n输入：s = \"cbbd\"输出：\"bb\"\n\n示例 3：\n输入：s = \"a\"输出：\"a\"\n\n示例 4：\n输入：s = \"ac\"输出：\"a\"\n\n提示：\n\n1 &lt;= s.length &lt;= 1000\ns 仅由数字和英文字母（大写和/或小写）组成\n\n1 思路博主一开始也想到了动态规划（有最优子结构），但是最后还是尝试用简单方法处理这道题，结果被一个问题难住了，我的思路是首尾维护两个指针，一点一点的向中间逼近，但是无论是从首到尾遍历还是从尾到首遍历都会漏掉回文串。这是错误的。还是老老实实用DP：\n用 P(i,j) 表示字符串 s 的第 i 到 j 个字母组成的串（下文表示成 s[i:j]）是否为回文串：\n\nP(i,j) = true，s的子串也是回文串\np(i,j) = false，s[i,j] 本身不是一个回文串或i&gt;j，此时 s[i,j] 本身不合法。\n\n因此写出Bellman方程：其他\n2 代码实现采用自顶向下的动态规划实现算法：\n/** * @param {string} s * @return {string} */var longestPalindrome = function(s) {    var p = new Array();    for(var i=0;i&lt;s.length;i++){        p[i] = new Array();        for(var j=0;j&lt;s.length;j++){// 初始化            if(i === j)    \t        p[i][j] = true;            else if(j === i+1)                p[i][j] = (s[i] === s[j])            else                p[i][j] = -1;        }    }\t// 记录最长回文子串的左右边界    let Palindrome_l = 0;    let Palindrome_r = 0;\t// 递归方法    let isPalindrome = function(l,r){        if(p[l][r] !== -1)            return p[l][r];        p[l][r] = isPalindrome(l+1,r-1) &amp;&amp; (s[l] === s[r]);        return p[l][r];    };    for(let i = 0;i&lt;s.length;i++){        for(let j = i+1;j&lt;s.length;j++){            if(isPalindrome(i,j) === true){                if(j-i&gt;Palindrome_r-Palindrome_l){                    // 有更长的回文子串\t\t\t\t\tPalindrome_r = j;\t\t\t\t\tPalindrome_l = i;\t\t\t\t}            }                    }    }    return s.substring(Palindrome_l,Palindrome_r+1)};\n\n以babad为例，打印p二维数组的结果为：\n[ true, false, true, false, false ],[ -1, true, false, true, false ],[ -1, -1, true, false, false ],[ -1, -1, -1, true, false ],[ -1, -1, -1, -1, true ]\n\n3 复杂度分析\n时间复杂度：其中 n 是字符串的长度。动态规划的状态总数为 ，对于每个状态，填表查表的时间为常数时间\n空间复杂度：\n\n😢😢不说了，太丑陋了。\n\n","categories":["LeetCode","动态规划"],"tags":["JavaScript","LeetCode","动态规划"]},{"title":"leetcode-盛水最多的容器","url":"/2022/01/17/leetcode-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/","content":"给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n说明：你不能倾斜容器。\n示例 1：\n\n\n输入：[1,8,6,2,5,4,8,3,7]输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n\n示例 2：\n输入：height = [1,1]输出：1\n\n示例 3：\n输入：height = [4,3,2,1,4]输出：16\n\n示例 4：\n输入：height = [1,2,1]输出：2\n\n一 思路这道题目看似简单，做起来才发现不容易。分治法、动态规划都用不上，最简单的就是暴力枚举的办法，但是有的复杂度。苦思冥想想不到更快的算法🤔🤔。在查看了题解后才恍然大悟😲😲，也感觉到了这道题的价值——缩减搜索空间。本题解参考O(n) 双指针解法：理解正确性、图解原理（C++/Java） - 盛最多水的容器 - 力扣（LeetCode） (leetcode-cn.com)\n本题采用双指针的解法，用一句话概括双指针解法的要点：指针每一次移动，都意味着排除掉了一个柱子。\n如下图所示，在一开始，我们考虑相距最远的两个柱子所能容纳水的面积。水的宽度是两根柱子之间的距离 d=8；水的高度取决于两根柱子之间较短的那个，即左边柱子的高度 h=3。水的面积就是 3×8=24。\n\n\n如果选择固定一根柱子，另外一根变化，水的面积会有什么变化吗？稍加思考可得：\n\n当前柱子是最两侧的柱子，水的宽度 d 为最大，其他的组合，水的宽度都比这个小。左边柱子较短，决定了水的高度为 3。如果移动左边的柱子，新的水面高度不确定，一定不会超过右边的柱子高度 7。但可能比当前的容积大\n如果移动右边的柱子，新的水面高度一定不会超过左边的柱子高度 3，也就是不会超过现在的水面高度。且宽度也缩小了，因此一定比当前的容积小。\n\n\n\n因此总结：每次移动都移动高度更小的一侧，记录下当前的容积取最大值。\n下面更直观的感受一下“排除掉一根柱子”、“指针移动”究竟代表着什么，假设柱子的编号从0到n，我们要寻找的是两根柱子i,j，它们需要满足的约束条件是：\n\ni、j 都是合法的柱子下标，即\n\ni 在 j 的左边，即 \n\n\n以 n = 8 为例，这时候全部的搜索空间是：\n\n\n由于 i、j 的约束条件的限制，搜索空间是白色的倒三角部分。可以看到，搜索空间的大小是数量级的。如果用暴力解法求解，一次只检查一个单元格，那么时间复杂度一定是。要想得到的解法，我们就需要能够一次排除多个单元格。那么我们来看看，本题的双指针解法是如何削减搜索空间的：\n一开始，我们检查右上方单元格 (0, 7)，即考虑最左边的 0 号柱子和最右边的 7 号柱子，计算它们之间容纳水的面积。然后我们比较一下两根柱子的高度，关注其中较短的一根。\n\n\n假设左边的 0 号柱子较短。根据刚才的推理，0 号柱子目前的水面高度已经到了上限。由于 7 号柱子已经是离 0 号柱子最远的了，水的宽度也最大，如果换其他的柱子和 0 号柱子配对，水的宽度只会更小，高度也不会增加，容纳水的面积只会更小。也就是说，0 号柱子和号柱子的配对都可以排除掉了。这相当于 i=0 的情况全部被排除。对应于双指针解法的代码，就是 i++；对应于搜索空间，就是削减了一行的搜索空间，如下图所示。\n\n\n排除掉了搜索空间中的一行之后，我们再看剩余的搜索空间，仍然是倒三角形状。我们检查右上方的单元格 (1,7)，即考虑 1 号柱子和 7 号柱子，计算它们之间容纳水的面积。然后，比较两根柱子的高度。\n\n\n假设此时 7 号柱子较短。同理， 7 号柱子已经是离 1 号柱子最远的了，如果换其他的柱子和 1 号柱子配对，水的宽度变小，高度也不会增加，容纳水的面积只会更小。记录了 (1,7) 这组柱子的结果之后，就可以排除 7 号柱子了。这相当于 j=7 的情况全部被排除。对应于双指针解法的代码，就是 j–；对应于搜索空间，就是削减了一列的搜索空间，如下图所示。\n\n\n可以看到，无论柱子 i 和 j 哪根更长，我们都可以排除掉一行或者一列的搜索空间。经过 n 步以后，就能排除所有的搜索空间，检查完所有的可能性。搜索空间的减小过程如下面动图所示：\n\n\n二 代码实现/** * @param {number[]} height * @return {number} */var maxArea = function(height) {    let res = 0;    let l = 0    let r = height.length-1;    while(l &lt; r){        let volume = (r-l)*Math.min(height[l],height[r]);        res = res&lt;volume?volume:res;        if(height[l]&lt;height[r])            l++;        else            r--;    }    return res;};\n\n三 复杂度分析\n时间复杂度：因为双指针沿数组收缩，只遍历了一遍，时间复杂度为\n空间复杂度：\n\n不说了，大佬nb，😘😘\n\n","categories":["LeetCode","双指针"],"tags":["JavaScript","LeetCode","双指针","缩减搜索空间"]},{"title":"实验：bagging集成学习预测Titanic数据集","url":"/2022/01/10/%E5%AE%9E%E9%AA%8C%EF%BC%9Abagging%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%E9%A2%84%E6%B5%8BTitanic%E6%95%B0%E6%8D%AE%E9%9B%86/","content":"实验要求用集成方法对数据集进行分类\n\n利用若干算法，针对同一样本数据训练模型，使用投票机制，少数服从多数，用多数算法给出的结果当作最终的决策依据，对Titanic数据集 进行分类，给出在测试集上的精确度； \n\n除了投票法，其他的集成学习方法也可以。 \n\n实验来自kaggle入门赛 https://www.kaggle.com/c/titanic ,可以参考原网站 代码与预处理部分，但与公开代码不同的在于，集成学习所用的基学习 器需要自己实现而不能调用sklearn库。 \n\n数据集的分析是一个开放性问题，可以参考网站中的预处理方式。 \n\n所选算法包括但不限于课堂上学习的模型例如： 决策树 SVM KNN  神经网络\n\n需要在网站上提交，不要求结果很高，但要求模型自己实现，如果有优化可以加分\n\n\n实验思路主要采用bagging集成学习方法，Bagging原理可见另一篇博客(16条消息) 集成学习(ensemble learning)_Sunburst7的博客-CSDN博客。子学习器采用贝叶斯决策论进行决策，对于训练集，我们进行5次有放回的随机抽样，得到5个训练子集，然后用这五个训练子集分别进行决策，得到5个分类结果，再进行投票决定最终的分类结果。\nTitanic数据字典：\n\n\n\nVariable\nDefinition\nKey\n\n\n\nsurvival\nSurvival\n0 = No, 1 = Yes\n\n\npclass\nTicket class，社会地位\nA proxy for socio-economic status (SES)，1 = 1st, 2 = 2nd, 3 = 3rd\n\n\nName\n乘客姓名\n\n\n\nsex\nSex\n\n\n\nAge\nAge in years\n\n\n\nsibsp\n# of siblings / spouses aboard the Titanic\n\n\n\nparch\n# of parents / children aboard the Titanic\n\n\n\nticket\nTicket number\n\n\n\nfare\nPassenger fare\n\n\n\ncabin\nCabin number\n\n\n\nembarked\nPort of Embarkation 出发港\nC = Cherbourg, Q = Queenstown, S = Southampton\n\n\n连接训练集与测试集，查看缺失值：\ntrain = pd.read_csv(\"train.csv\")test = pd.read_csv(\"test.csv\")df = pd.concat([train, test], axis=0)df = df.set_index('PassengerId')print(df.info())\n\n控制台输出：\nInt64Index: 1309 entries, 1 to 1309Data columns (total 11 columns): #   Column    Non-Null Count  Dtype  ---  ------    --------------  -----   0   Survived  891 non-null    float64 1   Pclass    1309 non-null   int64   2   Name      1309 non-null   object    3   Sex       1309 non-null   object  4   Age       1046 non-null   float64 5   SibSp     1309 non-null   int64   6   Parch     1309 non-null   int64   7   Ticket    1309 non-null   object    8   Fare      1308 non-null   float64 9   Cabin     295 non-null    object   10  Embarked  1307 non-null   object dtypes: float64(3), int64(3), object(5)\n\nCabin特征因为有太多的缺失值，所以决定舍弃它，本次不进行语义分析，因此乘客姓名Name，船票编号Ticket人人各不相同，也被舍弃。\n\n总体分析Age,Pclass,Sex对于Survived的影响：\n  import seaborn as snssns.set_theme(font_scale=1.5)sns.displot(data=df,hue='Sex', x='Age',row='Survived',col='Pclass')plt.show()\n\n  \n\n  第一行的乘客是那些没有存活下来的乘客，似乎大部分是来自Pclass=3的男性。幸存者大多是女性(第二行)。因此，Age和Pclass是生存的重要指标，年龄则不那么重要。\n\n仔细分析Age-Survived\n  sns.catplot(data=df,hue='Sex', x='Kind',row='Survived',col='Pclass', kind='count')plt.show()\n\n  `Pclass=1或2` 所有孩子都活下来了，也许这对我们有所帮助，所以我们保留`Age`这个特征，似乎儿童作为一个整体(年龄&lt;=15岁以上)比成年人生存得更好。因此可以粗略的将年龄分为成年人（`Age&gt;15`）与未成年人（`Age`&lt;=15)\n观察出发港Embarked\n  sns.catplot(data=df,hue='Sex', x='Embarked',col='Survived',kind='count')plt.show()\n\n  \n\n  从Southampton 出发的男性存活得较少(也许他们是在三等舱?)，但大约75%的南安普顿女性存活了下来，对于从Cherbourg出发的人来说，关系就相反了。所以Embarked也很重要。\n\nFare表示船票价格：乘客要花更多的钱才能坐头等舱，但这对他们的生存并没有太大的帮助。去除该特征\n\n\n因此留下的有意义的特征属性如下：\n\n\n\nVariable\nDefinition\nKey\n\n\n\nsurvival\nSurvival，预测标签\n0 = No, 1 = Yes\n\n\npclass\nTicket class，社会地位\nA proxy for socio-economic status (SES)，1 = 1st, 2 = 2nd, 3 = 3rd\n\n\nsex\nSex\n\n\n\nAge\nAge in years\n\n\n\nsibsp\n# of siblings / spouses aboard the Titanic\n\n\n\nparch\n# of parents / children aboard the Titanic\n\n\n\nembarked\nPort of Embarkation 出发港\nC = Cherbourg, Q = Queenstown, S = Southampton\n\n\n实验代码import mathimport numpy as npimport pandas as pdimport seaborn as snsimport matplotlib.pyplot as plt# 按照众数填充缺失值def fillMissingColumn(dataframe: pd.DataFrame):    # 检测出有缺失值的列，返回一个Series，有缺失值的列为True，无缺失值的列为False    missing_column = dataframe.isnull().any(axis=0)  # 按列检测    for index, value in missing_column.items():        if value:            print(index + \" needs to fill missing values\")            # 利用众数填充有缺失值的行            dataframe[index].fillna(dataframe[index].mode()[0], inplace=True)  # 一定要设置inplace=True 修改内存的值# 贝叶斯分类器，输入一个向量，输出预测标签           def classifier(x, train: pd.DataFrame):    # 分别存活的情况与没有存活的情况 0-死亡 1-存活    type0 = train[train['Survived'] == 0]    type1 = train[train['Survived'] == 1]    # 计算行数    sum_type0 = type0.count().values[0]    sum_type1 = type1.count().values[0]    # 计算先验概率    prior_0 = sum_type0/(sum_type0+sum_type1)    prior_1 = sum_type1/(sum_type0+sum_type1)    # print(str(prior_0) + \" \" + str(prior_1))    # 初始化分类器值(加上lnp(w))    g0 = math.log(prior_0)    g1 = math.log(prior_1)    # print(str(g0) + \" \" + str(g1))    # 计算所有列的似然/类条件概率密度    for column in train.columns:        if column != 'Survived':# 去除预测标签的影响            # print(column)            # 计算拉普拉斯平滑后的似然            likelihood0 = (type0[type0[column] == x[column]].count().values[0] + 1) / (sum_type0 + train[column].nunique())            likelihood1 = (type1[type1[column] == x[column]].count().values[0] + 1) / (sum_type1 + train[column].nunique())            # 取对数            ln_likelihood0 = math.log(likelihood0)            ln_likelihood1 = math.log(likelihood1)            # print(\"type0: likelihood: \" + str(likelihood0) + \" ln:\" + str(ln_likelihood0))            # print(\"type1: likelihood: \" + str(likelihood1) + \" ln:\" + str(ln_likelihood1))            g0 += ln_likelihood0            g1 += ln_likelihood1            # print('------------------------------------------------------------------')    # print(str(g0) + \" \" + str(g1))    if g0&gt;=g1:        # 预测为无法存活        return 0    else:        return 1# Load_Datatrain = pd.read_csv(\"train.csv\")test = pd.read_csv(\"test.csv\")# EDA 数据预处理df = pd.concat([train, test], axis=0)df = df.set_index('PassengerId')df['Age'] = df['Age'].map(lambda x:'Adult' if x &gt;15 else 'Child')df['Embarked'] = df['Embarked'].fillna('S')df = df.drop(['Name', 'Ticket', 'Cabin','Fare'], axis=1)# 填充缺失值fillMissingColumn(df)print(df.info())mapper = {    'Sex':{        'male':0,        'female':1    },    'Embarked':{        'C':0,        'Q':1,        'S':2,    }}# 特征数字化df.replace(mapper,inplace=True)print(df.head())# 分割训练集与测试集test = df.iloc[891:1309:1,:]train = df.iloc[0:891:1,:]SamplesArray = []for i in range(5):    # 有放回的随机抽样 抽样占比63%    SamplesArray.append(train.sample(frac=1,replace=True,axis=0))# 保存分类器的分类结果isSurvived = []for index,row in test.iterrows():    tmp = []    # 对于每一个测试集数据，放到5个子分类器中进行分类，保存子分类器分类结果    for i in range(5):        tmp.append(classifier(row,SamplesArray[i]))    isSurvived.append(tmp)# 投票决定最终预测vote = []for item in isSurvived:    SurvivedCount = str(item).count('1')    if SurvivedCount &gt; 2:        vote.append(1)    else:        vote.append(0)test['forecast_by_vote'] = vote# 输出预测结果for index,row in test.iterrows():    if row['forecast_by_vote'] == 1:        print(\"PassengerId: \" + str(index) + \", forecast: can Survive\")    else:        print(\"PassengerId: \" + str(index) + \", forecast: can't Survive\")# 写入CSVprint('write prediction to file:submission.csv')test['PassengerId'] = test.indextest[['PassengerId','forecast_by_vote']].to_csv('submission.csv', index=False)\n\n实验结果运行控制台截图，控制台输出每个测试乘客的预测结果，同时将结果写入到submission.csv中：\n\n\n在Kaggle网站上提交，正确率为76%，还有待提高：\n","categories":["机器学习"],"tags":["机器学习","python"]},{"title":"最大似然估计与贝叶斯估计","url":"/2022/01/10/%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%E4%B8%8E%E8%B4%9D%E5%8F%B6%E6%96%AF%E4%BC%B0%E8%AE%A1/","content":"参数估计在贝叶斯决策论中，我们已经学习了如何根据先验概率与类条件概率密度来设计最优分类器。但在实际应用中，通常得不到有关问题的概率结构的全部信息。通常的解决方案是利用这些训练样本来估计问题中所涉及的先验概率和类条件密度函数，并把这些估计的结果当做实际问题的先验概率和类条件概率密度，然后在设计分类器\n在典型的监督学习问题中，有标注的样本估计先验概率不困难，最大的困难在于估计类条件概率密度：\n\n已有的训练样本数太少，很难满足所有的特征都存在的情况\n当用于表示特征的向量x的维数较大时，就会产生严重的计算复杂度问题（算法的执行时间，系统的资源开销..）\n\n但如果先验知识允许我们把条件概率密度进行参数化，例如：我们可以假设是一个多元高斯分布，其均值是，协方差矩阵为。这样我们就把问题从估计完全未知的类条件概率密度转化为了估计参数与。这样的方法被称为参数估计方法。与之对应的也有非参数估计方法。\n参数估计问题是统计学中的经典问题，主要的解决方案有两种，分别对应统计学中的两大学派：\n\n最大似然估计——频率学派（Frequentist）\n贝叶斯估计——贝叶斯学派（Bayesian）\n\n当然，在参数估计完成后，我们仍然使用后验概率作为分类准则。\n最大似然估计参数分量根据每个样本所属的类别对样本集进行分类：，任意一个分类样本集中的样本都是独立的根据类条件概率密度函数来抽取的。因此获得一个重要假设：**每个样本集中的样本都是独立同分布的随机变量(independent and identically distributed：i.i.d)**，我们还假设每一个类的类条件概率密度的形式都是已知的，未知的是具体的参数向量的值。比如：假设服从多维正态分布，这样向量就由分量所组成。\n为了强调类条件概率密度函数依赖于参数向量的情况，通常写为形如的形式。因此最大似然估计（MLE）解决的就是正确的估计各个类别的具体的参数向量：。\n基本原理问题其实就变成了一个条件概率最大的求解，即在已有的训练集的条件下，求使得 最大的参数，形式化表达为求解而根据条件概率公式有因为我们在极大似然估计中假设是确定的，所以就是一个常数。同样是根据已有的数据得到的，也是确定的，或者我们可以把其看作是对整个概率的一个归一化因子。这时候，求解公式 (1) 就变成了求解一个有监督的总的样本集分为c类，我们要估计每个类的后验概率，有c个独立的问题，每个问题解决思路相同如下：已知样本集中有n个样本。由于这些样本独立同分布，因此由（3）中的似然函数得：【2】因为样本集已知，可以看作是参数向量的函数，**参数向量的最大似然估计，就是使似然函数：达到最大值的参数向量，记为**。为了方便分析取对数，定义对数似然函数：\n如果实际的待求参数的个数为p，则参数向量可以写成如下的p维向量的形式：。记为梯度算子（构建求偏导数的数学式）这样用数学语言表示求的全过程：\n\n\n注意：求得的解可能是全局最大值点，也可能是局部极值点。\n高斯情况深入讨论当训练样本服从多元正态分布时的情况。\n协方差矩阵已知，而均值未知\n\n\n\n我们得到以下结论，对于均值的最大似然估计就是对全体样本取平均。\n协方差矩阵和均值都未知高斯分布的更典型的情况是协方差矩阵和均值都未知。这样参数向量由两个分量组成。\n\n先考虑单变量的情况\n  \n\n  \n当高斯函数是多元时，最大似然估计的结果是：  \n  均值的最大似然估计就是样本的均值，而协方差的最大似然估计是n个的算术平均。实际上对方差的最大似然估计是有偏的估计，样本的协方差矩阵，而我们估计的方差是\n\n\n&gt; 样本协方差矩阵的推导过程【2】：\n&gt;\n&gt; {% asset_img dff0de718d34e83e9fd3f6c931675889_720w-16418259715585.jpg dff0de718d34e83e9fd3f6c931675889_720w %}\n\n贝叶斯估计基本原理\nMLP通过最大化似然函数从而找出参数，思想在于找出能最大概率生成这批数据的参数。但是这种做法完全依赖于数据本身，当数据量大的时候，最大似然估计往往能很好的估计出参数 ；但是当数据量小的时候，估计出来的结果并不会很好。就例如丢硬币问题，当我们投掷了5次，得出了正正正正正的结果，极大似然估计会得出投出正面的概率为100%！这显然是不符常理的。\n贝叶斯派的人认为，后验概率中被估计的参数同样服从一种已知的分布，即参数也为一个随机变量。他们在估计参数前会先带来先验知识，例如参数在[0.5,0.6]的区域内出现的概率最大，在引入了先验知识后利用样本估计出参数分布的形式，在数据量小的情况下估计出来的结果往往会更合理。【2】\n\n我们希望利用现有的全部信息来为测试样本x计算分类的依据：后验概率（现有的全部信息一部分为我们的先验知识，比如未知概率密度函数的形式，未知参数取值范围；另一部分则来自训练集本身），假设已有训练集，改写后验概率为：表示训练集的重要性，则贝叶斯公式为：\n\n这一公式指出我们能够根据训练样本提供的信息来确定类条件概率密度和先验概率。\n\n通常认为先验概率可以事先得到，或简单计算得到，可以简写为\n\n有监督学习可以把每个样本都归到它所属的类中，如果，那么样本集中的训练样本就对没有任何影响，这样就产生两个简化：\n\n能够对每一个类分别处理：只是用中的训练样本就能确定\n能够对每个类进行分别处理，公式中说明类别的符号都可以省略\n\n  本质上我们处理的是c个独立的问题，每个问题形式：已知一组训练样本D，根据这些样本估计（未简化为）\n\n\n\n参数估计法的前提是每个类的类条件概率密度形式已知，参数向量未知。对于任意一个测试样本x，去除类符号简化为且形式已知。而贝叶斯估计与最大似然估计的区别体现在，我们不认为是一个固定但未知的值，而是服从一个概率分布。根据、、与，我们可以得到未知参数的后验概率密度函数其中【这里是训练样本集的某一个样本】接着根据积分估算测试样本的后验概率：由于对测试样本x和训练样本集D的选取是独立进行的，，公式(10)改为：\n总结整个贝叶斯估计分为三个阶段：\n\n根据样本与先验知识求得参数的后验概率\n根据参数的后验概率与类条件概率密度的形式求得每个类的具体的类条件概率密度\n最后求出每个类的后验概率\n\n\n\n\n高斯情况下的贝叶斯估计对高斯正态分布的情况，用贝叶斯估计的方法来计算未知参数的后验概率密度函数和设计分类器所需的类条件概率密度函数，其中假设（相当于第一步中的）\n单变量情况第一步：先考虑只有均值未知的情况，同时假设特征向量是一维的。，而且我们认为所有关于均值的先验知识都在先验概率密度函数中，且均值服从（已知），根据3.1节总结的贝叶斯估计三步走：\n\n\n\n\n我们发现是一个指数函数，且指数部分是的二次型，因此实际上任然是正态分布，把写成下面的形式：\n\n\n利用对应位置系数相等的原则就可以求出的值：\n\n\n上述方程显示了先验知识和样本观测结果是如何被结合在一起，并且形成的后验概率密度函数的，总的来说：\n\n代表在观测n个样本后对的真实值的最好估计，是与的线性组合\n\n表示对这种估计的不确定性（取值更离散，不集中）\n\n如果，当n趋近于，趋近于样本均值，\n当时，，这是一种退化的情况：我们对先验估计是如此的确信，以至于任何观测样本都无法改变我们的认知。\n当远大于，表示我们对先验估计如此的不确信以至于直接拿样本均值当做\n\n  根据公式（7），是n的单调递减函数，也就是说每观测一个样本，我们对的估计的不确定性就会减小，当增加时，的概率密度图就会变得更尖锐，当n趋近于无穷大时，逼近狄拉克函数。\n\n\n\n狄拉克δ函数是一个广义函数，在物理学中常用其表示质点、点电荷等理想模型的密度分布，该函数在除了零以外的点取值都等于零，而其在整个定义域上的积分等于1。\n狄拉克δ函数在概念上，它是这么一个“函数”：在除了零以外的点函数值都等于零，而其在整个定义域上的积分等于1。【4】\n\n\n\n单变量情况第二步：在得到均值的后验概率密度后，我们就可以计算类条件概率密度（实际上是，把c个问题独立，去除类有关变量后）\n\n\n\n\n求得类条件概率密度后再带入到公式(19)就能求出后验概率了。\n最大似然估计与贝叶斯估计比较最大似然估计与贝叶斯估计在训练样本趋于无穷时效果是一样的，然而在实际的问题中，训练样本总是有限的，决定我们选择哪个方法的主要因素有\n\n计算复杂度：MLE只涉及一些微分与求极值，而贝叶斯估计计算复杂的积分\n可理解性：MLE是基于设计者所提供的训练样本的一个最佳解答，而贝叶斯估计方法得到的结果则是许多可行解的加权平均值，反映出对各种可行解的不确定程度\n对初始先验知识的信任程度：MLE得到的类条件概率密度形式与先验的假设是一样的，而贝叶斯估计得到的形式可能与初始假设不相同，贝叶斯方法能比MLE利用更多有用的信息。\n\n总结贝叶斯方法有很强的理论基础，但在实际应用中最大似然估计更加简便，且性能也相差无几。\n参考【1】模式分类（第二版）\n【2】(1条消息) 极大似然估计与贝叶斯估计_Jim_Liu-CSDN博客_极大似然估计和贝叶斯估计\n【3】(20 封私信 / 29 条消息) 为什么样本方差（sample variance）的分母是 n-1？ - 知乎 (zhihu.com)\n【4】百度百科：狄拉克δ函数\n","categories":["机器学习"],"tags":["机器学习"]},{"title":"正态密度下的分类器","url":"/2022/01/10/%E6%AD%A3%E6%80%81%E5%AF%86%E5%BA%A6%E4%B8%8B%E7%9A%84%E5%88%86%E7%B1%BB%E5%99%A8/","content":"一个贝叶斯分类器可由条件概率密度p(x|ωi)和先验概率P(ωi)决定。在各种密度函数中，高斯密度函数（多元正态函数）最受青睐。本节我们先从单变量高斯密度函数谈起，接着探讨多元高斯分布以及一些特殊情况下的判别函数。\n单变量高斯密度函数单变量正态或高斯密度函数，变量x遵循x~N(μ,σ^2)，其概率密度函数为：因此可以求出x的期望与方差：\n\n\n\n\n\n\n\n\n\n如中心极限定理所表示，大量的小的、独立的随机分布的总和等效为一个高斯分布，对于实际的概率分布而言高斯分布是一种很好的模型\n\n多元密度函数一般的d维多元正态分布密度及其相关统计量形式如下：\n\n\n其中x是一个d维列向量，μ是x的d维均值向量，Σ 是d*d的协方差矩阵，这里的(x-μ)(x-μ)T是向量的内积。均值向量与协方差矩阵的分量形式可写为：$$\\mu_i = E[\\textbf{x}i]\\\\sigma{ij}=E[(x_i-\\mu_i)(x_j-\\mu_j)]$$多元高斯分布的协方差矩阵有以下性质：\n\n协方差矩阵是对称且半正定的\n\n协方差矩阵的对角线元素表示各维的方差，非对角线元素表明两维之间的协方差。\n\n对于高斯分布来说，独立等价于不相关，所以如果xi与xj统计独立，则。\n\n\n服从正态分布的随机变量的线性组合，不管这些随机变量是独立的还是非独立的，线性组合也是正态分布。多元高斯分布有线性不变性：\n\n\n正态分布下的判别函数我们之前通过后验概率构造的判别函数g(x)：如果类条件概率密度函数p(x|ωi)是多元正态分布N(μi,Σi)，带入表达式可以化简为：其中最后一项与x无关，实际计算过程中可以省略。我们讨论一些特殊情况下的判别函数以及分类结果。\n这种情况发生在各特征统计独立，并且每个特征的具有相同的方差时。这种情况下所有类型的协方差矩阵相同，都是对角矩阵且为单位矩阵I与方差的乘积。因此 ，因此(6)式可以化简为：\n\n\n，继续观察。\n\n\n一个线性分类器的判定面是一些超平面，这些超平面是由线性方程来确定的，以上的例子中，此方程可以写成：\n\n\n继续变换：\n\n\n由于，特征空间中属于i类的类别空间与属于j类的类别空间分开的超平面与两个空间的中心点的连线垂直，当所有类别的先验概率相等时，就是中心点。\n这种情况下，最优判决规则从计算g(x)跟直观的改为——最小距离分类器：为了将某一特征向量x归类，通过测量每一个x到c个均值向量中的每一个欧氏距离（二维平面内的距离），并将x归为离他最近的那一类中。\n\n下图为先验概率相等的情况下的例子：\n  \n当先验概率不相等时判决边界可能出现偏移：\n  \n\n第二种情况是所有类的协方差矩阵都相等，但各自的均值向量是任意的，则由式(6)可得\n\n\n由于判别函数是线性的，判决边界同样是超平面，同3.1 计算与的边界\n\n\n由于并非朝着的方向，因而分离与的超平面也并非与均值间的连线垂直正交，但如果先验概率相等，x0还是均值向量的中心点。\n任意一般情况下，每一类的协方差矩阵都是不同的，式(6)中唯一可以去掉的只有(d/2)ln2π，\n\n\n在两类问题中，判定面是超二次曲面，甚至在一维情况下，其判决区域可以不连通。\n\n\n\n\n\n\n\n\n例：二维高斯分布数据的判决区域\n尝试计算上图的贝叶斯判别边界。以表示红点的集合，表示红点的集合。在这里我们假设只需要计算均值与方差，利用离散随机变量的均值与方差的定义可得。以的计算为例：\n\n\n因此：因为与不相同，与方差也不相同，属于第三类：任意。假设两类分布的先验概率相等（）带入到3.3节的公式中，则的判别边界如图中的顶点是（3 , 1.83）二次曲线，为:尽管两种分布的数据沿方向的方差相等（协方差矩阵的第二行），但判别边界并不通过两均值向量（[3,6]；[3,2]）的中点。这是因为对于分布而言，沿方向的概率分布相比与分布受到挤压（样本沿分布的更宽，且协方差矩阵第一行更大），由于总的先验概率相等（整个特征空间的积分【面积】相等），那么沿方向的分布将要增加（相对于），因此判别边界位于两均值向量的中点偏方向。\n参考【1】模式分类（第二版）\n","categories":["机器学习"],"tags":["机器学习"]},{"title":"非参数估计","url":"/2022/01/10/%E9%9D%9E%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/","content":"在之前的学习中，我们总是假设概率密度函数的参数形式已知，并在此条件下处理有监督学习过程。而在现实世界中，我们给出的概率密度函数很少符合实际情况，本节我们讨论**非参数化方法(non-parametric method)**，它可以处理任意的概率分布而不必假设密度的参数形式已知。大体上还是遵循着贝叶斯决策论，主要有两个非参数估计的方向：\n\n从训练样本中估计类条件概率密度：\n直接估计后验概率：\n\n概率密度的估计估计类条件概率密度的最基本的一个条件就是：一个向量x落在区域中的概率为是在区域上关于的导数的积分（相当于区域R内每个点的概率密度函数的积分，概率密度函数的积分就是概率函数），因此概率是概率密度函数的平滑（或取平均）的版本，因此我们可以通过概率来估计概率密度函数。\n先假设是连续的，并且区域足够小，以至于在这个区间中条件概率密度几乎没有变化，若其中表示区域所包含的体积（二维面积，三维代表体积）有：假设n个样本都是根据概率密度函数独立同分布(i,i,d)的抽取而得到的，其中有k个样本落在区域中的概率服从二项式定理：当样本足够大时，综合(2)式与(3)式，我们能够得到的估计为：让代表区域中样本的确切数量，有：\n\n推导过程如下图所示：\n\n\n类比利用频率直方图估计概率密度函数，理论上当我们的样本足够多，同时频率分布直方图组距设置的特别小，就是在逼近样本点的真实概率密度函数【2】：\n\n\n\n\n为了估计点处的概率密度函数，构造了一系列的包含的区域，其中第一个区域使用一个样本，第二个区域使用2个样本….，记为区域的体积，为落在中的样本的个数，而表示对的第n次估计：要求估计的概率密度函数收敛到真实值：必须满足以下三个条件，以及他们分别代表的意义【3】：\n\n\n\n随着样本数量的增加，体积尽可能小，类比频率分布直方图的组距尽可能小\n在小区域内有足够多的样本，保证频率之比能够收敛到概率\n在小区域内的样本数在总样本中所占的比例是很小的一部分\n\n\n有两种经常采用的估计途径：\n\nParzen窗：根据某一个确定的体积函数，比如，来逐渐收缩一个给定的初始区间。（要求，能保证能收敛到）\nK-nearest-neighbor：确定为n的某个函数，比如，这样体积必须逐渐生长，直到最后能包进的个相邻点。\n\n这两种方法最终都能收敛到真实概率，但在有限样本下效果不好\n\n\nParzen窗方法原理假设区间是一个d维的超立方体，如果表示超立方体一条边的长度，则体积为：，通过定义最简单的方型窗函数，得到训练集中的点是否落在落在窗中：\n'_' allowed only in math mode \\varphi(\\frac{\\textbf{x}-\\textbf{x}’}{h_n})=\\begin{cases} 1 &amp; \\text{|x_j-x_j’|\\leq h_n/2;j=1,…d}\\ 0 &amp; \\text{其他} \\end{cases} 该窗函数定义了一个d维空间中，中心点在点的超立方体。因此代表超立方体中的样本个数是：\n\n\n代入公式（11）得到Parzen窗概率密度函数：\n\n\n窗口函数本质上是出现在该区域内部的采样点的加权频数，可以看做是一种平滑。更一般的，窗函数并不一定是超立方体定义的函数，它可以是任意形式只要保证：\n\n\n\n另一个常见的高斯窗口函数如下：\n\n\n高斯窗口函数，随着采样点与中心点距离的增大而减小。\n当采用高斯窗口函数时，是出现在该区域内部的采样点的加权频数，每个采样点的权重取决于它们与中心的距离。\n\n回过头来看Parzen窗估计的概率密度函数（x代表测试样本，xi代表训练集数据）：表示我们对的估计是对一系列关于和的函数做平均，在本质上，是每一个样本依据它离的远近不同而对结果做出不同贡献。而且在进行估计前要确定一个具体形式的函数\n窗宽的影响我们定义如下，可以重写：\n\n\n因为，窗宽会显著影响的振幅与宽度\n\n\n\n\n\n如果非常大，那么的影响就很低，即使距离很远，和的差别也不大，这种情况下，是n个宽的、满变的函数的叠加，因此非常平滑\n\n如果很小，的峰值就非常大，这种情况下，是n个以样本为中心的尖脉冲的叠加，也就是一个充满噪声（不确定性）的估计\n\n\n\n\n\n的收敛性： 是样本点（随机变量）的函数， 所以我们希望随机变量的均值和方差满足：\n\n\n经过证明需要满足以下条件，证明过程可参考【4】：\n\n\n这就告诉我们对于的选择，当n趋向于正无穷时趋近于0，但必须以低于1/n的速率，因此常设定或\n\n总结：对于窗宽（或）的选取在很大程度上影响。如果太大，那么估计结果的分辨率就太低，如果太小，那么估计结果的统计稳定性就不够。当样本有限时，尽可能的取折中的估计，然而当样本个数无限，那么就可以在n增加时，让缓缓趋近于0，这样就收敛到某个概率密度函数\n下面举一个例子说明窗宽对估计结果的影响：\n\n\ns\n\n\n下图是一个二维Prazen窗的两类分类器，左图是小窗宽，右图为大窗宽\n\n\nK-Nearest Neighbor方法在Parzen窗中，我们固定了体积求解，但最佳的窗函数的选择总是一个问题。另一种思路是固定，让体积进行变化，而不是硬性的规定窗函数为落在区域内的全体样本个数的某个函数。比如我们以样本点为中心，让体积扩张，直到包含个样本为止（是关于n的某个特定函数）。这些样本称为点的个最近邻，带入（一）中的非参数估计公式：\n\n\n后验概率的估计假设我们把一个体积放在点周围，并且能够包含进k个样本，其中个属于类别。对于联合概率密度的估计为：这样对后验概率的估计就是：这里的值可以由Parzen窗与K近邻决定。\n\nParzen窗方法中，必须是关于n的某个固定形式的函数，比如或\nKn最近邻方法中，必须保证能够包含进足够的样本个数，比如\n\n如果有足够多的样本点并且体积足够小就可以证明这样处理是比较准确的。\n最近邻规则最近邻可以看作的k=1情况下的K近邻方法，最近邻规则描述了我们只依赖某个的单一的最近的邻居来做估计，也能达到足够好的性能：令，每个样本已标记，对于测试样本点，在集合D中距离它最近的点的类别为样本点的类别。\n最近邻规则是次优的方法，通常的误差率比贝叶斯误差要高，然而在无限训练样本的情况下，这个误差率至多不会超过贝叶斯误差率的两倍。\n通过最近邻规则，我们可以把样本特征空间分为一个个小的单元格(cell)，每个单元格中的点到最近邻的距离都比到别的样本点的距离要小。这个小单元格中的任意点的类别就与最近邻的类别相同。被称为：空间Voronoi网格。\n\n\n将相同类型的网格的边界相连就可以形成决策边界，最近邻的边界通常是不平滑的，我们可以通过扩大K值来去除噪音，平滑边界。\n\n\n参考【1】模式识别\n【2】非参数估计_音程的博客-CSDN博客_非参数估计\n【3】非参数估计 - 简书 (jianshu.com)\n【4】经典的非参估计 （二）parzen 窗 - 知乎 (zhihu.com)\n","categories":["机器学习"],"tags":["机器学习"]},{"title":"JS深入学习(6)：函数与闭包","url":"/2022/01/19/JS-%E5%87%BD%E6%95%B0%E4%B8%8E%E9%97%AD%E5%8C%85/","content":"函数实际上是对象。每个函数都是 Function 类型的实例，而 Function 也有属性和方法，跟其他引用类型一样。因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定与函数本身紧密绑定。\n函数有两种常见的定义方式：\n\n函数声明，注意函数定义最后没有加分号。：\n  function sum (num1, num2) &#123;\treturn num1 + num2;&#125;\n函数表达式\n  let sum = function(num1, num2) &#123;\treturn num1 + num2;&#125;;\n\nES6中新增了箭头函数，使用胖箭头（=&gt;）语法定义函数表达式。\n// 以下两种写法都有效let double = (x) =&gt; &#123; return 2 * x; &#125;;let triple = x =&gt; &#123; return 3 * x; &#125;;// 没有参数需要括号let getRandom = () =&gt; &#123; return Math.random(); &#125;;// 多个参数需要括号let sum = (a, b) =&gt; &#123; return a + b; &#125;;// 无效的写法：let multiply = a, b =&gt; &#123; return a * b; &#125;;\n\n箭头函数虽然语法简洁，但也有很多场合不适用。箭头函数不能使用arguments、super 和 new.target，也不能用作构造函数。此外，箭头函数也没有prototype 属性。\n1 函数基础1.1 函数名函数名就是指向函数的指针，这意味着一个函数可以有多个名称：\nfunction sum(num1, num2) &#123;\treturn num1 + num2;&#125;console.log(sum(10, 10)); // 20let anotherSum = sum;console.log(anotherSum(10, 10)); // 20\n\nES6的所有函数对象都会暴露一个只读的 name 属性，其中包含关于函数的信息。\n1.2 函数参数ES函数既不关心传入的参数个数，也不关心这些参数的数据类型。定义函数时要接收两个参数，并不意味着调用时就传两个参数。你可以传一个、三个，甚至一个也不传，解释器都不会报错。\n函数参数在内部表现为一个数组，函数被调用时总会接收一个数组，但函数并不关心这个数组中包含什么。，在使用function关键字定义（非箭头）函数时，可以在函数内部访问arguments对象，从中取得传进来的每个参数值。下面两个函数效果相同：\nfunction sayHi(name, message) &#123;\tconsole.log(&quot;Hello &quot; + name + &quot;, &quot; + message);&#125;function sayHi() &#123;\tconsole.log(&quot;Hello &quot; + arguments[0] + &quot;, &quot; + arguments[1]);&#125;\n\n也可以通过arguments对象的length属性检查传入的参数个数。下面的例子展示了在每调用一个函数时，都会打印出传入的参数个数：\nfunction doAdd() &#123;\tif (arguments.length === 1) &#123;\t\tconsole.log(arguments[0] + 10);\t&#125; else if (arguments.length === 2) &#123;\t\tconsole.log(arguments[0] + arguments[1]);\t&#125;&#125;doAdd(10); // 20doAdd(30, 20); // 50\n\n对于命名参数而言，如果调用函数时没有传这个参数，那么它的值就是undefined。\narguments对象的另一个有意思的地方就是，它的值始终会与对应的命名参数同步。来看下面的例子：\nfunction doAdd(num1, num2) &#123;\targuments[1] = 10;\tconsole.log(arguments[0] + num2);&#125;\n\n\n严格模式下，arguments 会有一些变化。首先，像前面那样给arguments[1]赋值不会再影响num2的值。就算把arguments[1]设置为10，num2 的值仍然还是传入的值。其次，在函数中尝试重写arguments 对象会导致语法错误。（代码也不会执行。）\n\nES6支持函数默认参数传递，只要在函数定义中的参数后面用=就可以为参数赋一个默认值，箭头函数同样也可以这样使用默认参数，只不过在只有一个参数时，就必须使用括号而不能省略了：\nfunction makeKing(name = &#x27;Henry&#x27;) &#123;\treturn `King $&#123;name&#125; VIII`;&#125;console.log(makeKing(&#x27;Louis&#x27;)); // &#x27;King Louis VIII&#x27;console.log(makeKing()); // &#x27;King Henry VIII&#x27;let makeKing = (name = &#x27;Henry&#x27;) =&gt; `King $&#123;name&#125;`;console.log(makeKing()); // King Henry\n\n1.3 函数参数传递方式在《JavaScript高级程序设计》中有这么一句话：\n\nECMAScript 中的所有参数都按值传递的。不可能按引用传递参数。如果把对象作为参数传递，那么传递的值就是这个对象的引用。\n\n这句话理解起来是有点问题的，让我们看两个例子：\n\n```js var value = 1; function foo(v) {\n v = 2;\n console.log(v); //2\n\n } foo(value); console.log(value) // 1\n     这个例子说明前半句话没有问题，我们传入了一个 value 相当于拷贝了一个value的副本`_value`，这样对`_value`的修改不会影响value的值。2. ```js    var obj = &#123;        value: 1    &#125;;    function foo(o) &#123;        o = 2;// 修改对象的引用(指针)，指向一个number        console.log(o); //2    &#125;    foo(obj);    console.log(obj.value) // 1 \n\n 按照书中原话描述的：“如果把对象作为参数传递，那么传递的值就是这个对象的引用”。那么obj应该被改为了2啊。\n\n\n出现这个现象的原因是，JS传递对象参数的方式遵循call by sharing, copy the reference，可以理解是共享传递。在传递对象的时候，传递对象的引用的副本。注意： 按引用传递是传递对象的引用，而按共享传递是传递对象的引用的副本(复制一个指针传递给函数)！\n\nThe main point of this strategy is that function receives the copy of the reference to object. This reference copy is associated with the formal parameter and is its value.Regardless the fact that the concept of the reference in this case appears, this strategy should not be treated as call by reference (though, in this case the majority makes a mistake), because the value of the argument is not the direct alias, but the copy of the address.\nThe main difference consists that assignment of a new value to argument inside the function does not affect object outside (as it would be in case of call by reference). However, because formal parameter, having an address copy, gets access to the same object that is outside (i.e. the object from the outside completely was not copied as would be in case of call by value), changes of properties of local argument object — are reflected in the external object.\n\n结合上面两个例子再分析下面的代码：\nvar obj = &#123;    value: 1&#125;;function foo(o) &#123;    o.value = 2;    console.log(o.value); //2&#125;foo(obj);console.log(obj.value) // 2 能成功修改\n\n其内存中的使用情况模拟：\n\n\n引用类型把在内存中的地址复制给了函数中的局部变量。所以修改 o.value，可以通过引用找到原值，但是直接修改 o，并不会修改原值。所以第二个和第三个例子其实都是按共享传递。\n总结：参数如果是基本类型是按值传递，如果是引用类型按共享传递。\n1.4 函数扩展与收集ES6新增了扩展运算符(…)，扩展操作符最有用的场景就是函数定义中的参数列表，扩展操作符既可以用于调用函数时传参，也可以用于定义函数参数。\n扩展参数：\n在给函数传参时，有时候可能不需要传一个数组，而是要分别传入数组的元素。\nlet values = [1, 2, 3, 4];function getSum() &#123;\tlet sum = 0;\tfor (let i = 0; i &lt; arguments.length; ++i) &#123;\t\tsum += arguments[i];\t&#125;\treturn sum;&#125;\n\n这个函数希望将所有加数逐个传进来，然后通过迭代arguments 对象来实现累加。如果不使用扩展操作符，想把定义在这个函数这面的数组拆分，那么就得求助于apply()方法：\nconsole.log(getSum.apply(null, values)); // 10\n\n而扩展操作符极为简洁地实现这种操作\nconsole.log(getSum(...values)); // 10\n\n因为数组的长度已知，所以在使用扩展操作符传参的时候，并不妨碍在其前面或后面再传其他的值，包括使用扩展操作符传其他参数：\nlet values = [1,2,3,4]function countArguments() &#123;\tconsole.log(arguments.length);&#125;countArguments(-1, ...values); // 5countArguments(...values, 5); // 5countArguments(-1, ...values, 5); // 6countArguments(...values, ...[5,6,7]); // 7\n\n除了使用arguments操作元素，在普通函数和箭头函数中，也可以将扩展操作符用于命名参数：\nfunction getProduct(a, b, c = 1) &#123;\treturn a * b * c;&#125;console.log(getProduct(...[1,2])); // 2console.log(getProduct(...[1,2,3])); // 6console.log(getProduct(...[1,2,3,4])); // 6\n\n收集参数：\n使用扩展操作符把不同长度的独立参数组合为一个Array实例。收集参数的前面如果还有命名参数，则只会收集其余的参数；如果没有则会得到空数组。因为收集参数的结果可变，所以只能把它作为最后一个参数：\n// 不可以function getProduct(...values, lastValue) &#123;&#125;// 可以function ignoreFirst(firstValue, ...values) &#123;\tconsole.log(values);&#125;ignoreFirst(); // []ignoreFirst(1); // []ignoreFirst(1,2); // [2]ignoreFirst(1,2,3); // [2, 3]\n\n箭头函数虽然不支持arguments对象，但支持收集参数的定义方式，因此也可以实现与使用arguments 一样的逻辑：\nlet getSum = (...values) =&gt; &#123;\treturn values.reduce((x, y) =&gt; x + y, 0);&#125;\n\n使用收集参数与arguments互不影响。\n1.5 函数声明JavaScript 引擎在加载数据时对函数声明与函数表达式是区别对待的。之前学习执行上下文时说过，JavaScript 引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中生成函数定义。而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。\n函数声明提升（function declaration hoisting）：以下代码可以正常运行，因为函数声明会在任何代码执行之前先被读取并添加到执行上下文。这个过程叫作。\n// 没问题console.log(sum(10, 10));function sum(num1, num2) &#123;\treturn num1 + num2;&#125;\n\n该段代码会出错：\n// 会出错console.log(sum(10, 10));let sum = function(num1, num2) &#123;\treturn num1 + num2;&#125;;\n\n1.6 函数表达式我们知道，定义函数有两种方式：函数声明和函数表达式。函数声明的关键特点是函数声明提升，即函数声明会在代码执行之前获得定义。这意味着函数声明可以出现在调用它的代码之后。\n第二种创建函数的方式就是函数表达式。最常见的形式是这样的：\nlet functionName = function(arg0, arg1, arg2) &#123;\t// 函数体&#125;;\n\n函数表达式看起来就像一个普通的变量定义和赋值，即创建一个函数再把它赋值给一个变量 functionName。这样创建的函数叫作匿名函数（anonymous funtion）。任何时候，只要函数被当作值来使用，它就是一个函数表达式。在下一节具体说明\n1.7 函数作为值因为函数名在ECMAScript 中就是变量（类似指针），所以函数可以用在任何可以使用变量的地方。这意味着不仅可以把函数作为参数传给另一个函数，而且还可以在一个函数中返回另一个函数。\n作为参数：\nfunction callSomeFunction(someFunction, someArgument) &#123;\treturn someFunction(someArgument);&#125;function add10(num) &#123;\treturn num + 10;&#125;let result1 = callSomeFunction(add10, 10);\n\n如果是函数作为参数传递(访问函数)而不是调用函数，那就必须不带括号，所以传给callSomeFunction()的必须是 add10 ，而不能是它们的执行结果。\n返回函数：\n例如，假设有一个包含对象的数组，而我们想按照任意对象属性对数组进行排序。为此，可以定义一个sort()方法需要的比较函数，它接收两个参数，即要比较的值。但这个比较函数还需要想办法确定根据哪个属性来排序。这个问题可以通过定义一个根据属性名来创建比较函数的函数来解决。比如：\nfunction createComparisonFunction(propertyName) &#123;\treturn function(object1, object2) &#123;\t\tlet value1 = object1[propertyName];\t\tlet value2 = object2[propertyName];\t\tif (value1 &lt; value2) &#123;\t\t\treturn -1;\t\t&#125; else if (value1 &gt; value2) &#123;\t\t\treturn 1;\t\t&#125; else &#123;\t\t\treturn 0;\t\t&#125;\t&#125;;&#125;\n\n使用时\nlet data = [\t&#123;name: &quot;Zachary&quot;, age: 28&#125;,\t&#123;name: &quot;Nicholas&quot;, age: 29&#125;];data.sort(createComparisonFunction(&quot;name&quot;));console.log(data[0].name); // Nicholasdata.sort(createComparisonFunction(&quot;age&quot;));console.log(data[0].name); // Zachary\n\n2 函数作为对象2.1 函数内部对象在ECMAScript 5 中，函数内部存在两个特殊的对象：arguments 和this。ECMAScript 6 又新增了new.target 属性。\n2.1.1 arguments之前讨论过，它是一个类数组对象，包含调用函数时传入的所有参数。这个对象只有以 function 关键字定义函数（相对于使用箭头语法创建函数）时才会有。\n\n所谓的类数组对象，可以理解为拥有多个属性和若干索引属性的对象，举个例子：\nvar array = [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;sex&#x27;];//数组var arrayLike = &#123;    0: &#x27;name&#x27;,    1: &#x27;age&#x27;,    2: &#x27;sex&#x27;,    length: 3&#125;//类数组|对象\n\n类数组对象在读写、获取长度、遍历的三个方面有类似于数组的性质：\n// 读写console.log(array[0]); // nameconsole.log(arrayLike[0]); // namearray[0] = &#x27;new name&#x27;;arrayLike[0] = &#x27;new name&#x27;;// 获取长度console.log(array.length); // 3console.log(arrayLike.length); // 3// 遍历for(var i = 0, len = array.length; i &lt; len; i++) &#123;   ……&#125;for(var i = 0, len = arrayLike.length; i &lt; len; i++) &#123;    ……&#125;\n\n调用数组方法：类数组对象无法直接调用数组的方法，但我们可以用 Function.call 间接调用\nvar arrayLike = &#123;0: &#x27;name&#x27;, 1: &#x27;age&#x27;, 2: &#x27;sex&#x27;, length: 3 &#125;Array.prototype.join.call(arrayLike, &#x27;&amp;&#x27;); // name&amp;age&amp;sexArray.prototype.slice.call(arrayLike, 0); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] // slice可以做到类数组转数组Array.prototype.map.call(arrayLike, function(item)&#123;    return item.toUpperCase();&#125;); // [&quot;NAME&quot;, &quot;AGE&quot;, &quot;SEX&quot;]\n\n类数组对象转数组：\nvar arrayLike = &#123;0: &#x27;name&#x27;, 1: &#x27;age&#x27;, 2: &#x27;sex&#x27;, length: 3 &#125;// 1. sliceArray.prototype.slice.call(arrayLike); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] // 2. spliceArray.prototype.splice.call(arrayLike, 0); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] // 3. ES6 Array.fromArray.from(arrayLike); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] // 4. applyArray.prototype.concat.apply([], arrayLike)// 5. ......arrayLike\n\nArguments 对象只定义在函数体中，包括了函数的参数和其他属性。在函数体中，arguments 指代该函数的 Arguments 对象。举个例子：\nfunction foo(name, age, sex) &#123;    console.log(arguments);&#125;foo(&#x27;name&#x27;, &#x27;age&#x27;, &#x27;sex&#x27;)\n\n打印结果如下：\n\n\narguments对象还有一个callee属性，是一个指向arguments对象所在函数的指针。我们可以利用这个特性在递归函数中让函数逻辑与函数名解耦：\n// 阶乘function factorial(num) &#123;\tif (num &lt;= 1) &#123;\t\treturn 1;\t&#125; else &#123;\t\treturn num * arguments.callee(num - 1);\t&#125;&#125;\n\n利用arguments将参数从一个函数传递到另一个函数\n// 使用 apply 将 foo 的参数传递给 barfunction foo() &#123;    bar.apply(this, arguments);&#125;function bar(a, b, c) &#123;   console.log(a, b, c);&#125;foo(1, 2, 3)\n\n2.1.2 thisthis并不属于一个对象的属性，而是在执行上下文中。在之前讨论过this的问题，不清楚可以回顾JS深入学习(5)：执行上下文 | Sunburst7’s Blog。在这里考察特殊情况：\n在箭头函数中，this 引用的是定义箭头函数的上下文。下面的例子演示了这一点。o.sayColor作为Reference类型，其baseValue是global：\nwindow.color = &#x27;red&#x27;;let o = &#123;\tcolor: &#x27;blue&#x27;&#125;;let sayColor = () =&gt; console.log(this.color);sayColor(); // &#x27;red&#x27;o.sayColor = sayColor;o.sayColor(); // &#x27;red&#x27;\n\n在事件回调或定时回调中调用某个函数时，this 值指向的并非想要的对象。此时将回调函数写成箭头函数就可以解决问题。这是因为箭头函数中的 this 会保留定义该函数时的上下文：\nfunction King() &#123;this.royaltyName = &#x27;Henry&#x27;;\t// this 引用King 的实例\tsetTimeout(() =&gt; console.log(this.royaltyName), 1000);&#125;function Queen() &#123;this.royaltyName = &#x27;Elizabeth&#x27;;\t// this 引用window 对象\tsetTimeout(function() &#123; console.log(this.royaltyName); &#125;, 1000);&#125;new King(); // Henrynew Queen(); // undefined\n\n2.1.3 new.target之前在JS深入学习(1)：对象与类初步 | Sunburst7’s Blog中提到，ES中的函数始终可以作为构造函数实例化一个新对象，也可以作为普通函数被调用。ES6 新增了检测函数是否使用 new 关键字调用的new.target属性。\n如果函数是正常调用的。则new.target的值是undefined；如果是使用 new 关键字调用的，则new.target将引用被调用的构造函数。\nfunction King() &#123;\tif (!new.target) &#123;\t\tthrow &#x27;King must be instantiated using &quot;new&quot;&#x27;\t&#125;\tconsole.log(&#x27;King instantiated using &quot;new&quot;&#x27;);&#125;new King(); // King instantiated using &quot;new&quot;King(); // Error: King must be instantiated using &quot;new&quot;\n\n2.2 函数属性ECMAScript 中的函数是对象，因此有属性和方法。每个函数都有两个属性：length和prototype。\n\nlength属性保存函数定义的命名参数的个数：\n  function sayName(name) &#123;\tconsole.log(name);&#125;function sum(num1, num2) &#123;\treturn num1 + num2;&#125;function sayHi() &#123;\tconsole.log(&quot;hi&quot;);&#125;console.log(sayName.length); // 1console.log(sum.length); // 2console.log(sayHi.length); // 0\nprototype保存着该函数（作为构造函数）的原型，toString()、valueOf()等方法实际上都保存在prototype上，进而由所有实例共享。prototype属性是不可枚举的，因此使用for-in 循环不会返回这个属性。\n\n\n2.3 函数方法apply()和call()。这两个方法都会以指定的 this 值来调用函数，即会设置调用函数时函数体内 this 对象的值。\n\napply()：方法接收两个参数：函数内 this 的值和一个参数数组。第二个参数可以是Array 的实例，但也可以是arguments 对象\ncall()：方法第一个参数跟apply()一样，也是this值，而剩下的要传给被调用函数的参数则是逐个传递的。换句话说，通过call()向函数传参时，必须将参数一个一个地列出来\n\nfunction sum(num1, num2) &#123;\treturn num1 + num2;&#125;function callSum1(num1, num2) &#123;\treturn sum.apply(this, arguments); // 传入arguments 对象    //return sum.apply(this, [num1, num2]); // 传入数组，效果相同&#125;function callSum2(num1, num2) &#123;\treturn sum.call(this, num1, num2);&#125;console.log(callSum1(10, 10)); // 20console.log(callSum2(10, 10)); // 20\n\napply()和call()真正强大的地方并不是给函数传参，而是控制函数调用上下文即函数体内this值的能力。\nwindow.color = &#x27;red&#x27;;let o = &#123;\tcolor: &#x27;blue&#x27;&#125;;function sayColor() &#123;\tconsole.log(this.color);&#125;sayColor(); // redsayColor.call(o); // blue\n\n使用call()或apply()的好处是可以将任意对象设置为任意函数的作用域，这样对象可以不用关心方法。\nES5中定义了一个类似的方法：bind()。bind()方法会创建一个新的函数实例，其 this 值会被绑定到传给bind()的对象:\nvar color = &#x27;red&#x27;;var o = &#123;\tcolor: &#x27;blue&#x27;&#125;;function sayColor() &#123;\tconsole.log(this.color);&#125;let objectSayColor = sayColor.bind(o);objectSayColor(); // blue\n\n3 闭包闭包（closure）指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。比如，下面是之前展示的createComparisonFunction()函数：\nfunction createComparisonFunction(propertyName) &#123;\treturn function(object1, object2) &#123;\t\tlet value1 = object1[propertyName];//引用了外部函数的变量propertyName\t\tlet value2 = object2[propertyName];//引用了外部函数的变量propertyName\t\tif (value1 &lt; value2) &#123;\t\t\treturn -1;\t\t&#125; else if (value1 &gt; value2) &#123;\t\t\treturn 1;\t\t&#125; else &#123;\t\t\treturn 0;\t\t&#125;\t&#125;;&#125;\n\n闭包的原理依赖于执行上下文，详情JS深入学习(5)：执行上下文 | Sunburst7’s Blog。在调用一个函数时，会为这个函数调用创建一个执行上下文，并创建一个作用域链。然后用 arguments 和其他命名参数来初始化这个函数的活动对象。外部函数的活动对象是内部函数作用域链上的第二个对象。这个作用域链一直向外串起了所有包含函数的活动对象，直到全局执行上下文才终止。\n当一个函数执行完毕时，其执行上下文的作用域链会销毁，但它的活动对象仍然会保留在内存中供嵌套的函数的作用域链使用。\n总结闭包的特点：\n\n即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）\n 因为闭包会保留它们包含函数的作用域，所以比其他函数更占用内存。过度使用闭包可能导致内存过度占用\n\n在代码中引用了自由变量\n\n\n以下两段代码为例：\nvar data = [];for (var i = 0; i &lt; 3; i++) &#123;  data[i] = function () &#123;    console.log(i);  &#125;;&#125;data[0]();//3data[1]();//3data[2]();//3//闭包写法var data = [];for (var i = 0; i &lt; 3; i++) &#123;  data[i] = (function (i) &#123;        \t\treturn function()&#123;           \t\t\tconsole.log(i);        \t\t&#125;  &#125;)(i);&#125;data[0]();data[1]();data[2]();\n\n第一段答案是都是 3，让我们分析一下原因：\n当执行到 data[0] 函数之前，此时全局上下文的 VO 为：\nglobalContext = &#123;    VO: &#123;        data: [...],        i: 3    &#125;&#125;\n\n当执行 data[0] 函数的时候，data[0] 函数的作用域链为：\ndata[0]Context = &#123;    Scope: [AO, globalContext.VO]&#125;\n\ndata[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。data[1] 和 data[2] 是一样的道理。\n重点关注第二段代码：\nvar data = [];for (var i = 0; i &lt; 3; i++) &#123;  data[i] = (function (i) &#123;        \t\treturn function()&#123;            \t\tconsole.log(i);        \t\t&#125;  &#125;)(i);//立即调用函数，data[i]中保存的是该匿名函数的返回值，也就是另一个匿名函数&#125;data[0]();data[1]();data[2]();\n\n当执行到 data[0] 函数之前，此时全局上下文的 VO 为：\nglobalContext = &#123;    VO: &#123;        data: [...],        i: 3    &#125;&#125;\n\n跟没改之前一模一样。当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：\ndata[0]Context = &#123;    Scope: [AO, 匿名函数Context.AO globalContext.VO]&#125;\n\n匿名函数执行上下文的AO为：\n匿名函数Context = &#123;    AO: &#123;        arguments: &#123;            i: 0,            length: 1        &#125;,    &#125;&#125;\n\ndata[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是0。data[1] 和 data[2] 是一样的道理。\n参考【1】JavaScript高级程序设计（第四版）\n【2】(1) JavaScript深入之参数按值传递 · Issue #10 · mqyqingfeng/Blog (github.com)\n【3】call by sharing——JavaScript中“共享传参”和“按值传参”的理解 - SegmentFault 思否\n","categories":["JavaScript"],"tags":["JavaScript","前端"]},{"title":"JS深入学习(3)：类","url":"/2022/01/15/JS-%E7%B1%BB/","content":"前面一篇博客我们讲述了使用ES5的特性来模拟类似类的行为，但实现继承的代码也显得非常冗长和混乱。ECMAScript 6 新引入的class 关键字具有正式定义类的能力。类（class）是ECMAScript 中新的基础性语法糖结构，虽然ECMAScript 6 类表面上看起来可以支持正式的面向对象编程，但实际上它背后使用的仍然是原型和构造函数的概念。\n1 类定义与函数类型相似，定义类也有两种主要方式：类声明和类表达式。这两种方式都使用class 关键字加大括号：\n// 类声明class Person &#123;&#125;// 类表达式const Animal = class &#123;&#125;;\n\n跟函数声明不同的地方是，函数受函数作用域限制，而类受块作用域限制：\n\nJavaScript的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的，可以在整个函数的范围内使用及复用，也就是说在函数体内变量声明之前就已经可用了(事实上在嵌套的作用域中也可以使用)。\n\n&#123;\tfunction FunctionDeclaration() &#123;&#125;\tclass ClassDeclaration &#123;&#125;&#125;console.log(FunctionDeclaration); // FunctionDeclaration() &#123;&#125;console.log(ClassDeclaration); // ReferenceError: ClassDeclaration is not defined\n\n类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。空的类定义照样有效。默认情况下，类定义中的代码都在严格模式下执行。\n2 构造函数constructor 关键字用于在类定义块内部创建类的构造函数。不定义构造函数默认为空函数。\n使用 new 操作符实例化一个类的操作等于使用 new 调用其构造函数，使用 new 会执行如下操作：\n\n在内存中创建一个新对象。\n\n这个新对象内部的[[Prototype]]指针被赋值为构造函数的prototype 属性。\n\n构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。\n\n执行构造函数内部的代码（给新对象添加属性）。\n\n如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。\n\n\n类实例化时传入的参数会用作构造函数的参数。如果不需要参数，则类名后面的括号也是可选的：\nclass Person &#123;\tconstructor(name) &#123;\t\tconsole.log(arguments.length);\t\tthis.name = name || null;\t&#125;&#125;let p1 = new Person; // 0console.log(p1.name); // nulllet p2 = new Person(); // 0console.log(p2.name); // nulllet p3 = new Person(&#x27;Jake&#x27;); // 1console.log(p3.name); // Jake\n\n默认情况下，类构造函数会在执行之后返回 this 对象（此时 this 对象指向内存中新创建的对象）。构造函数返回的对象会被用作实例化的对象，如果没有什么引用新创建的 this 对象，那么这个对象会被销毁。不过，如果返回的不是 this 对象，而是其他对象，那么这个对象不会通过 instanceof 操作符检测出跟类有关联，因为这个对象的原型指针并没有被修改指向类\n\n使用 instanceo 操作符检查构造函数原型是否存在于实例的原型链中。\n可以使用instanceof 操作符检查一个对象与类构造函数，以确定这个对象是不是类的实例。只不过此时的类构造函数要使用类标识符\n\nclass Person &#123;\tconstructor(override) &#123;\t\tthis.foo = &#x27;foo&#x27;;\t\tif (override) &#123;\t\t\treturn &#123;\t\t\t\tbar: &#x27;bar&#x27;\t\t\t&#125;;\t\t&#125;\t&#125;&#125;let p1 = new Person(),p2 = new Person(true);console.log(p1); // Person&#123; foo: &#x27;foo&#x27; &#125;console.log(p1 instanceof Person); // trueconsole.log(p2); // &#123; bar: &#x27;bar&#x27; &#125;console.log(p2 instanceof Person); // false\n\n类构造函数与构造函数的区别：\n\n调用类构造函数必须使用 new 操作符，忘了使用 new 则会抛出错误。而普通构造函数如果不使用 new 调用，那么就会以全局的 this（通常是window）作为内部对象。\n  function Person() &#123;&#125;class Animal &#123;&#125;// 把window 作为this 来构建实例let p = Person();let a = Animal();// TypeError: class constructor Animal cannot be invoked without &#x27;new&#x27;\n实例化之后，类构造函数会成为普通的实例方法（但作为类构造函数，仍然要使用new 调用）。因此，实例化之后可以在实例上引用它：\n  class Person &#123;&#125;// 使用类创建一个新实例let p1 = new Person();p1.constructor();// TypeError: Class constructor Person cannot be invoked without &#x27;new&#x27;// 使用对类构造函数的引用创建一个新实例let p2 = new p1.constructor();\n\n类是一个特殊函数：\n\n通过 typeof 操作符检测类标识符，表明它是一个函数\n  class Person &#123;&#125;console.log(Person); // class Person &#123;&#125;console.log(typeof Person); // function\n\n  类标识符可等同于函数名，类标识符有prototype 属性，而这个原型也有一个constructor 属性指向类自身\n  class Person&#123;&#125;console.log(Person.prototype); // &#123; constructor: f() &#125;console.log(Person === Person.prototype.constructor); // true\n类可以像其他对象或函数引用一样把类作为参数传递：\n  // 类可以像函数一样在任何地方定义，比如在数组中let classList = [\tclass &#123;\t\tconstructor(id) &#123;\t\t\tthis.id_ = id;\t\t\tconsole.log(`instance $&#123;this.id_&#125;`);\t\t&#125;\t&#125;];function createInstance(classDefinition, id) &#123;\treturn new classDefinition(id);&#125;let foo = createInstance(classList[0], 3141); // instance 3141\n与立即调用函数表达式相似，类也可以立即实例化\n  // 因为是一个类表达式，所以类名是可选的let p = new class Foo &#123;\tconstructor(x) &#123;\t\tconsole.log(x);\t&#125;&#125;(&#x27;bar&#x27;); // barconsole.log(p); // Foo &#123;&#125;// 结合类构造函数的特性let q = new p.constructor(&#x27;qqq&#x27;)// qqqconsole.log(q);// Foo &#123;&#125;\n\n3 实例、原型和类成员类的语法可以非常方便地定义应该存在于实例上的成员、应该存在于原型上的成员，以及应该存在于类本身的成员。\n3.1 实例成员在构造函数内或在构造函数外通过this.添加的自有属性是类的实例成员，每个实例都对应一个唯一的成员对象，这意味着所有实例成员都不会共享：\nclass Person &#123;\tconstructor() &#123;\t// 这个例子先使用对象包装类型定义一个字符串\t// 为的是在下面测试两个对象的相等性\t\tthis.name = new String(&#x27;Jack&#x27;);\t\tthis.sayName = () =&gt; console.log(this.name);\t\tthis.nicknames = [&#x27;Jake&#x27;, &#x27;J-Dog&#x27;]\t&#125;&#125;let p1 = new Person(),p2 = new Person();p1.sayName(); // Jackp2.sayName(); // Jackconsole.log(p1.name === p2.name); // falseconsole.log(p1.sayName === p2.sayName); // falseconsole.log(p1.nicknames === p2.nicknames); // falsep1.name = p1.nicknames[0];p2.name = p2.nicknames[1];p1.sayName(); // Jakep2.sayName(); // J-Dog\n\n3.2 原型方法与访问器为了在实例间共享方法，类定义语法把在类块中定义的方法作为原型方法。但不能在类块中给原型添加成员数据：\nclass Person &#123;\tconstructor() &#123;\t// 添加到this 的所有内容都会存在于不同的实例上\t\tthis.locate = () =&gt; console.log(&#x27;instance&#x27;);\t&#125;\t// 在类块中定义的所有内容都会定义在类的原型上\tlocate() &#123;\t\tconsole.log(&#x27;prototype&#x27;);\t&#125;&#125;let p = new Person();p.locate(); // instancePerson.prototype.locate(); // prototypeclass Person &#123;\tname: &#x27;Jake&#x27;&#125;// Uncaught SyntaxError: Unexpected tokenFoo.prototype.name = &#x27;111&#x27;// 在类块外定义原型属性let p = new Foo();console.log(p.name);// 111\n\n类定义也支持get和set访问器。语法与行为跟普通对象一样：\n// let book = &#123;//     year_:2017,// &#125;// Object.defineProperty(//     book, &#x27;year&#x27;,&#123;//         get()&#123;//             return this.year_;//         &#125;,//         set(newValue)&#123;//             if(newValue &gt; 2017)&#123;//                 this.year_ = newValue//                 this.edition += newValue - 2017//             &#125;//         &#125;//     &#125;// )class Person &#123;\tset name(newName) &#123;\t\tthis.name_ = newName;\t&#125;\tget name() &#123;\t\treturn this.name_;\t&#125;&#125;let p = new Person();p.name = &#x27;Jake&#x27;;console.log(p.name); // Jake\n\n3.3 静态类方法可以在类上定义静态方法。这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。与原型方法类似，静态成员所有实例共享。\n静态类成员在类定义中使用static 关键字作为前缀。在静态成员中，this 引用类自身。其他所有约定跟原型成员一样：\nclass Person &#123;\tconstructor() &#123;\t// 添加到this 的所有内容都会存在于不同的实例上\t\tthis.locate = () =&gt; console.log(&#x27;instance&#x27;, this);\t&#125;\t// 定义在类的原型对象上\tlocate() &#123;\t\tconsole.log(&#x27;prototype&#x27;, this);\t&#125;\t// 定义在类本身上\tstatic locate() &#123;\t\tconsole.log(&#x27;class&#x27;, this);\t&#125;&#125;let p = new Person();p.locate(); // instance, Person &#123;&#125;Person.prototype.locate(); // prototype, &#123;constructor: ... &#125;Person.locate(); // class, class Person &#123;&#125;\n\n静态类方法非常适合作为实例工厂：\nclass Person &#123;\tconstructor(age) &#123;\t\tthis.age_ = age;\t&#125;\tsayAge() &#123;\t\tconsole.log(this.age_);\t&#125;\tstatic create() &#123;\t\t// 使用随机年龄创建并返回一个Person 实例\t\treturn new Person(Math.floor(Math.random()*100));\t&#125;&#125;console.log(Person.create()); // Person &#123; age_: ... &#125;\n\n3.4 类外添加虽然类块中(构造函数外)并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加：\nclass Person &#123;\tsayName() &#123;\t\tconsole.log(`$&#123;Person.greeting&#125; $&#123;this.name&#125;`);\t&#125;&#125;// 在类上定义实例数据成员Person.greeting = &#x27;My name is&#x27;;// 在原型上定义数据成员Person.prototype.name = &#x27;Jake&#x27;;// 在原型上定义函数成员Person.prototype.sayHi = function()&#123;    console.log(&#x27;hi&#x27;)&#125;let p = new Person();p.sayName(); // My name is Jakeconsole.log(p.sayHi()) // hi\n\n4 继承之前一直在讨论 ES5 的机制实现继承。ECMAScript 6 新增特性中最出色的一个就是原生支持了类继承机制。虽然类继承使用的是新语法，但背后依旧使用的是原型链。\n4.1 继承基础ES6 类支持单继承。使用extends 关键字，就可以继承任何拥有[[Construct]]和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（保持向后兼容）：\nclass Vehicle &#123;&#125;// 继承类class Bus extends Vehicle &#123;&#125;let b = new Bus();console.log(b instanceof Bus); // trueconsole.log(b instanceof Vehicle); // truefunction Person() &#123;&#125;// 继承普通构造函数class Engineer extends Person &#123;&#125;let e = new Engineer();console.log(e instanceof Engineer); // trueconsole.log(e instanceof Person); // true\n\n派生类都会通过原型链访问到类和原型上定义的方法。this 的值会反映调用相应方法的实例或者类。\n子类通过 super 关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部：\n\n在类构造函数中使用 super 可以调用父类构造函数：\n  class Vehicle &#123;\tconstructor() &#123;\t\tthis.hasEngine = true;\t&#125;&#125;class Bus extends Vehicle &#123;\tconstructor() &#123;\t\t// 不要在调用super()之前引用this，否则会抛出\tReferenceError\t\tsuper(); // 相当于super.constructor()\t\tconsole.log(this instanceof Vehicle); // true\t\tconsole.log(this); // Bus &#123; hasEngine: true &#125;\t&#125;&#125;new Bus();\n在静态方法中可以通过 super 调用继承的类上定义的静态方法：\n  class Vehicle &#123;\tstatic identify() &#123;\t\tconsole.log(&#x27;vehicle&#x27;);\t&#125;&#125;class Bus extends Vehicle &#123;\tstatic identify() &#123;\t\tsuper.identify();\t&#125;&#125;Bus.identify(); // vehicle\n\n在使用 super 时要注意几个问题：\n\nsuper 只能在派生类构造函数和静态方法中使用。\n\n不能单独引用 super 关键字，要么用它调用构造函数，要么用它引用静态方法。\n\n调用super()会调用父类构造函数，并将返回的实例赋值给this。\n  class Vehicle &#123;&#125;class Bus extends Vehicle &#123;\tconstructor() &#123;\t\tsuper();\t\tconsole.log(this instanceof Vehicle);\t&#125;&#125;new Bus(); // true\nsuper()的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入。\n  class Vehicle &#123;\tconstructor(licensePlate) &#123;\t\tthis.licensePlate = licensePlate;\t&#125;&#125;class Bus extends Vehicle &#123;\tconstructor(licensePlate) &#123;\t\tsuper(licensePlate);\t&#125;&#125;console.log(new Bus(&#x27;1337H4X&#x27;)); // Bus &#123; licensePlate: &#x27;1337H4X&#x27; &#125;\n派生类如果没有定义类构造函数，在实例化派生类时会调用super()，而且会传入所有传给派生类的参数。\n\n在类构造函数中，不能在调用super()之前引用this。可能是因为super()会将返回的实例赋给this，因此要先super\n\n如果在派生类中显式定义了构造函数，则要么必须在其中调用super()，要么必须在其中返回一个对象。\n  class Vehicle &#123;&#125;class Car extends Vehicle &#123;&#125;class Bus extends Vehicle &#123;\tconstructor() &#123;\t\tsuper();\t&#125;&#125;class Van extends Vehicle &#123;\tconstructor() &#123;\t\treturn &#123;&#125;;\t&#125;&#125;console.log(new Car()); // Car &#123;&#125;console.log(new Bus()); // Bus &#123;&#125;console.log(new Van()); // &#123;&#125;\n\n4.2 抽象基类有时我们可能需要定义一个抽象类，它可供其他类继承，但本身不会被实例化。虽然ECMAScript 没有专门支持这种类的语法 ，但通过new.target也很容易实现。new.target保存通过 new 关键字调用的类或函数。通过在实例化时检测new.target是不是抽象基类，可以阻止对抽象基类的实例化：\n通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法。因为原型内的方法在一个实例初始化之前就存在，所以可以通过this关键字来检查相应的方法：\n// 抽象基类class Vehicle &#123;\tconstructor() &#123;\t\tif (new.target === Vehicle) &#123;\t\t\tthrow new Error(&#x27;Vehicle cannot be directly instantiated&#x27;);\t\t&#125;\t\tif (!this.foo) &#123;\t\t\tthrow new Error(&#x27;Inheriting class must define foo()&#x27;);\t\t&#125;\t\tconsole.log(&#x27;success!&#x27;);\t&#125;&#125;// 基类初始化失败new Vehicle(); // Error: Vehicle cannot be directly instantiated// 派生类class Bus extends Vehicle &#123;\tfoo() &#123;&#125;&#125;// 派生类class Van extends Vehicle &#123;&#125;new Bus(); // success!new Van(); // Error: Inheriting class must define foo()\n\nES6 类为继承**内置引用类型(Array Map…)**提供了顺畅的机制，以一个扩展数组为例，扩展数组实现了洗牌算法：\nclass SuperArray extends Array &#123;\tshuffle() &#123;\t\t// 洗牌算法\t\tfor (let i = this.length - 1; i &gt; 0; i--) &#123;\t\t\tconst j = Math.floor(Math.random() * (i + 1));\t\t\t[this[i], this[j]] = [this[j], this[i]];\t\t&#125;\t&#125;&#125;let a = new SuperArray(1, 2, 3, 4, 5);console.log(a instanceof Array); // trueconsole.log(a instanceof SuperArray); // trueconsole.log(a); // [1, 2, 3, 4, 5]a.shuffle();console.log(a); // [3, 1, 4, 5, 2]\n\n有些内置类型的方法会返回新实例。默认情况下，返回实例的类型与原始实例的类型是一致的：\nclass SuperArray extends Array &#123;&#125;let a1 = new SuperArray(1, 2, 3, 4, 5);let a2 = a1.filter(x =&gt; !!(x%2))console.log(a1); // [1, 2, 3, 4, 5]console.log(a2); // [1, 3, 5]console.log(a1 instanceof SuperArray); // trueconsole.log(a2 instanceof SuperArray); // true\n\n如果想覆盖这个默认行为，则可以覆盖Symbol.species访问器，这个访问器决定在创建返回的实例时使用的类：\nclass SuperArray extends Array &#123;\tstatic get [Symbol.species]() &#123;\t\treturn Array;\t&#125;&#125;\n\n5 参考【1】JavaScript高级程序设计（第四版）\n","categories":["JavaScript"],"tags":["JavaScript","前端","面向对象"]},{"title":"JS深入学习(1)：对象与类初步","url":"/2022/01/11/JS-%E5%AF%B9%E8%B1%A1/","content":"1 对象对象被定义为一组属性的无序集合，可以把ES的对象想象成一张散列表，值可以是数据或函数。\n1.1 创建对象有两种创建对象的方式：\n// 第一种let person = new Object()person.name = &#x27;Bob&#x27;person.age = 20person.sayName = function()&#123;    console.log(this.name)&#125;// 第二种let person2 = &#123;    name:&#x27;Ana&#x27;,    age:20,    sayName()&#123;        console.log(this.name)    &#125;&#125;\n\n1.2 内置特性对象还有一些描述属性的内置特性，这些内置特性用两个中括号括起来，比如[[Enumerable]]。不同类型的对象属性有不同的特性：\n\n数据属性：\n\n[[Configurable]]：表示属性是否可以通过delete删除\n[[Enumerable]]：表示属性是否可以通过for-in 循环返回。\n[[Writable]]：表示属性的值是否可以被修改。\n[[Value]]：包含属性实际的值。值会从这个位置读取，也会写入到这个位置。\n\n  在像前面例子中那样将属性显式添加到对象之后，该属性被称为数据属性，每个属性都会有这几个特性：[[Configurable]]、[[Enumerable]]和[[Writable]]都会被设置为true，而[[Value]]特性会被设置为指定的值。\n  要修改属性的默认特性，就必须使用Object.defineProperty()方法。这个方法接收3个参数：要给其添加属性的对象、属性的名称和一个开头小写的内置特性：\n  let person = &#123;&#125;;Object.defineProperty(person, &quot;name&quot;, &#123;    writable: false,    value: &quot;Nicholas&quot;&#125;);console.log(person.name); // &quot;Nicholas&quot;person.name = &quot;Greg&quot;;console.log(person.name); // &quot;Nicholas&quot;\n访问器属性：\n  访问器属性不包含数据值。相反，它们包含一个获取（getter）函数和一个设置（setter）函数，不过这两个函数不是必需的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访问器属性有4 个特性描述它们的行为。\n\n[[Configurable]]：表示属性是否可以通过delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性都是true。\n\n[[Enumerable]]：表示属性是否可以通过for-in 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是true。\n\n[[Get]]：获取函数，在读取属性时调用。默认值为undefined。\n\n[[Set]]：设置函数，在写入属性时调用。默认值为undefined。\n\n访问器属性是不能直接定义的，必须使用Object.defineProperty()，当有多个访问器属性需要定义时，可以使用Object.defineProperties()*\n\n\n  let book = &#123;    year_:2017,    edition:1&#125;;Object.defineProperty(    book, &#x27;year&#x27;,&#123;        get()&#123;            return this.year_;        &#125;,        set(newValue)&#123;            if(newValue &gt; 2017)&#123;                this.year_ = newValue                this.edition += newValue - 2017            &#125;        &#125;    &#125;)book.year = 2021;console.log(book.edition);// 5// 使用多属性赋值let book = &#123;&#125;;Object.defineProperties(book, &#123;    year_: &#123;        value: 2017    &#125;,    edition: &#123;        value: 1    &#125;,    year: &#123;        get() &#123;            return this.year_;        &#125;,        set(newValue) &#123;            if (newValue &gt; 2017) &#123;                this.year_ = newValue;                this.edition += newValue - 2017;            &#125;        &#125;    &#125;&#125;);\n\n想要查看这些内置特性，ECMAScript 2017 新增了Object.getOwnPropertyDescriptors()静态方法。这个方法实际上会在每个自有属性上调用Object.getOwnPropertyDescriptor()并在一个新对象中返回它们。\nconsole.log(Object.getOwnPropertyDescriptors(book));\n\n\n\n1.3 合并对象ES6中提供了一个专门为合并对象的Object.assign()方法。\n这个方法接收一个目标对象和一个或多个源对象作为参数，然后将每个源对象中可枚举（属性的Enumerable=true的，可通过Object.propertyIsEnumerable()检验）和自有（Object.hasOwnProperty()返回true）属性复制到目标对象。以字符串和符号为键的属性会被复制。\nlet book = &#123;    year_:2017,// 显式的被添加的属性，数据属性默认为true    edition:1&#125;;console.log(book.propertyIsEnumerable(&#x27;edition&#x27;)) // trueObject.defineProperty(book,&#x27;edition&#x27;,&#123;enumerable:false&#125;)console.log(book.propertyIsEnumerable(&#x27;edition&#x27;)) // false\n\n对每个符合条件的属性，这个方法会使用源对象上的[[Get]]取得属性的值，然后使用目标对象上的[[Set]]设置属性的值。\n/*** 多个源对象合并*/dest = &#123;&#125;;result = Object.assign(dest, &#123; a: &#x27;foo&#x27; &#125;, &#123; b: &#x27;bar&#x27; &#125;);console.log(result); // &#123; a: foo, b: bar &#125;/*** 获取函数与设置函数*/dest = &#123;    set a(val) &#123;        console.log(`Invoked dest setter with param $&#123;val&#125;`);    &#125;&#125;;src = &#123;    get a() &#123;        console.log(&#x27;Invoked src getter&#x27;);        return &#x27;foo&#x27;;    &#125;&#125;;Object.assign(dest, src);// 调用src的get方法// 调用dest的set方法并传入参数&quot;foo&quot;// 因为这里的设置函数不执行赋值操作// 所以实际上并没有把值转移过来// Invoked src getter// Invoked dest setter with param fooconsole.log(dest); // &#123; a: [Setter] &#125;\n\nObject.assign()实际上对每个源对象执行的是浅复制。如果多个源对象都有相同的属性，则使用最后一个复制的值。\n// 可以通过目标对象上的设置函数观察到覆盖的过程：dest = &#123;    set id(x) &#123;// 声明一个访问器属性id    \tconsole.log(x);\t&#125;&#125;;Object.assign(dest, &#123; id: &#x27;first&#x27; &#125;, &#123; id: &#x27;second&#x27; &#125;, &#123; id: &#x27;third&#x27; &#125;);// first// second// third\n\n1.4 对象相等判定ES6采用Object.is(obj1,obj2)的方法判定\nconsole.log(Object.is(true, 1)); // falseconsole.log(Object.is(&#123;&#125;, &#123;&#125;)); // falseconsole.log(Object.is(&quot;2&quot;, 2)); // false// 正确的0、-0、+0 相等/不等判定console.log(Object.is(+0, -0)); // falseconsole.log(Object.is(+0, 0)); // trueconsole.log(Object.is(-0, 0)); // false// 正确的NaN 相等判定console.log(Object.is(NaN, NaN)); // true\n\n要检查超过两个值，递归地利用相等性传递，这个博主没太看懂。\nfunction recursivelyCheckEqual(x, ...rest) &#123;\treturn Object.is(x, rest[0]) &amp;&amp;\t(rest.length &lt; 2 || recursivelyCheckEqual(...rest));&#125;\n\n1.5 对象迭代ECMAScript 2017 新增了两个静态方法，用于将对象内容转换为序列化的——更重要的是可迭代的——格式。这两个静态方法Object.values()和Object.entries()接收一个对象，返回它们内容的数组。Object.values()返回对象值的数组，Object.entries()返回键/值对的数组：\nconst o = &#123;    foo: &#x27;bar&#x27;,    baz: 1,    qux: &#123;&#125;&#125;;console.log(Object.values(o));// [&quot;bar&quot;, 1, &#123;&#125;]console.log(Object.entries((o)));// [[&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 1], [&quot;qux&quot;, &#123;&#125;]]\n\n注意，非字符串属性会被转换为字符串输出。另外，这两个方法执行对象的浅复制，符号属性会被忽略：\nconst sym = Symbol();const o = &#123;\t[sym]: &#x27;foo&#x27;&#125;;console.log(Object.values(o));// []console.log(Object.entries((o)));// []\n\n1.6 ES6的增强语法1.6.1 属性值简写简写属性名只要使用变量名（不用再写冒号）就会自动被解释为同名的属性键。如果没有找到同名变量，则会抛出ReferenceError。\nlet name = &#x27;Matt&#x27;;let person = &#123;\tname\t// 等价于 name:name&#125;;console.log(person); // &#123; name: &#x27;Matt&#x27; &#125;\n\n1.6.2 属性名可计算在引入可计算属性之前，如果想使用变量的值作为属性，那么必须先声明对象，然后使用中括号语法来添加属性：\nconst nameKey = &#x27;name&#x27;;const ageKey = &#x27;age&#x27;;let person = &#123;&#125;;person[nameKey] = &#x27;Matt&#x27;;person[ageKey] = 27;console.log(person); // &#123; name: &#x27;Matt&#x27;, age: 27 &#125;\n\n有了可计算属性，就可以在对象字面量中完成动态属性赋值。中括号包围的对象属性键告诉运行时将其作为JavaScript 表达式而不是字符串来求值：\nconst nameKey = &#x27;name&#x27;;const ageKey = &#x27;age&#x27;;let person = &#123;    [nameKey]: &#x27;Matt&#x27;,    [ageKey]: 27,&#125;;console.log(person);//&#123; name: &#x27;Matt&#x27;, age: 27 &#125;\n\n因为被当作JavaScript 表达式求值，所以可计算属性本身可以是复杂的表达式，在实例化时再求值：\nconst nameKey = &#x27;name&#x27;;const ageKey = &#x27;age&#x27;;const jobKey = &#x27;job&#x27;;let uniqueToken = 0;function getUniqueKey(key) &#123;\treturn `$&#123;key&#125;_$&#123;uniqueToken++&#125;`;&#125;let person = &#123;\t[getUniqueKey(nameKey)]: &#x27;Matt&#x27;,\t[getUniqueKey(ageKey)]: 27,\t[getUniqueKey(jobKey)]: &#x27;Software engineer&#x27;&#125;;console.log(person); // &#123; name_0: &#x27;Matt&#x27;, age_1: 27, job_2: &#x27;Software engineer&#x27; &#125;\n\n1.6.3 简写方法名在给对象定义方法时，通常都要写一个方法名、冒号，然后再引用一个匿名函数表达式：\nlet person = &#123;\tsayName: function(name) &#123;\t\tconsole.log(`My name is $&#123;name&#125;`);\t&#125;&#125;;\n\n新方法不用再引用匿名函数表达式了，简写方法名对获取函数和设置函数也是适用的：\nlet person = &#123;\tname_: &#x27;&#x27;,\tget name() &#123;\t\treturn this.name_;\t&#125;,\tset name(name) &#123;\t\tthis.name_ = name;\t&#125;,\tsayName() &#123;\t\tconsole.log(`My name is $&#123;this.name_&#125;`);\t&#125;&#125;;person.name = &#x27;Matt&#x27;;person.sayName(); // My name is Matt\n\n2 类初步虽然使用Object构造函数（new Object）或对象字面量（&#123;&#125;）可以方便地创建对象，但这些方式也有明显不足：创建具有同样接口的多个对象需要重复编写很多代码。\nES6开始正式支持类和继承。ES6的类定义本身就相当于对原有结构的封装。ES中类的定义经过了从工厂模式，到构造函数，再到原型模式，最后到ES6中的类的演变。\n2.1 工厂模式工厂模式是一种众所周知的设计模式，用于抽象创建特定对象的过程。下面的例子展示了一种按照特定接口创建对象的方式：\nfunction createPerson(name, age, job) &#123;\tlet o = new Object();    o.name = name;    o.age = age;    o.job = job;    o.sayName = function() &#123;    \tconsole.log(this.name);    &#125;;\treturn o;&#125;let person1 = createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);let person2 = createPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;);\n\n这种工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题（即新创建的对象是什么类型）。\n2.2 构造函数模式ES 中的构造函数是用于创建特定类型对象的。像 Object 和 Array 这样的原生构造函数，运行时可以直接在执行环境中使用。当然也可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法：\nfunction Person(name, age, job)&#123;    this.name = name;    this.age = age;    this.job = job;    this.sayName = function() &#123;    \tconsole.log(this.name);\t&#125;;&#125;let person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);let person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);person1.sayName(); // Nicholasperson2.sayName(); // Greg\n\n在这个例子中，Person()构造函数代替了createPerson()工厂函数。实际上，Person()内部的代码跟createPerson()基本是一样的，只是有如下区别。\n\n没有显式地创建对象。\n属性和方法直接赋值给了this。\n没有return。\n\n\n要创建 Person 的实例，应使用 new 操作符。以这种方式调用构造函数会执行如下操作：\n\n在内存中创建一个新对象。\n\n这个新对象内部的[[Prototype]]特性被赋值为构造函数的prototype 属性。\n\n构造函数内部的 this 被赋值为这个新对象（即this 指向新对象）。\n\n执行构造函数内部的代码（给新对象添加属性）。\n\n如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。\n\n\n\n上一个例子的最后，person1 和person2 分别保存着Person 的不同实例。这两个对象都有一个constructor属性指向Person，如下所示：\nconsole.log(person1.constructor == Person); // trueconsole.log(person2.constructor == Person); // true\n\nconstructor 本来是用于标识对象类型的。不过，一般认为instanceof 操作符是确定对象类型更可靠的方式。前面例子中的每个对象都是Object 的实例，同时也是Person 的实例，如下面调用instanceof 操作符的结果所示：\nconsole.log(person1 instanceof Object); // trueconsole.log(person1 instanceof Person); // trueconsole.log(person2 instanceof Object); // trueconsole.log(person2 instanceof Person); // true\n\n2.2.1 构造函数与普通函数构造函数与普通函数唯一的区别就是调用方式不同。任何函数只要使用 new 操作符调用就是构造函数，而不使用 new 操作符调用的函数就是普通函数。比如，前面的例子中定义的 Person()可以像下面这样调用：\n// 作为构造函数let person = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);person.sayName(); // &quot;Nicholas&quot;// 作为函数调用Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); // 添加到window 对象window.sayName(); // &quot;Greg&quot;// 在另一个对象的作用域中调用let o = new Object();Person.call(o, &quot;Kristen&quot;, 25, &quot;Nurse&quot;);o.sayName(); // &quot;Kristen&quot;\n\n普通函数没有使用new操作符调用Person()，结果会将属性和方法添加到 window 对象。这里要记住，在调用一个函数而没有明确设置this 值的情况下（即没有作为对象的方法调用，或者没有使用call()/apply()调用），this 始终指向 Global 对象（在浏览器中就是window 对象）\n2.2.2 构造函数的问题构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。因此对前面的例子而言，person1 和person2 都有名为sayName()的方法，但这两个方法不是同一个Function 实例。\nconsole.log(person1.sayName === person2.sayName)// false\n\n因为都是做一样的事，所以没必要定义两个不同的Function 实例。要解决这个问题，可以把函数定义转移到构造函数外部：\nfunction Person(name, age, job)&#123;    this.name = name;    this.age = age;    this.job = job;    this.sayName = sayName;&#125;function sayName() &#123;\tconsole.log(this.name);&#125;let person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);let person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);person1.sayName(); // Nicholasperson2.sayName(); // Greg\n\n这样虽然解决了相同逻辑的函数重复定义的问题，但全局作用域也因此被搞乱了，因为那个函数实际上只能在一个对象上调用。如果这个对象需要多个方法，那么就要在全局作用域中定义多个函数。这会导致自定义类型引用的代码不能很好地聚集一起。这个新问题可以通过原型模式来解决。\n2.3 原型模式每个函数都会创建一个prototype属性，这个属性是一个对象，包含该函数代表的类的实例共享的属性和方法。\n使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型，如下所示：\nfunction Person() &#123;&#125;//let Person = function() &#123;&#125;;Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function() &#123;\tconsole.log(this.name);&#125;;let person1 = new Person();person1.sayName(); // &quot;Nicholas&quot;let person2 = new Person();person2.sayName(); // &quot;Nicholas&quot;console.log(person1.sayName == person2.sayName); // true\n\n这里，所有属性和sayName()方法都直接添加到了Person 的prototype属性上，构造函数体中什么也没有。但这样定义之后，调用构造函数创建的新对象仍然拥有相应的属性和方法。与构造函数模式不同，使用这种原型模式定义的属性和方法是由所有实例共享的。\n3 参考【1】JavaScript高级程序设计（第四版）\n","categories":["JavaScript"],"tags":["JavaScript","前端"]},{"title":"JS深入学习(2)：原型与原型链","url":"/2022/01/14/JS-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/","content":"1 原型每个函数都会创建一个prototype属性，这个属性是一个对象，包含该函数代表的类的实例共享的属性和方法。\n构造函数与原型的区别在于，构造函数定义的方法会在每个实例上都创建一遍。而原型中定义的方法所有实例共享。\n1.1 理解原型无论何时，只要创建一个函数(类的申明)，就会按照特定的规则为这个函数创建一个prototype 属性（指向原型对象）。\n\n\n因为原型是通过调用构造函数创建的对象的原型。所有原型对象自动获得一个名为constructor的属性，指回与之关联的构造函数。对前面的例子而言，Person.prototype.constructor指向Person。\n\n\n在自定义构造函数时，原型对象默认只会获得constructor 属性，其他的所有方法都继承自Object。每次调用构造函数创建一个新实例，这个实例的内部[[Prototype]]指针就会被赋值为构造函数的原型对象。Firefox、Safari 和Chrome会在每个对象上暴露__proto__属性（等同于[[Prototype]]），通过这个属性可以访问对象的原型。\n关键在于理解这一点：实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有。\n\n\n在前面，我们已经讲了原型也是一个对象，其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 __proto__ 指向构造函数的 prototype ，所以我们再更新下关系图：\n\n\n而Object.prototype 的原型呢，打印可知原型为null，然而 null 究竟代表了什么呢？引用阮一峰老师的 《undefined与null的区别》 就是：\n\nnull 表示“没有对象”，即该处不应该有值。\n\n所以 Object.prototype.proto 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。所以查找属性的时候查到 Object.prototype 就可以停止查找了。最后一张关系图也可以更新为：\n\n\n下面一个综合的例子：\n/*** 构造函数可以是函数表达式* 也可以是函数声明，因此以下两种形式都可以：* function Person() &#123;&#125;* let Person = function() &#123;&#125;*/function Person() &#123;&#125;/*** 声明之后，构造函数就有了一个* 与之关联的原型对象：*/console.log(typeof Person.prototype);console.log(Person.prototype);// &#123;// constructor: f Person(),// __proto__: Object// &#125;/*** 如前所述，构造函数有一个prototype 属性* 引用其原型对象，而这个原型对象也有一个* constructor 属性，引用这个构造函数* 换句话说，两者循环引用：*/console.log(Person.prototype.constructor === Person); // true/*** 正常的原型链都会终止于Object 的原型对象* Object 原型的原型是null*/console.log(Person.prototype.__proto__ === Object.prototype); // trueconsole.log(Person.prototype.__proto__.constructor === Object); // trueconsole.log(Person.prototype.__proto__.__proto__ === null); // trueconsole.log(Person.prototype.__proto__);// &#123;// constructor: f Object(),// toString: ...// hasOwnProperty: ...// isPrototypeOf: ...// ...// &#125;let person1 = new Person(),person2 = new Person();/*** 构造函数、原型对象和实例* 是3 个完全不同的对象：*/console.log(person1 !== Person); // trueconsole.log(person1 !== Person.prototype); // trueconsole.log(Person.prototype !== Person); // true/*** 实例通过__proto__链接到原型对象，* 它实际上指向隐藏特性[[Prototype]]** 构造函数通过prototype 属性链接到原型对象** 实例与构造函数没有直接联系，与原型对象有直接联系*/console.log(person1.__proto__ === Person.prototype); // trueconosle.log(person1.__proto__.constructor === Person); // true/*** 同一个构造函数创建的两个实例* 共享同一个原型对象：*/console.log(person1.__proto__ === person2.__proto__); // true/*** instanceof 检查实例的原型链中* 是否包含指定构造函数的原型：*/console.log(person1 instanceof Person); // trueconsole.log(person1 instanceof Object); // trueconsole.log(Person.prototype instanceof Object); // true\n\n\n\n另外：原型对象可以通过Object.getPrototypeOf(对象实例)来返回实例[[prototype]]的值\n1.2 原型层次在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身。如果在这个实例上发现了给定的名称，则返回该名称对应的值。如果没有找到这个属性，则搜索会沿着指针进入原型对象，然后在原型对象上找到属性后，再返回对应的值。\n因此，在调用person1.sayName()时，会发生两步搜索。首先，JavaScript 引擎会问：“person1 实例有sayName 属性吗？”答案是没有。然后，继续搜索并问：“person1 的原型有sayName 属性吗？”答案是有。于是就返回了保存在原型上的这个函数。在调用person2.sayName()时，会发生同样的搜索过程，而且也会返回相同的结果。这就是原型用于在多个对象实例间共享属性和方法的原理。\n虽然可以通过实例读取原型对象上的值，但不可能通过实例重写这些值。如果在实例上添加了一个与原型对象中同名的属性，那就会在实例上创建这个属性，这个属性会遮住原型对象上的属性：\nfunction Person() &#123;&#125;Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function() &#123;\tconsole.log(this.name);&#125;;let person1 = new Person();let person2 = new Person();person1.name = &quot;Greg&quot;;console.log(person1.name); // &quot;Greg&quot;，来自实例console.log(person2.name); // &quot;Nicholas&quot;，来自原型\n\n使用delete操作符可以完全删除实例上的这个属性，从而让标识符解析过程能够继续搜索原型对象：\ndelete person1.name;console.log(person1.name); // &quot;Nicholas&quot;，来自原型\n\nhasOwnProperty()方法用于确定某个属性是在实例上还是在原型对象上。这个方法是继承自Object的，会在属性存在于调用它的对象实例上时返回true，如下面的例子所示：\nperson1.name = &quot;Greg&quot;;console.log(person1.name); // &quot;Greg&quot;，来自实例console.log(person1.hasOwnProperty(&quot;name&quot;)); // trueconsole.log(person2.name); // &quot;Nicholas&quot;，来自原型console.log(person2.hasOwnProperty(&quot;name&quot;)); // false\n\n1.3 in操作符有两种方式使用 in 操作符：\n\n在for-in 循环中使用：在for-in 循环中使用 in 操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性。\n  要获得对象上所有可枚举的实例属性，可以使用Object.keys()方法。这个方法接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组。\n  function Person() &#123;&#125;Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function() &#123;\tconsole.log(this.name);&#125;;let keys = Object.keys(Person.prototype);console.log(keys); // &quot;name,age,job,sayName&quot;let p1 = new Person();p1.name = &quot;Rob&quot;;p1.age = 31;let p1keys = Object.keys(p1);console.log(p1keys); // &quot;[name,age]&quot;\n\n  如果想列出所有实例属性，无论是否可以枚举，都可以使用Object.getOwnPropertyNames()：\n  let keys = Object.getOwnPropertyNames(Person.prototype);console.log(keys); // &quot;[constructor,name,age,job,sayName]&quot;\n单独使用：in 操作符会在可以通过对象访问指定属性时返回true，无论该属性是在实例上还是在原型上。\n  function Person() &#123;&#125;Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function() &#123;\tconsole.log(this.name);&#125;;let person1 = new Person();console.log(person1.hasOwnProperty(&quot;name&quot;)); // falseconsole.log(&quot;name&quot; in person1); // trueperson1.name = &quot;Greg&quot;;console.log(person1.name); // &quot;Greg&quot;，来自实例console.log(person1.hasOwnProperty(&quot;name&quot;)); // trueconsole.log(&quot;name&quot; in person1); // true\n\n  可以通过对 in 与 hasOwnProperty()的组合判断一个属性是在实例上还是在原型上：\n\nname in object === true &amp;&amp; Object.hasOwnProperty(name)===true：该属性在实例上\nname in object === true &amp;&amp; Object.hasOwnProperty(name)===false：该属性在原型上\n\n\n\n1.4 原型语法在前面的例子中，每次定义一个属性或方法都会把Person.prototype重写一遍。为了减少代码冗余，直接通过一个包含所有属性和方法的对象字面量(&#123;&#125;)来重写原型成为了一种常见的做法，如下面的例子所示：\nfunction Person() &#123;&#125;Person.prototype = &#123;    name: &quot;Nicholas&quot;,    age: 29,    job: &quot;Software Engineer&quot;,    sayName() &#123;    \tconsole.log(this.name);    &#125;&#125;;\n\n在这个例子中，Person.prototype 被设置为等于一个通过对象字面量创建的新对象。\n但这样重写之后，Person.prototype 的 constructor 属性就不指向 Person 了。在创建函数时，也会创建它的 prototype  对象，同时会自动给这个原型的 constructor 属性赋值。而上面的写法完全重写了默认的prototype 对象，因此其constructor 属性也指向了完全不同的新对象（Object 构造函数），不再指向原来的构造函数。虽然instanceof 操作符还能可靠地返回值，但我们不能再依靠 constructor 属性来识别类型了，如下面的例子所示：\nlet friend = new Person();console.log(friend instanceof Object); // trueconsole.log(friend instanceof Person); // trueconsole.log(friend.constructor == Person); // falseconsole.log(friend.constructor == Object); // true\n\n如果 constructor 的值很重要，则可以像下面这样在重写原型对象时专门设置一下它的值：\nfunction Person() &#123;&#125;Person.prototype = &#123;    constructor: Person,    name: &quot;Nicholas&quot;,    age: 29,    job: &quot;Software Engineer&quot;,    sayName() &#123;        console.log(this.name);    &#125;&#125;;\n\n但要注意，以这种方式恢复的 constructor 属性的[[Enumerable]]为true。而原生 constructor 属性默认是不可枚举的。\n某些情况可以改为使用Object.defineProperty()方法来定义constructor 属性：\nfunction Person() &#123;&#125;    Person.prototype = &#123;    name: &quot;Nicholas&quot;,    age: 29,    job: &quot;Software Engineer&quot;,    sayName() &#123;    \tconsole.log(this.name);\t&#125;&#125;;// 恢复constructor 属性Object.defineProperty(Person.prototype, &quot;constructor&quot;, &#123;\tenumerable: false,\tvalue: Person&#125;);\n\n1.5 原型动态性因为从原型上搜索值的过程是动态的，所以即使实例在修改原型之前已经存在，任何时候对原型对象所做的修改也会在实例上反映出来：\nfunction Person()&#123;&#125;;let friend = new Person();Person.prototype.sayHi = function() &#123;\tconsole.log(&quot;hi&quot;);&#125;;friend.sayHi(); // &quot;hi&quot;，没问题！\n\n之所以会这样，主要原因是实例与原型之间松散的联系。在调用friend.sayHi()时，首先会从这个实例中搜索名为 sayHi 的属性。在没有找到的情况下，运行时会继续搜索原型对象。因为实例和原型之间的链接就是简单的指针(__proto__)，而不是保存的副本，所以会在原型上找到 sayHi 属性并返回这个属性保存的函数。\n实例的[[Prototype]]指针是在调用构造函数时自动赋值的，这个指针即使把原型修改为不同的对象也不会变。重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型。\nfunction Person() &#123;&#125;let friend = new Person();Person.prototype = &#123;    constructor: Person,    name: &quot;Nicholas&quot;,    age: 29,    job: &quot;Software Engineer&quot;,    sayName() &#123;    \tconsole.log(this.name);    &#125;&#125;;friend.sayName(); // 错误\n\n在这个例子中，重写构造函数上的原型之后再创建的实例才会引用新的原型。而在此之前创建的实例仍然会引用最初的原型。\n\n\n1.6 原型的问题首先，它弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值。虽然这会带来不便，但原型的最主要问题源自它的共享特性。\n包含原始类型的值的属性还好，但包含引用值的属性时非常不便：\nfunction Person() &#123;&#125;Person.prototype = &#123;\tconstructor: Person,\tname: &quot;Nicholas&quot;,\tage: 29,\tjob: &quot;Software Engineer&quot;,\tfriends: [&quot;Shelby&quot;, &quot;Court&quot;],\tsayName() &#123;\t\tconsole.log(this.name);\t&#125;&#125;;let person1 = new Person();let person2 = new Person();person1.friends.push(&quot;Van&quot;);console.log(person1.friends); // &quot;Shelby,Court,Van&quot;console.log(person2.friends); // &quot;Shelby,Court,Van&quot;console.log(person1.friends === person2.friends); // true\n\nperson1.friends 通过push 方法向数组中添加了一个字符串。由于这个friends 属性存在于Person.prototype 而非person1 上，新加的这个字符串也会在（指向同一个数组的）person2.friends 上反映出来。如果这是有意在多个实例间共享数组，那没什么问题。但一般来说，不同的实例应该有属于自己的属性副本。这就是实际开发中通常不单独使用原型模式的原因。\n2 继承与原型链面向对象语言都支持两种继承：接口继承和实现继承。前者只继承方法签名，后者继承实际的方法。接口继承在ECMAScript 中是不可能的，因为函数没有签名。实现继承是ECMAScript 唯一支持的继承方式，而这主要是通过原型链实现的。\n2.1 原型链ES6之前的继承方式。其基本思想就是通过原型继承多个引用类型的属性和方法。\n\n重温一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象(Person.prototype)，原型有一个属性(constructor)指回构造函数，而实例有一个内部指针(__proto__)指向原型。\n如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。\n\n// 父类function SuperType() &#123;\tthis.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123;\treturn this.property;&#125;;// 子类function SubType() &#123;\tthis.subproperty = false;&#125;// 子类继承SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function () &#123;\treturn this.subproperty;&#125;;let instance = new SubType();console.log(instance.getSuperValue()); // true\n\n这个例子中实现继承的关键，是SubType 没有使用默认原型，而是将其替换成了一个新的对象。这个新的对象恰好是 SuperType 的实例。这样一来，SubType 的实例不仅能从 SuperType 的实例中继承属性和方法，而且还与 SuperType 的原型挂上了钩。于是instance（通过内部的[[Prototype]]）指向 SubType.prototype，而SubType.prototype（作为SuperType 的实例又通过内部的[[Prototype]]）指向SuperType.prototype。\n\n\n我们知道，在读取实例上的属性时，首先会在实例上搜索这个属性。如果没找到，则会继承搜索实例的原型。在通过原型链实现继承之后，搜索就可以继承向上，搜索原型的原型，对属性和方法的搜索会一直持续到原型链的末端。\n2.1.1 默认原型默认情况下，所有引用类型都继承自Object，这也是通过原型链实现的。任何函数的默认原型都是一个Object 的实例，这意味着这个实例有一个内部指针指向Object.prototype。这也是为什么自定义类型能够继承包括toString()、valueOf()在内的所有默认方法的原因。\n\n\n2.1.2 继承关系原型与实例的关系可以通过两种方式来确定。\n\n使用instanceof 操作符，如果一个实例的原型链中出现过相应的构造函数，则instanceof 返回true。\n  console.log(instance instanceof Object); // trueconsole.log(instance instanceof SuperType); // trueconsole.log(instance instanceof SubType); // true\n使用isPrototypeOf()方法。原型链中的每个原型都可以调用这个方法，如下例所示，只要原型链中包含这个原型，这个方法就返回true：\n  console.log(Object.prototype.isPrototypeOf(instance)); // trueconsole.log(SuperType.prototype.isPrototypeOf(instance)); // trueconsole.log(SubType.prototype.isPrototypeOf(instance)); // true\n\n2.1.3 子类重载子类有时候需要覆盖父类的方法，或者增加父类没有的方法。为此，这些方法必须在原型赋值之后再添加到原型上。\nfunction SuperType() &#123;\tthis.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123;\treturn this.property;&#125;;function SubType() &#123;\tthis.subproperty = false;&#125;// 继承SuperTypeSubType.prototype = new SuperType();// 新方法SubType.prototype.getSubValue = function () &#123;\treturn this.subproperty;&#125;;// 覆盖已有的方法SubType.prototype.getSuperValue = function () &#123;\treturn false;&#125;;let instance = new SubType();console.log(instance.getSuperValue()); // false\n\n以对象字面量方式创建原型方法会破坏之前的原型链，因为这相当于重写了原型链。\n...// 继承SuperTypeSubType.prototype = new SuperType();// 通过对象字面量添加新方法，这会导致上一行无效SubType.prototype = &#123;\tgetSubValue() &#123;\t\treturn this.subproperty;\t&#125;,\tsomeOtherMethod() &#123;\t\treturn false;\t&#125;&#125;;let instance = new SubType();console.log(instance.getSuperValue()); // 出错！\n\n在这段代码中，子类的原型在被赋值为SuperType 的实例后，又被一个对象字面量覆盖了。覆盖后的原型是一个 Object 的实例，而不再是 SuperType 的实例。\n2.1.4 原型链的问题原型链虽然是实现继承的强大工具，但它也有问题。主要体现在两个方面：\n\n原型中包含的引用值会在所有实例间共享，这也是为什么属性通常会在构造函数中定义而不会定义在原型上的原因。在使用原型实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变成为了原型属性。\n  function SuperType() &#123;\tthis.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;function SubType() &#123;&#125;// 继承SuperTypeSubType.prototype = new SuperType();let instance1 = new SubType();instance1.colors.push(&quot;black&quot;);console.log(instance1.colors); // &quot;red,blue,green,black&quot;let instance2 = new SubType();console.log(instance2.colors); // &quot;red,blue,green,black&quot;\n\n  当SubType 通过原型继承SuperType 后，SubType.prototype 变成了SuperType 的一个实例，因而也获得了自己的colors属性。这类似于创建了SubType.prototype.colors 属性。最终结果是，SubType 的所有实例都会共享这个colors 属性。\n\n子类型在实例化时不能给父类型的构造函数传参。\n\n\n这两个问题使得原型链基本不会被单独使用。\n2.2 原型链的改进为了解决原型链存在的问题，发明了很多技术：\n\n**盗用构造函数(constructor stealing)**：使用call()调用父类构造函数\n  问题：同构造函数缺点，方法不能复用、子类也不能访问父类原型\n\n组合继承：结合盗用构造函数与原型链继承\n  问题：调用两次父类构造函数\n\n原型式继承：返回一个父类的实例副本\n  问题：同原型模式缺点，引用值属性在实例间共享\n\n寄生式继承：在原型式继承的基础上增强这个实例\n  问题：既有构造函数缺点，也有原型模式缺点\n\n寄生式组合继承：不通过将子类原型指向父类对象实现继承，而是取得一个父类原型的副本赋给子类原型\n\n\n2.2.1 盗用构造函数“盗用构造函数”（constructor stealing）有时也称作“对象伪装”或“经典继承”。基本思路很简单：在子类构造函数中调用父类构造函数。因为毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用apply()和call()方法以新创建的对象为上下文执行构造函数。\ncall()与apply()的解释\n这里指的注意的是，使用call()或apply()时传入一个当前this指针，使得call()与apply()内部的this指向发生变化。\nfunction SuperType() &#123;\tthis.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;function SubType() &#123;// 继承SuperType\tSuperType.call(this);&#125;let instance1 = new SubType();instance1.colors.push(&quot;black&quot;);console.log(instance1.colors); // &quot;red,blue,green,black&quot;let instance2 = new SubType();console.log(instance2.colors); // &quot;red,blue,green&quot;\n\n盗用构造函数的另一个优点就是可以在子类构造函数中向父类构造函数传参。这是利用call()函数传递一个参数列表给父类构造函数：\nfunction SuperType(name)&#123;\tthis.name = name;&#125;function SubType() &#123;\t// 继承SuperType 并传参\tSuperType.call(this, &quot;Nicholas&quot;);\t// 实例属性\tthis.age = 29;&#125;let instance = new SubType();console.log(instance.name); // &quot;Nicholas&quot;;console.log(instance.age); // 29\n\n盗用构造函数的主要缺点：\n\n也是使用构造函数模式自定义类型的问题：必须在构造函数中定义方法，因此函数不能重用。\n子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式。\n\n由于存在这些问题，盗用构造函数基本上也不能单独使用。\n2.2.2 组合继承组合继承（有时候也叫伪经典继承）综合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。来看下面的例子：\nfunction SuperType(name)&#123;    this.name = name;    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function() &#123;\tconsole.log(this.name);&#125;;function SubType(name, age)&#123;// 继承属性    SuperType.call(this, name);    this.age = age;&#125;// 继承方法SubType.prototype = new SuperType();SubType.prototype.sayAge = function() &#123;\tconsole.log(this.age);&#125;;let instance1 = new SubType(&quot;Nicholas&quot;, 29);instance1.colors.push(&quot;black&quot;);console.log(instance1.colors); // &quot;red,blue,green,black&quot;instance1.sayName(); // &quot;Nicholas&quot;;instance1.sayAge(); // 29let instance2 = new SubType(&quot;Greg&quot;, 27);console.log(instance2.colors); // &quot;red,blue,green&quot;instance2.sayName(); // &quot;Greg&quot;;instance2.sayAge(); // 27\n\n组合继承弥补了原型链和盗用构造函数的不足，是JavaScript 中使用最多的继承模式。而且组合继承也保留了instanceof 操作符和isPrototypeOf()方法识别合成对象的能力。\n2.2.3 原型式继承原型式继承的思路是利用原型即使不自定义类型也可以通过原型实现对象之间的信息共享。这个思想主要依赖下面这个函数：\nfunction object(o) &#123;    function F() &#123;&#125;    F.prototype = o;    return new F();&#125;\n\n这个object()函数会创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。本质上，object()是对传入的对象执行了一次浅复制：\nlet person = &#123;name: &quot;Nicholas&quot;,\tfriends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#125;;let anotherPerson = object(person);anotherPerson.name = &quot;Greg&quot;;anotherPerson.friends.push(&quot;Rob&quot;);let yetAnotherPerson = object(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;);console.log(person.friends); // &quot;Shelby,Court,Van,Rob,Barbie&quot;\n\n每次将person传给object()，实际上是克隆了一个person对象，这个新对象的原型是person，意味着它的原型上既有原始值属性又有引用值属性。这也意味着person.friends 不仅是 person 的属性，也会跟 anotherPerson 和yetAnotherPerson共享。\nES5中的Object.create()方法将原型式继承的概念规范化，这个方法接收两个参数：\n\n作为新对象原型的对象，\n\n新对象定义额外属性的对象（第二个可选）。\n\n\n在只有一个参数时，Object.create()与这里的object()方法效果相同。Object.create()的第二个参数与Object.defineProperties()的第二个参数一样：每个新增属性都通过各自的描述符来描述。以这种方式添加的属性会遮蔽原型对象上的同名属性。比如：\nlet person = &#123;\tname: &quot;Nicholas&quot;,\tfriends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#125;;let anotherPerson = Object.create(person, &#123;\tname: &#123;\t\tvalue: &quot;Greg&quot;\t&#125;&#125;);console.log(anotherPerson.name); // &quot;Greg&quot;\n\n原型式继承非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。但要，属性中包含的引用值始终会在相关对象间共享，跟使用原型模式是一样的。\n2.2.4 寄生式继承寄生式继承与原型继承的不同在于：寄生式继承创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。基本的寄生继承模式如下：\nfunction createAnother(original)&#123;\tlet clone = object(original); // 通过调用函数创建一个新对象\tclone.sayHi = function() &#123; // 以某种方式增强这个对象\t\tconsole.log(&quot;hi&quot;);\t&#125;;\treturn clone; // 返回这个对象&#125;\n\n通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似。\n2.2.5 寄生式组合继承组合继承中，父类构造函数始终会被调用两次：一次在是创建子类原型时调用，另一次是在子类构造函数中调用，回顾一下组合继承：\nfunction SuperType(name) &#123;\tthis.name = name;\tthis.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function() &#123;\tconsole.log(this.name);&#125;;function SubType(name, age)&#123;\tSuperType.call(this, name); // 第二次调用SuperType()\tthis.age = age;&#125;SubType.prototype = new SuperType(); // 第一次调用SuperType()SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function() &#123;\tconsole.log(this.age);&#125;;\n\nname 和 colors 都是SuperType 的实例属性，但在SubType.prototype = new SuperType();后成为了SubType 的原型属性。在调用SubType 构造函数时，也会调用SuperType 构造函数SuperType.call(this, name);，这一次会在新对象上创建实例属性name 和colors。这两个实例属性会遮蔽原型上同名的属性\n\n\n\n\n寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。寄生式组合继承的基本模式如下所示：\nfunction inheritPrototype(subType, superType) &#123;    let prototype = object(superType.prototype); // 创建对象    prototype.constructor = subType; // 增强对象    subType.prototype = prototype; // 赋值对象&#125;// 实例演示function SuperType(name) &#123;    this.name = name;    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function() &#123;\tconsole.log(this.name);&#125;;function SubType(name, age) &#123;\tSuperType.call(this, name);    this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function() &#123;\tconsole.log(this.age);&#125;;\n\n这里只调用了一次SuperType 构造函数，避免了SubType.prototype 上不必要也用不到的属性，因此可以说这个例子的效率更高。而且，原型链仍然保持不变，因此 instanceof 操作符和 isPrototypeOf()方法正常有效。寄生式组合继承可以算是引用类型继承的最佳模式。\n3 参考【1】JavaScript高级程序设计（第四版）\n【2】JavaScript深入之从原型到原型链 · Issue #2 · mqyqingfeng/Blog (github.com)\n","categories":["JavaScript"],"tags":["JavaScript","前端"]},{"title":"JS深入学习(5)：执行上下文","url":"/2022/01/16/JS-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/","content":"JavaScript 的可执行代码(Executable Code)的类型有哪些？其实很简单，就三种：\n\n全局代码(最外层的代码)\n函数代码(声明的函数以及嵌套函数内的代码)\neval代码。\n\n每当执行到一段代码时，JS引擎总是先扫描一遍这段代码，创建一个相关的执行上下文（全局上下文、函数上下文、eval上下文）再执行。变量或函数的执行上下文决定了它们可以访问哪些数据，以及它们的行为。对于每个执行上下文，都有三个重要属性，它们影响着变量的解析，变量作用域和函数this的指向。：\n\n\n\n变量对象(Variable object，VO)：变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。不同执行上下文下的变量对象稍有不同\n作用域链(Scope chain)\nthis\n\n1 执行上下文栈JavaScript 引擎会维护一个执行上下文栈（Execution context stack，ECS）来管理执行上下文，每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript程序的执行流就是通过这个上下文栈进行控制的。\n\n一个执行上下文可以激活另一个上下文，就好比一个函数调用了另一个函数(或者全局的上下文调用了一个全局函数)，然后一层一层调用下去。逻辑上来说，这种实现方式是栈，我们可以称之为上下文堆栈。\n激活其它上下文的某个上下文被称为调用者(caller) 。被激活的上下文被称为**被调用者(callee)**。被调用者同时也可能是调用者(比如一个在全局上下文中被调用的函数调用某些自身的内部方法)。\n当一个caller激活了一个callee，那么这个caller就会暂停它自身的执行，然后将控制权交给这个callee. 于是这个callee被放入堆栈，称为进行中的上下文[running/active execution context]. 当这个callee的上下文结束之后，会把控制权再次交给它的caller，然后caller会在刚才暂停的地方继续执行。在这个caller结束之后，会继续触发其他的上下文。一个callee可以用返回（return）或者抛出异常（exception）来结束自身的上下文。\n如下图，所有的ECMAScript的程序执行都可以看做是一个执行上下文堆栈[execution context (EC) stack]。堆栈的顶部就是处于激活状态的上下文。\n\n\n\n为了模拟执行上下文栈的行为，我们定义执行上下文栈：\nECStack = [];\n\n当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用globalContext表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext，以下面这个程序为例：\nfunction fun3() &#123;    console.log(&#x27;fun3&#x27;)&#125;function fun2() &#123;    fun3();&#125;function fun1() &#123;    fun2();&#125;fun1()\n\n当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码：\n// ECStack = [globalContext]// fun1()ECStack.push(&lt;fun1&gt; functionContext);// fun1中调用了fun2，创建fun2的执行上下文ECStack.push(&lt;fun2&gt; functionContext);// fun2还调用了fun3，创建fun2的执行上下文ECStack.push(&lt;fun3&gt; functionContext);// fun3执行完毕ECStack.pop();// fun2执行完毕ECStack.pop();// fun1执行完毕ECStack.pop();// ECStack = [globalContext]\n\n2 变量对象\nA variable object is a scope of data related with the execution context. It’s a special object associated with the context and which stores variables and function declarations are being defined within the context.\n变量对象(variable object) 是与执行上下文相关的 数据作用域(scope of data) 。它是与上下文关联的特殊对象，用于存储被定义在上下文中的变量(variables) 和函数声明(function declarations) 。\n\n2.1 全局上下文中的变量对象全局上下文是最外层的上下文。根据 ECMAScript 实现的宿主环境，表示全局上下文的对象可能不一样。在浏览器中，全局上下文就是我们常说的 window 对象，上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。\n所有通过 var 定义的全局变量和函数以及函数声明都会成为 window 对象的属性和方法。使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。\nvar foo = 10;function bar() &#123;&#125; //  函数声明console.log(  this.foo == foo, // true  window.bar == bar // true);\n\n\n\n因此全局上下文中的变量对象就是全局对象\n2.2 函数上下文中的变量对象在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。\n\n活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object ，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。\n\n一般来说，可执行代码会分成三个阶段进行处理：创建，进入和执行，我们也可以叫做：\n\n创建上下文：代码流执行到该段可执行代码（调用一个函数），创建执行上下文并推到ECS中。\n\n进入上下文：JS引擎扫描该段可执行代码\n 活动对象是在进入函数上下文时刻被创建的，活动对象最初只有一个定义变量：arguments。（全局上下文中没有这个变量）\n\n代码执行\n\n\n如果可执行代码是一段函数，最前面多一阶段：在定义函数时，就会为它创建作用域链，预装载全局变量对象，并保存在内部的[[Scope]]中。\n第一阶段前面分析过，重点关注后两个阶段\n2.2.1 进入上下文当进入上下文时，这时候还没有执行代码，变量对象会包括：\n\n函数的所有形参 (如果是函数上下文)\n由名称和对应值组成的一个变量对象的属性被创建\n没有实参，属性值设为 undefined\n\n\n函数声明\n由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建\n如果变量对象已经存在相同名称的属性，则完全替换这个属性\n注意：这里是函数声明(function xx(){})，而不是函数表达式。函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。\n函数声明提升\n\n\n变量声明\n由名称和对应值（undefined）组成一个变量对象的属性被创建；\n如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性\n变量声明提升\n\n\n\n举例：\nfunction foo(a) &#123;  var b = 2;  function c() &#123;&#125;  var d = function() &#123;&#125;;  b = 3;&#125;foo(1);\n\n在进入执行上下文后，这时候的 AO 是：\nAO = &#123;    arguments: &#123;        0: 1,        length: 1    &#125;,    a: 1,    b: undefined,    c: reference to function c()&#123;&#125;,    d: undefined&#125;\n\n2.2.2 代码执行在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值\n还是上面的例子，当代码执行完后，这时候的 AO 是：\nAO = &#123;    arguments: &#123;        0: 1,        length: 1    &#125;,    a: 1,    b: 3,    c: reference to function c()&#123;&#125;,    d: reference to FunctionExpression &quot;d&quot;&#125;\n\n2.2.3 总结\n全局上下文的变量对象初始化是全局对象\n函数上下文的变量对象初始化只包括 Arguments 对象\n在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值\n在代码执行阶段，会再次修改变量对象的属性值\n\n2.3 变量声明2.3.1 var在使用var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在with 语句中，最接近的上下文也是函数上下文。\n如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文\nfunction add(num1, num2) &#123;\tvar sum1 = num1 + num2;\tsum2 = num1 + num2;\treturn sum1,sum2;&#125;let result1,result2 = add(10, 20); // 30console.log(sum2); // 30console.log(sum1); // ReferenceError: sum1 is not defined\n\nvar 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫作“提升”(hoisting)。提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用。\nfunction() &#123;\tconsole.log(name); // undefined\tvar name = &#x27;Jake&#x27;;&#125;\n\n2.3.2 letES6 新增的let 关键字跟var 很相似，但它的作用域是块级的，这也是JavaScript 中的新概念。块级作用域由最近的一对包含花括号{}界定。换句话说，if 块、while 块、function 块，甚至连单独的块也是let 声明变量的作用域。\nif (true) &#123;\tlet a;&#125;console.log(a); // ReferenceError: a 没有定义while (true) &#123;\tlet b;&#125;console.log(b); // ReferenceError: b 没有定义function foo() &#123;let c;&#125;console.log(c); // ReferenceError: c 没有定义// 这没什么可奇怪的// var 声明也会导致报错// 这不是对象字面量，而是一个独立的块// JavaScript 解释器会根据其中内容识别出它来&#123;let d;&#125;console.log(d); // ReferenceError: d 没有定义\n\nlet 与 var 的另一个不同之处是在同一作用域内不能声明两次。重复的 var 声明会被忽略，而重复的 let 声明会抛出SyntaxError。\nlet 的行为非常适合在循环中声明迭代变量。使用 var 声明的迭代变量会泄漏到循环外部\n2.3.3 const使用 const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。\nconst 声明只应用到顶级原语或者对象。换句话说，赋值为对象的const 变量不能再被重新赋值为其他引用值，但对象的键则不受限制。\nconst o1 = &#123;&#125;;o1 = &#123;&#125;; // TypeError: 给常量赋值const o2 = &#123;&#125;;o2.name = &#x27;Jake&#x27;;console.log(o2.name); // &#x27;Jake&#x27;\n\n如果想让整个对象都不能修改，可以使用Object.freeze()，这样再给属性赋值时虽然不会报错，但会静默失败：\nconst o3 = Object.freeze(&#123;&#125;);o3.name = &#x27;Jake&#x27;;console.log(o3.name); // undefined\n\n由于const 声明暗示变量的值是单一类型且不可修改，JavaScript 运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找。\n3 作用域链由多个执行上下文的变量对象构成的链表就叫做作用域链。作用域链是一个对象列表(list of objects) ，用以检索上下文代码中出现的标识符(identifiers) 。\n作用域链中的下一个变量对象来自包含上下文(词法作用域)，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。\n之前提到，函数的作用域在函数定义的时候就决定了。这是因为**函数有一个内部属性 [[scope]]**，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链（不包括自身的变量对象/活动对象）！举个例子：\nvar x = 10;function foo() &#123;    var y = 20;    function bar() &#123;        var z = 30;        ...    &#125;&#125;\n\n函数创建时，各自的[[scope]]为：\nfoo.[[scope]] = [  globalContext.VO];bar.[[scope]] = [    fooContext.AO,    globalContext.VO];\n\n\n\n以下面的例子为例，结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程（此处省略全局上下文内容）：\nfunction createComparisonFunction(propertyName) &#123;\treturn function(object1, object2) &#123;        let value1 = object1[propertyName];        let value2 = object2[propertyName];\t\tif (value1 &lt; value2) &#123;\t\t\treturn -1;\t\t&#125; else if (value1 &gt; value2) &#123;\t\t\treturn 1;\t\t&#125; else &#123;\t\t\treturn 0;\t\t&#125;\t&#125;;&#125;let compare = createComparisonFunction(&#x27;name&#x27;);let result = compare(&#123; name: &#x27;Nicholas&#x27; &#125;, &#123; name: &#x27;Matt&#x27; &#125;);\n\n执行过程如下：\n\n定义createComparisonFunction 函数，保存作用域链到内部属性[[scope]]\n createComparisonFunction.[[scope]] = [    globalContext.VO];\n当调用 createComparisonFunction 时，创建 createComparisonFunction 函数执行上下文，createComparisonFunction 函数执行上下文被压入执行上下文栈\n createComparisonFunctionContext = &#123;    AO: &#123;        arguments: &#123;        \t0:undefined,            length: 1        &#125;,    &#125;，&#125;ECStack = [    createComparisonFunctionContext,    globalContext];\ncreateComparisonFunction 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性到执行上下文的作用域链\n createComparisonFunctionContext = &#123;    AO: &#123;         arguments: &#123;            0:undefined,            length: 1         &#125;,    &#125;，    Scope: checkscope.[[scope]],&#125;\n第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明\n createComparisonFunctionContext = &#123;    AO: &#123;        arguments: &#123;            0:&#x27;name&#x27;,            length: 1        &#125;,   \t\t// 暂无函数声明与变量声明    &#125;，    Scope: createComparisonFunction.[[scope]],&#125;\n第三步：将活动对象压入 checkscope 作用域链顶端\n createComparisonFunctionContext = &#123;    AO: &#123;        arguments: &#123;            0:&#x27;name&#x27;,            length: 1        &#125;,\t\t// 暂无函数声明与变量声明    &#125;,    Scope: [AO, [[Scope]]]&#125;\n准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值，createComparisonFunction()没有变量声明与函数声明，不需要修改\n createComparisonFunctionContext = &#123;    AO: &#123;        arguments: &#123;            0:&#x27;name&#x27;,            length: 1        &#125;,\t\t// 暂无函数声明与变量声明    &#125;,    Scope: [AO, [[Scope]]]&#125;\n准备返回时，扫描到匿名函数，保存作用域链到内部属性[[scope]]\n anonymityFunction[[scope]] = [\tcreateComparisonFunctionContext.AO,    globalContext.VO,];\n\n调用匿名函数时，创建 anonymityFunction 函数执行上下文，anonymityFunction 函数执行上下文被压入执行上下文栈\n anonymityFunctionFunctionContext = &#123;    AO: &#123;        arguments: &#123;        \t0:undefined,        \t1:undefined,            length: 2        &#125;,    value1:undefined,    value2:undefined    &#125;，&#125;ECStack = [\tanonymityFunctionFunctionContext,    createComparisonFunctionContext,    globalContext];\n\n同理，进入执行上下文，执行函数，并且更新上下文\n anonymityFunctionFunctionContext = &#123;    AO: &#123;        arguments: &#123;        \t0:undefined,        \t1:undefined,            length: 2        &#125;,    value1:&#123; name: &#x27;Nicholas&#x27; &#125;,    value2:&#123; name: &#x27;Matt&#x27; &#125;    &#125;,    Scope: [    \tanonymityFunctionFunctionContext.AO,    \tcreateComparisonFunctionContext.AO,     \t[[Scope]]    ]&#125;\n\n函数执行完毕，函数上下文从执行上下文栈中弹出\n ECStack = [ \tcreateComparisonFunctionContext,    globalContext];\n\ncreateComparisonFunction执行完毕，函数上下文从执行上下文栈中弹出\n ECStack = [==    globalContext];\n\n下图展示了调用compareNames()之后作用域链之间的关系。\n\n\ncreateComparisonFunction()的活动对象并不能在它执行完毕后销毁，因为匿名函数的作用域链中仍然有对它的引用。在createComparisonFunction()执行完毕后，其执行上下文的作用域链会销毁，但它的活动对象仍然会保留在内存中，直到匿名函数被销毁后才会被销毁。\n4 this当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。对于每个执行上下文，都有三个重要属性，this也是其中之一。通常，this 被错误地描述为变量对象的属性。请牢记：\n\na this value is a property of the execution context, but not a property of the variable object.\nthis是执行上下文环境的一个属性，而不是某个变量对象的属性\n\n这个特点很重要，因为和变量不同，this是没有一个类似搜寻变量的过程。当你在代码中使用了this，这个this的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。this的值只取决于进入上下文时的情况。\n在通常的函数调用中，this是由激活上下文代码的调用者(caller)来提供的，即调用函数的父上下文(parent context)。this取决于调用函数的方式。【5】\n\n正是调用函数的方式影响了调用的上下文中的this值，没有别的什么（我们可以在一些文章，甚至是在关于javascript的书籍中看到，它们称：“this值取决于函数如何定义，如果它是全局函数，this设置为全局对象，如果函数是一个对象的方法，this将总是指向这个对象。–这绝对不正确”）。即使是正常的全局函数也会被调用方式的不同形式激活，这些不同的调用方式导致了不同的this值。\nfunction foo() &#123;    console.log(this);&#125;      console.log(foo === foo.prototype.constructor); // true// 但是同一个function的不同的调用表达式，this是不同的foo(); // global  console.log(&#x27;---------------&#x27;)foo.prototype.constructor(); // foo.prototype\n\n\n\n那么，调用函数的方式如何影响this值？为了充分理解this值的确定，需要详细分析其内部类型之一——引用类型（Reference type）。\n5 引用类型解释this由冴羽大佬的博客JavaScript深入之从ECMAScript规范解读this · Issue #7 · mqyqingfeng/Blog (github.com)中我们得知：\nECMAScript 的类型分为语言类型和规范类型：\n\n语言类型是开发者直接使用 ECMAScript 可以操作的。其实就是我们常说的Undefined, Null, Boolean, String, Number, 和 Object。\n\n规范类型相当于 meta-values，是用来用算法描述 ECMAScript 语言结构和 ECMAScript 语言类型的。规范类型包括：Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, 和 Environment Record。\n\n\n引用类型用来说明 delete，typeof，赋值运算符这些运算符的行为，但并不存在于实际的 js 代码中。Reference 的构成，由三个组成部分，分别是：\n\nbase value：引用所在的对象或者就是 EnvironmentRecord，它的值只可能是 undefined, an Object, a Boolean, a String, a Number, or an environment record 其中的一种。\nreferenced name：引用的名称\nstrict reference：标识是否严格引用\n\n引用类型的值只有两种情况：\n\n  标示符：标识符是变量名，函数名，函数参数名和全局对象中未识别的属性名。\n\nvar foo = 10;function bar() &#123;&#125;var fooReference = &#123;  base: global,  referencedName: &#x27;foo&#x27;,  strict reference:false&#125;; var barReference = &#123;  base: global,  referencedName: &#x27;bar&#x27;,  strict reference:false&#125;;\n\n\n  属性访问器：有两种变体，点（.）语法（此时属性名是正确的标示符，且事先知道），或括号语法（[]）。\n\nfoo.bar();foo[&#x27;bar&#x27;]();var fooBarReference = &#123;  base: foo,  referencedName: &#x27;bar&#x27;,  strict reference:false&#125;; GetValue(fooBarReference); // function object &quot;bar&quot; 从 Reference 类型获取对应值的方法： GetValue\n\n引用类型与函数上下文中的this值如何相关？一个函数上下文中确定this值的通用规则如下：\n在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用括号()的左边是引用类型的值，this将设为引用类型值的base value，在其他情况下（与引用类型不同的任何其它属性），this被设置为undefined。举例：\nvar value = 1;var foo = &#123;  value: 2,  bar: function () &#123;    return this.value;  &#125;&#125;//示例1console.log(foo.bar());//2//示例2 ()返回执行Expression的结果，它可能是Reference类型。console.log((foo.bar)());//2//示例3 = 令rval（右侧表达式）为GetValue(rref)，返回rval 不是Reference类型。console.log((foo.bar = foo.bar)());//underfined//示例4 || 返回 GetValue(rref)不是Reference类型。console.log((false || foo.bar)());//underfined//示例5console.log((foo.bar, foo.bar)());//underfined\n\n6 执行上下文总结结合着所有内容，讲讲执行上下文的具体处理过程。\n提出这样一道思考题：\nvar scope = &quot;global scope&quot;;function checkscope()&#123;    var scope = &quot;local scope&quot;;    function f()&#123;        return scope;    &#125;    return f();&#125;checkscope();var scope = &quot;global scope&quot;;function checkscope()&#123;    var scope = &quot;local scope&quot;;    function f()&#123;        return scope;    &#125;    return f;&#125;checkscope()();\n\n两段代码都会打印’local scope’。虽然两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？\n6.1 第一段代码我们分析第一段代码：\nvar scope = &quot;global scope&quot;;function checkscope()&#123;    var scope = &quot;local scope&quot;;    function f()&#123;        return scope;    &#125;    return f();&#125;checkscope();\n\n执行过程如下：\n\n创建全局执行上下文，全局上下文被压入执行上下文栈\n ECStack = [    globalContext];\n全局上下文初始化\n globalContext = &#123;    VO: [global],    Scope: [globalContext.VO],    this: globalContext.VO&#125;\n初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]]\n checkscope.[[scope]] = [  globalContext.VO];\n执行全局代码，执行到 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈\n ECStack = [    checkscopeContext,    globalContext];\n进入上下文，checkscope 函数执行上下文初始化：\n\n复制函数 [[scope]] 属性创建作用域链，\n用 arguments 创建活动对象，\n初始化活动对象，即加入形参、函数声明、变量声明，\n将活动对象压入 checkscope 作用域链顶端。\n\n 同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]\n checkscopeContext = &#123;    AO: &#123;        arguments: &#123;            length: 0        &#125;,        scope: undefined,        f: reference to function f()&#123;&#125;    &#125;,    Scope: [AO, globalContext.VO],    this: undefined&#125;f.[[scope]] =[\tcheckscopeContext.AO,\tglobalContext.VO]\n创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈\n ECStack = [    fContext,    checkscopeContext,    globalContext];\nf 函数执行上下文初始化, 以下跟第 5 步相同：\n\n复制函数 [[scope]] 属性创建作用域链\n用 arguments 创建活动对象\n初始化活动对象，即加入形参、函数声明、变量声明\n将活动对象压入 f 作用域链顶端\n\n fContext = &#123;    AO: &#123;        arguments: &#123;            length: 0        &#125;    &#125;,    Scope: [AO, checkscopeContext.AO, globalContext.VO],    this: undefined&#125;\nf 函数执行，沿着作用域链查找 scope 值，返回 scope 值\n\nf 函数执行完毕，f 函数上下文从执行上下文栈中弹出\n ECStack = [    checkscopeContext,    globalContext];\ncheckscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出\nECStack = [    globalContext];\n\n6.2 第二段代码第二段代码类似，区别在于checkscpoe函数返回的不是f函数运行的结果而是f函数自身。\nvar scope = &quot;global scope&quot;;function checkscope()&#123;    var scope = &quot;local scope&quot;;    function f()&#123;        return scope;    &#125;    return f;&#125;checkscope()();\n\n\n创建全局执行上下文，全局上下文被压入执行上下文栈\n ECStack = [    globalContext];\n全局上下文初始化\n globalContext = &#123;    VO: [global],    Scope: [globalContext.VO],    this: globalContext.VO&#125;\n初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]]\n checkscope.[[scope]] = [  globalContext.VO];\n执行全局代码，执行到 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈\n ECStack = [    checkscopeContext,    globalContext];\ncheckscope 函数执行上下文初始化：\n\n复制函数 [[scope]] 属性创建作用域链，\n用 arguments 创建活动对象，\n初始化活动对象，即加入形参、函数声明、变量声明，\n将活动对象压入 checkscope 作用域链顶端。\n\n checkscopeContext = &#123;    AO: &#123;        arguments: &#123;            length: 0        &#125;,        scope: undefined,        f: reference to function f()&#123;&#125;    &#125;,    Scope: [AO, globalContext.VO],    this: undefined&#125;\ncheckscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出，返回f函数。\n ECStack = [      globalContext  ];\n创建f函数，保存作用域链到函数的内部属性[[scope]]，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈\n f.[[scope]] =[\tcheckscopeContext.AO,\tglobalContext.VO]ECStack = [    fContext,    globalContext];\nf 函数执行上下文初始化, 以下跟第 4 步相同：\n\n复制函数 [[scope]] 属性创建作用域链\n用 arguments 创建活动对象\n初始化活动对象，即加入形参、函数声明、变量声明\n将活动对象压入 f 作用域链顶端\n\n fContext = &#123;    AO: &#123;        arguments: &#123;            length: 0        &#125;    &#125;,    Scope: [AO, checkscopeContext.AO, globalContext.VO],    this: undefined&#125;\nf 函数执行，沿着作用域链查找 scope 值，返回 scope 值\n\nf 函数执行完毕，f 函数上下文从执行上下文栈中弹出\nECStack = [    globalContext];\n\n参考【1】JavaScript高级程序设计（第四版）\n【2】JavaScript深入之执行上下文栈 · Issue #4 · mqyqingfeng/Blog (github.com)\n【3】JavaScript深入之变量对象 · Issue #5 · mqyqingfeng/Blog (github.com)\n【4】JavaScript深入之从ECMAScript规范解读this · Issue #7 · mqyqingfeng/Blog (github.com)\n【5】深入理解JavaScript系列（13）：This? Yes,this! - 汤姆大叔 - 博客园 (cnblogs.com)\n【6】彻底理解js的执行上下文，以及变量对象 - 简书 (jianshu.com)\n","categories":["JavaScript"],"tags":["JavaScript","前端"]},{"title":"实验：决策树完成鸢尾花卉品种预测","url":"/2022/01/10/%E5%AE%9E%E9%AA%8C%EF%BC%9A%E5%86%B3%E7%AD%96%E6%A0%91%E5%AE%8C%E6%88%90%E9%B8%A2%E5%B0%BE%E8%8A%B1%E5%8D%89%E5%93%81%E7%A7%8D%E9%A2%84%E6%B5%8B/","content":"[TOC]\n实验要求本实验通过鸢尾花数据集iris.csv来实现对决策树进一步的了解。其中， Iris鸢尾花数据集是一个经典数据集，在统计学习和机器学习领域都经常被用作示例。数据集内包含3类共150条记录，每类各50个数据，每条记录都有4项特征：花萼长度、花萼宽度、花瓣长度、花瓣宽度，可以通过这4个特征预测鸢尾花卉属于iris-setosa, iris-versicolour, iris-virginica三个类别中的 哪一品种。Iris数据集样例如下图所示：\n\n\n本实验将五分之四的数据集作为训练集对决策树模型进行训练；将剩余五 分之一的数据集作为测试集，采用训练好的决策树模型对其进行预测。训练集 与测试集的数据随机选取。本实验采用准确率(accuracy)作为模型的评估函数：预测结果正确的数量占样本总数，(TP+TN)/(TP+TN+FP+FN)。\n【实验要求】  \n\n本实验要求输出测试集各样本的预测标签和真实标签，并计算模型准确率。(选做)另外，给出 3 个可视化预测结果。 \n\n决策树算法可以分别尝试 ID3,C4.5,cart树，并评判效果。 \n\n（选做）：对你的决策树模型进行预剪枝与后剪枝 \n\n（选做）：分别做 c4.5 和 cart 树的剪枝并比较不同。\n\n\n实验思路分析数据结构，因为没有每个样本独有的属性（例如学生ID），决定采用ID3决策树（ID3决策树的信息增益偏向于可能值较多的属性）。采用信息增益Information Gain确定划分的最优特征，对于保存树的结构方面，采用字典的形式保存，以下方字典形式为例：\n{    \"PetalWidth\": {        \"0\": \"Iris-setosa\",        \"1\": {            \"PetalLength\": {                \"0\": \"Iris-setosa\",                \"1\": \"Iris-versicolor\",                \"2\": {                    \"SepalLength\": {                        \"1\": \"Iris-virginica\",                        \"2\": \"Iris-versicolor\"                    }                }            }        },        \"2\": {            \"SepalLength\": {                \"0\": \"Iris-virginica\",                \"1\": \"Iris-virginica\",                \"2\": {                    \"SepalWidth\": {                        \"0\": \"Iris-virginica\",                        \"1\": \"Iris-virginica\"                    }                }            }        }    }}\n\n由于数据是连续的，在训练决策树之前需要将其离散化，利用python中seaborn库观察数据分布：\nimport pandas as pdimport matplotlib.pyplot as pltimport seaborn as sbData = pd.read_csv('iris.csv')sb.pairplot(Data.dropna(), hue='Species')plt.show()\n\n\n\n因此我们确定数据的离散边界：\n\n\n\n离散特征\\离散后的值\n0\n1\n2\n\n\n\nSepalLength\n0-5.5\n5.5-6.3\n6.3-inf\n\n\nSepalWidth\n0.3.2\n3.2-inf\n\n\n\nPetalLength\n0-2\n2-4.9\n4.9-inf\n\n\nPetalWidth\n0-0.6\n0.6-1.7\n1.7-inf\n\n\n为了保证结果的随机性，训练集与测试集的划分采用随机采样，每种花随机抽取10个共30个测试集样本，其余为训练集样本：\n# 分割训练集与测试集def split_train_test(data:pd.DataFrame):    # 随机采样    test_index = random.sample(range(50),10)    test_index.extend(random.sample(range(50,100),10))    test_index.extend(random.sample(range(100,150),10))    print(test_index)    testSet = data.iloc[test_index]    train_index = list(range(150))    for index in test_index:        train_index.remove(index)    # 划分训练集    trainSet = data.iloc[train_index]    return trainSet,testSet\n\n实验代码\nsplit_train_test：分割训练集与测试集\nShannonEntropy：计算一个Dataframe关于forecast_label列的信息熵\nInformationGain：计算一个Dataframe中label标签关于forecast_label的信息增益\ncreateTree：递归生成决策树的过程\ndecision：对一个样本进行决策\n\nimport pandas as pdimport numpy as npimport matplotlib.pyplot as pltimport seaborn as sbimport jsonimport randomdef split_train_test(data:pd.DataFrame):    \"\"\"    分割训练集与测试集    :param data: 总的数据集    :return: 返回训练集与测试集    \"\"\"    # 随机采样    test_index = random.sample(range(50),10)    test_index.extend(random.sample(range(50,100),10))    test_index.extend(random.sample(range(100,150),10))    print(test_index)    testSet = data.iloc[test_index]    train_index = list(range(150))    for index in test_index:        train_index.remove(index)    # 划分训练集    trainSet = data.iloc[train_index]    return trainSet,testSetdef ShannonEntropy(data:pd.DataFrame,forecast_label:str)-&gt;float:    \"\"\"    计算一个数据集关于某个标签(这里是预测标签)的信息熵    :param data: 数据集    :param forecast_label: 预测标签    :return: 返回这个数据集的信息熵    \"\"\"    total = data.shape[0]    kinds = data[forecast_label].value_counts()    Entropy = 0.0    # 对于每种预测标签 计算pk*log(pk)    for i in range(kinds.shape[0]):        # 计算每种预测标签的比例        prior_probability = kinds[i]/total        # 计算信息熵        Entropy += (prior_probability * np.log2(prior_probability))    return -Entropydef InformationGain(data:pd.DataFrame,label:str,forecast_label:str)-&gt;float:    \"\"\"    计算label标签关于forecast_label的信息增益    :param data: 数据集    :param label: 计算标签    :param forecast_label: 预测标签    :return: 信息增益    \"\"\"    # 计算总的信息熵Entropy(S)    total_entropy = ShannonEntropy(data,forecast_label)    # 初始化信息增益    gain = total_entropy    # 按照计算标签分组    sub_frame = data[[label,'Species']]    group = sub_frame.groupby(label)    # 计算信息增益    for key, df in group:        gain -= (df.shape[0]/data.shape[0]) * ShannonEntropy(df,'Species')    return gaindef createTree(data:pd.DataFrame)-&gt;dict:    \"\"\"    递归的创建决策树    :param data: 训练集数据    :return: 返回一个字典表示决策树    \"\"\"    # 该分支下的实例只有一种分类    if len(data['Species'].value_counts()) == 1:        return data['Species'].iloc[0]    # 初始化最优信息增益与最优属性    bestGain = 0    bestFeature = -1    # 对于每种属性计算信息增益，选出信息增益最大的一列    for column in data:        if column != 'Species':            gain = InformationGain(data, column, 'Species')            if bestGain &lt; gain:                bestGain = gain                bestFeature = column    # 数据集中所有数据都相同，但种类不同，返回最多数量的种类    if bestFeature == -1:        valueCount = data['Species'].value_counts()        return valueCount.index[0]    # 初始化一个字典    myTree = {bestFeature: {}}    # 统计出最佳属性的所有可能取值    valueList = set(data[bestFeature])    for value in valueList:        # 递归的构造子树        myTree[bestFeature][value] = createTree(data[data[bestFeature] == value])    return myTreedef decision(tree:dict,testVector:pd.Series):    \"\"\"    预测一个测试集样本的类别    :param tree: 生成的决策树    :param testVector: 测试数据向量    :return: 返回预测标签    \"\"\"    # 初始化预测标签    forecastLabel = 0    # 获取当前决策树第一个节点属性    firstFeature = next(iter(tree))    # 获取子树    childTree = tree[firstFeature]    # 对子树中不同的可能值检测是否相等    for key in childTree.keys():        # 满足条件深入到下一层        if testVector[firstFeature] == key:            # 下一层是分支节点            if type(childTree[key]) == dict :                forecastLabel = decision(childTree[key],testVector)            # 下一层是叶节点            else:                forecastLabel = childTree[key]    return forecastLabelif __name__ == '__main__' :    Data = pd.read_csv('iris.csv')    # 画出统计分布图，统计每种类别的特征    # sb.pairplot(Data.dropna(), hue='Species')    # plt.show()    # 数据离散化处理    Data['SepalLength'] = np.digitize(Data['SepalLength'],bins=[5.5,6.3])    Data['SepalWidth'] = np.digitize(Data['SepalWidth'],bins=[3.2])    Data['PetalLength'] = np.digitize(Data['PetalLength'],bins=[2,4.9])    Data['PetalWidth'] = np.digitize(Data['PetalWidth'],bins=[0.6,1.7])    # 数据离散化的字典    discrete_dict = {        'SepalLength' : {'0-5.5':0,'5.5-6.3':1,'6.3-inf':2},        'SepalWidth' : {'0.3.2':0,'3.2-inf':1},        'PetalLength' : {'0-2':0,'2-4.9':1,'4.9-inf':2},        'PetalWidth' : {'0-0.6':0,'0.6-1.7':1,'1.7-inf':2}    }    print('数据离散化字典：')    print(json.dumps(discrete_dict, indent=4))    # 分出训练集与测试集    train_set,test_set = split_train_test(Data)    # 训练出决策树    tree = createTree(train_set)    print(\"决策树字典表示：\")    print(json.dumps(tree, indent=4, sort_keys=True))    # 初始化统计参数    T = 0    N = 0    for i in range(test_set.shape[0]):        print('================================================')        vector = test_set.iloc[i, :-1]        sl = vector['SepalLength']        sw = vector['SepalWidth']        pl = vector['PetalLength']        pw = vector['PetalWidth']        trueLabel = test_set.iloc[i]['Species']        print(f'离散化后的测试数据:SepalLength={sl},SepalWidth={sw},PetalLength={pl},PetalWidth={pw},真实标签={trueLabel}')        forecastLabel= decision(tree,vector)        if forecastLabel == trueLabel:            T+=1            print(f'预测为{forecastLabel},预测正确')        else:            N+=1            print(f'预测为{forecastLabel},预测错误')    print('-------------------------------------------------------------')    print(f'决策树预测准确率为:'+str(T/(T+N)))\n\n实验结果与分析运行程序后的控制台输出：\n数据离散化字典：{    \"SepalLength\": {        \"0-5.5\": 0,        \"5.5-6.3\": 1,        \"6.3-inf\": 2    },    \"SepalWidth\": {        \"0.3.2\": 0,        \"3.2-inf\": 1    },    \"PetalLength\": {        \"0-2\": 0,        \"2-4.9\": 1,        \"4.9-inf\": 2    },    \"PetalWidth\": {        \"0-0.6\": 0,        \"0.6-1.7\": 1,        \"1.7-inf\": 2    }}随机训练集index: [38, 28, 26, 44, 40, 19, 2, 18, 7, 46, 68, 79, 50, 97, 65, 88, 69, 81, 92, 95, 126, 132, 137, 131, 110, 124, 133, 116, 125, 143]决策树字典表示：{    \"PetalLength\": {        \"0\": \"Iris-setosa\",        \"1\": {            \"PetalWidth\": {                \"1\": \"Iris-versicolor\",                \"2\": {                    \"SepalWidth\": {                        \"0\": \"Iris-virginica\",                        \"1\": \"Iris-versicolor\"                    }                }            }        },        \"2\": {            \"PetalWidth\": {                \"1\": {                    \"SepalLength\": {                        \"1\": \"Iris-virginica\",                        \"2\": \"Iris-versicolor\"                    }                },                \"2\": {                    \"SepalLength\": {                        \"1\": \"Iris-virginica\",                        \"2\": {                            \"SepalWidth\": {                                \"0\": \"Iris-virginica\",                                \"1\": \"Iris-virginica\"                            }                        }                    }                }            }        }    }}================================================离散化后的测试数据:SepalLength=0,SepalWidth=0,PetalLength=0,PetalWidth=0,真实标签=Iris-setosa预测为Iris-setosa,预测正确================================================离散化后的测试数据:SepalLength=0,SepalWidth=1,PetalLength=0,PetalWidth=0,真实标签=Iris-setosa预测为Iris-setosa,预测正确================================================离散化后的测试数据:SepalLength=0,SepalWidth=1,PetalLength=0,PetalWidth=0,真实标签=Iris-setosa预测为Iris-setosa,预测正确================================================离散化后的测试数据:SepalLength=0,SepalWidth=1,PetalLength=0,PetalWidth=0,真实标签=Iris-setosa预测为Iris-setosa,预测正确================================================离散化后的测试数据:SepalLength=0,SepalWidth=1,PetalLength=0,PetalWidth=0,真实标签=Iris-setosa预测为Iris-setosa,预测正确================================================离散化后的测试数据:SepalLength=0,SepalWidth=1,PetalLength=0,PetalWidth=0,真实标签=Iris-setosa预测为Iris-setosa,预测正确================================================离散化后的测试数据:SepalLength=0,SepalWidth=1,PetalLength=0,PetalWidth=0,真实标签=Iris-setosa预测为Iris-setosa,预测正确================================================离散化后的测试数据:SepalLength=1,SepalWidth=1,PetalLength=0,PetalWidth=0,真实标签=Iris-setosa预测为Iris-setosa,预测正确================================================离散化后的测试数据:SepalLength=0,SepalWidth=1,PetalLength=0,PetalWidth=0,真实标签=Iris-setosa预测为Iris-setosa,预测正确================================================离散化后的测试数据:SepalLength=0,SepalWidth=1,PetalLength=0,PetalWidth=0,真实标签=Iris-setosa预测为Iris-setosa,预测正确================================================离散化后的测试数据:SepalLength=1,SepalWidth=0,PetalLength=1,PetalWidth=1,真实标签=Iris-versicolor预测为Iris-versicolor,预测正确================================================离散化后的测试数据:SepalLength=1,SepalWidth=0,PetalLength=1,PetalWidth=1,真实标签=Iris-versicolor预测为Iris-versicolor,预测正确================================================离散化后的测试数据:SepalLength=2,SepalWidth=1,PetalLength=1,PetalWidth=1,真实标签=Iris-versicolor预测为Iris-versicolor,预测正确================================================离散化后的测试数据:SepalLength=1,SepalWidth=0,PetalLength=1,PetalWidth=1,真实标签=Iris-versicolor预测为Iris-versicolor,预测正确================================================离散化后的测试数据:SepalLength=2,SepalWidth=0,PetalLength=1,PetalWidth=1,真实标签=Iris-versicolor预测为Iris-versicolor,预测正确================================================离散化后的测试数据:SepalLength=1,SepalWidth=0,PetalLength=1,PetalWidth=1,真实标签=Iris-versicolor预测为Iris-versicolor,预测正确================================================离散化后的测试数据:SepalLength=1,SepalWidth=0,PetalLength=1,PetalWidth=1,真实标签=Iris-versicolor预测为Iris-versicolor,预测正确================================================离散化后的测试数据:SepalLength=1,SepalWidth=0,PetalLength=1,PetalWidth=1,真实标签=Iris-versicolor预测为Iris-versicolor,预测正确================================================离散化后的测试数据:SepalLength=1,SepalWidth=0,PetalLength=1,PetalWidth=1,真实标签=Iris-versicolor预测为Iris-versicolor,预测正确================================================离散化后的测试数据:SepalLength=1,SepalWidth=0,PetalLength=1,PetalWidth=1,真实标签=Iris-versicolor预测为Iris-versicolor,预测正确================================================离散化后的测试数据:SepalLength=1,SepalWidth=0,PetalLength=1,PetalWidth=2,真实标签=Iris-virginica预测为Iris-virginica,预测正确================================================离散化后的测试数据:SepalLength=2,SepalWidth=0,PetalLength=2,PetalWidth=2,真实标签=Iris-virginica预测为Iris-virginica,预测正确================================================离散化后的测试数据:SepalLength=2,SepalWidth=0,PetalLength=2,PetalWidth=2,真实标签=Iris-virginica预测为Iris-virginica,预测正确================================================离散化后的测试数据:SepalLength=2,SepalWidth=1,PetalLength=2,PetalWidth=2,真实标签=Iris-virginica预测为Iris-virginica,预测正确================================================离散化后的测试数据:SepalLength=2,SepalWidth=1,PetalLength=2,PetalWidth=2,真实标签=Iris-virginica预测为Iris-virginica,预测正确================================================离散化后的测试数据:SepalLength=2,SepalWidth=1,PetalLength=2,PetalWidth=2,真实标签=Iris-virginica预测为Iris-virginica,预测正确================================================离散化后的测试数据:SepalLength=2,SepalWidth=0,PetalLength=2,PetalWidth=1,真实标签=Iris-virginica预测为Iris-versicolor,预测错误================================================离散化后的测试数据:SepalLength=2,SepalWidth=0,PetalLength=2,PetalWidth=2,真实标签=Iris-virginica预测为Iris-virginica,预测正确================================================离散化后的测试数据:SepalLength=2,SepalWidth=1,PetalLength=2,PetalWidth=2,真实标签=Iris-virginica预测为Iris-virginica,预测正确================================================离散化后的测试数据:SepalLength=2,SepalWidth=1,PetalLength=2,PetalWidth=2,真实标签=Iris-virginica预测为Iris-virginica,预测正确-------------------------------------------------------------决策树预测准确率为:0.9666666666666667\n\n观察决策树的结构，SepalWidth=0或SepalWidth=1时的决策结果相同，可以通过剪枝的操作减去多余的子树。同时对数据的分布进行分析，SepalWidth与SepalLength的数据重合部分大，对这两个数据进行预剪枝的效果可能更好。\n参考【1】机器学习实战\n【2】机器学习项目实战–基于鸢尾花数据集（python代码，多种算法对比：决策树、SVM、k近邻）_西南交大-Liu_z的博客-CSDN博客\n","categories":["机器学习"],"tags":["机器学习","python"]},{"title":"实验：神经网络预测Fashion—MNIST数据集","url":"/2022/01/10/%E5%AE%9E%E9%AA%8C%EF%BC%9A%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E9%A2%84%E6%B5%8BFashion%E2%80%94MNIST%E6%95%B0%E6%8D%AE%E9%9B%86/","content":"实验数据Fashion-MNIST数据集，数据集中包含 60000 张训练样本，10000 张测试 样本，可将训练样本划分为49000 张样本的训练集和1000 张样本的验证集，测 试集可只取1000 张测试样本。其中每个样本都是 28×28 像素的灰度照片，每 个像素点包括RGB三个数值，数值范围0 ~ 255，所有照片分属10个不同的类别。\n\n\n灰度与像素值的关系：\n\n图像的灰度化： 灰度就是没有色彩，RGB色彩分量全部相等。图像的灰度化就是让像素点矩阵中的每一个像素点都满足关系：R=G=B，此时的这个值叫做灰度值。如RGB(100,100,100)就代表灰度值为100,RGB(50,50,50)代表灰度值为50。\n\n灰度值与像素值的关系： 如果对于一张本身就是灰度图像（8位灰度图像）来说，他的像素值就是它的灰度值，如果是一张彩色图像，则它的灰度值需要经过函数映射来得到。灰度图像是由纯黑和纯白来过渡得到的，在黑色中加入白色就得到灰色，纯黑和纯白按不同的比例来混合就得到不同的灰度值。R=G=B=255为白色，R=G=B=0为黑色，R=G=B=小于255的某个整数时，此时就为某个灰度值。\n\n\n实验要求\n用神经网络对给定的数据集进行分类，画出loss图，给出在测试集上的精确度；\n\n不能使用 pytorch 等框架，也不能使用库函数，所有算法都要自己实现\n\n神经网络结构图如下图所示：\n \n整个神经网络包括 3 层——输入层，隐藏层，输出层。输入层有28x28x3个神经元，隐藏层有 50个神经元，输出层有 10 个神经元（对应 10 个类别）。\n\n附加：可以试着修改隐藏层神经元数，层数，学习率，正则化权重等参数探究参数对实验结果的影响\n\n\n实验思路与代码实验要求设计一个三层的全连接神经网络，实现分类的功能。实验原理请见我的博客：神经网络基础与反向传播_Sunburst7的博客-CSDN博客\n神经网络的每次迭代主要包括以下几个步骤：\n\n传入训练图片灰度矩阵/数组\n进行前馈运算，计算出输出层10个神经元预测的标签\n与期望的标签计算Loss，更新隐含层（Hidden）到输出层（Output）的权值\n计算隐含层的敏感度，更新输入层（Input）到隐含层的权值\n传入测试图片灰度矩阵，进行预测。\n统计\n\n起初我的设计充满了面向对象的思想，导致在进行大数据集的运算时消耗时间很长，无法训练神经网络，受到参考【2】【3】【4】中博客的启发，改变思路，采用矩阵运算的思想成功训练出一个良好的神经网络。\n初始的设想我准备编写一个神经元类表示单个神经元，该神经元有以下属性，手绘原理图：\n\n\n\n权值数组Weights：上一层与该神经元相连的所有神经元的权值\n\n偏置Bias\n\n输入值数组Inputs与输出值Output\n\n激活函数\n\n敏感度：定义可见实验原理博客\n\n神经元类型Type：标识是输入层还是输出层还是隐含层神经元\n\n\n每个神经元有两个函数，分别代表前馈与反向传播。\n\n前馈：将输入值与权值进行向量的内积，加上偏置，在传入激活函数，输出最后的值\n反向传播：对于输入层与输出层不同，利用传入的敏感度数组与权值数组更新自身的权值矩阵。\n\nimport numpy as npdef sigmoid(x):    if x&gt;=0:      #对sigmoid函数的优化，避免了出现极大的数据溢出        return 1.0/(1+np.exp(-x))    else:        return np.exp(x)/(1+np.exp(x))class Neuron:    def __init__(self, weights, bias, ntype):        # 上一层与之相连的weights array        self.weights = weights        # 偏置 bias        self.bias = bias        # input array        self.inputs = 0        # 总的输出 z_k        self.output = 0        # 一个神经元的敏感度        self.sensitivity = 0.0        # 神经元的类型:Input Hidden Output        self.ntype = ntype    def __str__(self):        return \"weights: \\n\"+str(self.weights)+\"\\nbias:\\n\"+str(self.bias)+\"\\ninputs:\\n\"+str(self.inputs)+\"\\noutput:\\n\"+str(self.output)+\"\\nsensitivity\\n\"+str(self.sensitivity)+\"\\ntype:\\n\"+str(self.ntype)    def feedForward(self, inputs:np.array):        \"\"\"        前馈        :param inputs: 输入的向量        :return:        \"\"\"        self.inputs = inputs        # weight inputs, add bias, then use the activation function        total = np.dot(self.weights, self.inputs) + self.bias        # 计算神经元的输出        # 如果是输入层，不需要带入激活函数f        if self.ntype == 'Input':            self.output = total        else:            self.output = sigmoid(total)        return self.output    def backPropagation(self ,eta ,tk ,sensitivities ,weights):        \"\"\"        反向传递更新权值        :param eta: 学习率        :param tk: 真实标签        :param sensitivities: 该神经元如果不是输出层，隐含层下一层所有神经元的敏感度        :param weights: 该神经元如果不是输出层，与该神经元相连的下一层的所有权值        :return:        \"\"\"        if self.ntype == 'Output':            # 计算f'(net)=f(net)*(1-f(net))            derivative_f = self.output*(1-self.output)            # 计算loss'(zk)=-(tk-zk)            derivative_loss = -(tk - self.output)            # 计算该神经元的敏感度 sensitivity = -f'(net)*loss'(zk)            self.sensitivity = -derivative_f*derivative_loss            # 更新权重            self.weights = self.weights + eta*self.sensitivity*np.array(self.inputs)        elif self.ntype == 'Hidden':            # 计算f'(net)=f(net)*(1-f(net))            derivative_f = self.output * (1 - self.output)            # 计算隐含层单元的敏感度 sensitivity = f'(net)*&lt;下一层所有神经元的敏感度，该神经元与下一层相连的权重&gt;            self.sensitivity = derivative_f*np.dot(sensitivities,weights)            # 更新权重            self.weights = self.weights + eta*self.sensitivity*np.array(self.inputs)        else:            return\n\n再编写一个神经网络类构造三层神经元并进行feedForward与backPropagation的参数传递工作：\nimport numpy as npimport osimport gzipfrom exp4.Neuron1 import Neurondef sigmoid(x):    if x&gt;=0:      #对sigmoid函数的优化，避免了出现极大的数据溢出        return 1.0/(1+np.exp(-x))    else:        return np.exp(x)/(1+np.exp(x))# 定义加载数据的函数，加载4个zip格式文件def load_data(data_folder):  files = [      'train-labels-idx1-ubyte.gz', 'train-images-idx3-ubyte.gz',      't10k-labels-idx1-ubyte.gz', 't10k-images-idx3-ubyte.gz'  ]  paths = []  for fname in files:    paths.append(os.path.join(data_folder,fname))  with gzip.open(paths[0], 'rb') as lbpath:    y_train = np.frombuffer(lbpath.read(), np.uint8, offset=8)  with gzip.open(paths[1], 'rb') as imgpath:    x_train = np.frombuffer(        imgpath.read(), np.uint8, offset=16).reshape(len(y_train), 28, 28)  with gzip.open(paths[2], 'rb') as lbpath:    y_test = np.frombuffer(lbpath.read(), np.uint8, offset=8)  with gzip.open(paths[3], 'rb') as imgpath:    x_test = np.frombuffer(        imgpath.read(), np.uint8, offset=16).reshape(len(y_test), 28, 28)  return (x_train, y_train), (x_test, y_test)def makeTrueLabels(trueLabel):    \"\"\"    生成传递给输出层的期望标签数组    :param trueLabel:    :return:    \"\"\"    labels = []    for i in range(10):        if trueLabel == i:            labels.append(1)        else:            labels.append(0)    return labelsclass NeuronNetwork:    def __init__(self,train_images,train_labels,test_images,test_labels):        self.inputLayer = []        self.hiddenLayer = []        self.outputLayer = []        self.train_images = train_images        self.train_labels = train_labels        self.test_images = test_images        self.test_labels = test_labels        # 从输入层到隐含层权值的初始化        initWeight_1 = np.random.uniform(-1/np.sqrt(784),1/np.sqrt(784),(50,784))        # 从隐含层到输出层权值的初始化        initWeight_2 = np.random.uniform(-1/np.sqrt(50),1/np.sqrt(50),(10,50))        # 偏置初始化        bias = np.random.normal(0,0.5,2)        # 初始化输入层        for i in range(784):            neuron = Neuron(1,0,ntype='Input')            self.inputLayer.append(neuron)        # 初始化隐藏层        for i in range(50):            neuron = Neuron(initWeight_1[i],bias[0],ntype='Hidden')            self.hiddenLayer.append(neuron)        # 初始化输出层        for i in range(10):            neuron = Neuron(initWeight_2[i],bias[1],ntype='Output')            self.outputLayer.append(neuron)    def iteration(self):        T = 0        N = 0        # 依次将60000章图片训练一边        for m in range(self.train_images.shape[0]):            # 输入层(784个神经元)的输出            y_i = []            # 对于每张图片的784个像素点            for row in range(self.train_images.shape[1]):                for col in range(self.train_images.shape[2]):                    y_i.append(                        self.inputLayer[28 * row + col].feedForward(inputs=np.array(train_images[m][row][col]))                    )            # 隐藏层(50个神经元)的输出            y_h = []            for hidden_neuron in self.hiddenLayer:                y_h.append(hidden_neuron.feedForward(y_i))            # 输出层的标签：预测标签            y_o = []            for output_neuron in self.outputLayer:                y_o.append(output_neuron.feedForward(y_h))            # 进行预测，统计预测正误            forecastLabel = y_o.index(np.array(y_o).max())            if forecastLabel == train_labels[m]:                T+=1            else:                N+=1            # 期望值数组            trueLabels = makeTrueLabels(trueLabel=forecastLabel)            # 对输出层进行反向传播            output_sensitivities = [] # 输出层所有节点的敏感度            output_weights = [] # 输出层所有节点的权重            for i in range(10):                self.outputLayer[i].backPropagation(eta=0.1,tk=trueLabels[i],sensitivities=None,weights=None)                # 保存更新过的敏感度                output_sensitivities.append(self.outputLayer[i].sensitivity)                output_weights.append(self.outputLayer[i].weights)            # 对隐含层进行反向传播            for i in range(50):                # 隐含层每个神经元连接的10个输出层神经元的权值                linkedWeights = [arr[i] for arr in output_weights]                self.hiddenLayer[i].backPropagation(eta=0.1,tk=None,sensitivities=output_sensitivities,weights=linkedWeights)        return T, N# 传入数据集(train_images, train_labels), (test_images, test_labels) = load_data('')train_images = train_images[0:500:1]train_labels = train_labels[0:500:1]\"\"\"    定义统计信息：\"\"\"n = 100positive = []negative = []nn = NeuronNetwork(train_images=train_images,train_labels=train_labels,test_images=test_images,test_labels=test_labels)for k in range(100):    T,N = nn.iteration()    positive.append(T)    negative.append(N)\n\n该神经网络只能运行在少量的样本上，不能满足需要\n\n\n改进思路：矩阵运算之前思路中更新的过程太慢，每次都要一张一张图片传入，同时大量的对象也拖慢了运算的速度，因此我取消了神经元类，而在神经网络中保存两个矩阵，分别代表从输入层到隐含层与从隐含层到输出层的权值。\n\n\n神经网络类通过输入层节点数、隐含层节点数、输出层节点数、学习率进行初始化，同时初始化两个权值矩阵以及一个偏置数组。\n# 制作一个神经网络算法的类，其名为神经网络，相当于函数库，直接进行调用里面的函数即可。class NeuralNetwork:    def __init__(self,inputNeurons,hiddenNeurons,outputNeurons,lr):        \"\"\"        神经网络构造方法        :param inputNeurons:输入层神经元个数        :param hiddenNeurons:隐含层神经元个数        :param outputNeurons:输出层神经元个数        :param lr:学习率        \"\"\"        self.iNeuron_num = inputNeurons        self.hNeuron_num = hiddenNeurons        self.oNeuron_num = outputNeurons        self.learnRate = lr # 学习率        self.f = lambda x: ssp.expit(x) # 设置激活函数f为Sigmod(x)激活函数        # 设置输入层与隐藏层直接的权重关系矩阵以及隐藏层与输出层之间的权重关系矩阵,初始值为正态分布        self.weights_i_h = np.random.normal(0.0, 1/np.sqrt(hiddenNeurons), (self.hNeuron_num, self.iNeuron_num))        self.weights_h_o = np.random.normal(0.0, 1/np.sqrt(hiddenNeurons), (self.oNeuron_num, self.hNeuron_num))        # 偏置初始化        self.bias = np.random.normal(0, 0.5, 2)\n\n对输入的图片与标签进行两步处理：\n\n归一化\n\n对于图片将所有的灰度(0-255)全部映射到(0.01-0.99)上\n对于每一个表示分类结果的标签(0-9)重新构造一个长度为10的数组，下标对应每个标签，若真实分类标签为8，则数组[7] = 0.99，其他位置的值为0.01，近似表示该图片真实标签的概率。\n\n  # 对60000张图片进行遍历for i in range(60000):    # 测试集的28*28矩阵转化为784的一维数组    img = train_images[i].reshape(train_images.shape[1]*train_images.shape[2])    # 进行归一化：除以255，再乘以0.99，最后加上0。01，保证所有的数据都在0.01到1.00之间    train_matrix[:,i] = (img/255.0)*0.99+0.01    # 建立准确输出结果矩阵，对应的位置标签数值为0.99，其他位置为0.01    # 第i张图片代表第i列，行数代表正确的标签    train_labels_matrix[train_labels[i],i] = 0.99    # 对10000章测试集图片进行处理for i in range(10000):    # 训练集的28*28矩阵转化为784的一维数组    test_img = test_images[i].reshape(test_images.shape[1] * test_images.shape[2])    # 更新输入到神经网络中的训练集矩阵    test_matrix[:,i] = (test_img/255.0)*0.99+0.01    # 建立准确输出结果矩阵，对应的位置标签数值为0.99，其他位置为0.01    test_label_matrix[test_labels[i],i] = 0.99\nReshape：将输入的图片灰度与标签从新组合\n  \n\n整个前馈的矩阵运算的过程如图：\n\n\nBP的过程主要分为两个部分：\n\n对于输出层到隐含层：\n  计算f'(net) = f(net)*(1-f(net))计算loss'(zk)=-(tk-zk)计算对于每张图片该神经元的敏感度(10,60000):sensitivity = -f'(output_f_net)*loss'(zk) = (tk-zk)*f(output_f_net)*(1-f(output_f_net))[矩阵对应位置相乘]更新权重:学习率*敏感度(10,60000) @ 50个隐含层层神经元的输出(60000,50)\n对于隐含层到输入层：\n  计算对于每张图片50个隐含层神经元的每一个神经元的从输出层传入的敏感度（50*60000)：输出层敏感度的加权和*f'(net)更新权重\n\n完整的训练过程如下：\ndef train(self,featuresMatrix,targetMatrix,iterateNum):    \"\"\"    神经网络一次训练    :param featuresMatrix: 784*60000的图片灰度矩阵 也是隐含层的输入    :param targetMatrix: 10*60000的期望值矩阵 tk    :param iterateNum: 迭代序号    :return: 返回训练正确率    \"\"\"    T = 0    N = 0    # 前馈 feedforward    # 隐藏层net（50*60000）计算    hidden_net = (self.weights_i_h @ featuresMatrix)+self.bias[0]    # 隐藏层输出f(hidden_net)    hidden_f_net = self.f(hidden_net)    # 输出层net(10*60000) 计算    output_net = (self.weights_h_o @ hidden_f_net)+self.bias[1]    # 输出层输出f(output_net) zk    output_f_net = self.f(output_net)    # 统计网络预测正确率    for imgIndex in range(60000):        # 返回输出层10个神经元最大值下标 与 预测标签        if output_f_net[:,imgIndex].argmax() == targetMatrix[:,imgIndex].argmax():            T+=1        else:            N+=1    print(\"第\"+iterateNum+\"次训练集迭代正确率：\"+str(T/60000))    # 反向传播运算 backPropagation    # 对于输出层到隐含层    output_errors = targetMatrix - output_f_net    # 计算f'(net) = f(net)*(1-f(net))    # 计算loss'(zk)=-(tk-zk)    # 计算对于每张图片该神经元的敏感度(10,60000) sensitivity = -f'(net)*loss'(zk) = (tk-zk)*f(net)*(1-f(net))[矩阵对应位置相乘]    sensitivities = output_errors * output_f_net * (1.0 - output_f_net)    # 更新权重 学习率* 敏感度(10,60000) @ 50个隐含层层神经元的输出(60000,50)    self.weights_h_o += self.learnRate * (sensitivities @ hidden_f_net.T)    # 对于隐含层到输入层    # 计算对于每张图片50个隐含层神经元的每一个敏感度（50*60000） = 输出层敏感度的加权和*f'(net)    hidden_sensitivities = (self.weights_h_o.T @ sensitivities) * hidden_f_net * (1 - hidden_f_net)    # 更新权重    self.weights_i_h += self.learnRate * ( hidden_sensitivities @ featuresMatrix.T)        return T/60000\n\n预测的过程就是进行一遍前馈的过程：\ndef test(self,testMatrix,targetMatrix,iterateNum):    \"\"\"    利用神经网络对训练集进行一次测试    :param testMatrix: 784*10000的灰度矩阵    :param targetMatrix: 10*10000的预测标签矩阵    :param iterateNum: 迭代序号    :return: 返回训练正确率    \"\"\"    T = 0    N = 0    # 前馈 feedforward    # 隐藏层net（50*60000）计算    hidden_net = (self.weights_i_h @ testMatrix) + self.bias[0]    # 隐藏层输出f(hidden_net)    hidden_f_net = self.f(hidden_net)    # 输出层net(10*60000) 计算    output_net = (self.weights_h_o @ hidden_f_net) + self.bias[1]    # 输出层输出f(output_net) zk    output_f_net = self.f(output_net)    # 统计网络预测正确率    for imgIndex in range(10000):        # 返回输出层10个神经元最大值下标 与 预测标签        if output_f_net[:, imgIndex].argmax() == targetMatrix[:, imgIndex].argmax():            T += 1        else:            N += 1    print(\"第\" + iterateNum + \"次测试集迭代正确率：\" + str(T / 10000))    return T / 10000\n\n调试与结果展示代码如下：\n# 导入数据(train_images, train_labels), (test_images, test_labels) = load_data('')# 输出图片# plt.imshow(train_images[0], cmap='Greys', interpolation='None')# 初始化输入数据矩阵train_matrix = np.zeros((784,60000))test_matrix = np.zeros((784,10000))# 初始化输出层期望值矩阵train_labels_matrix = np.zeros((10,60000))+0.01test_label_matrix = np.zeros((10,10000))+0.01# 对60000张图片进行遍历for i in range(60000):    # 测试集的28*28矩阵转化为784的一维数组    img = train_images[i].reshape(train_images.shape[1]*train_images.shape[2])    # 进行归一化：除以255，再乘以0.99，最后加上0。01，保证所有的数据都在0.01到1.00之间    train_matrix[:,i] = (img/255.0)*0.99+0.01    # 建立准确输出结果矩阵，对应的位置标签数值为0.99，其他位置为0.01    # 第i张图片代表第i列，行数代表正确的标签    train_labels_matrix[train_labels[i],i] = 0.99# 对10000章测试集图片进行处理for i in range(10000):    # 训练集的28*28矩阵转化为784的一维数组    test_img = test_images[i].reshape(test_images.shape[1] * test_images.shape[2])    # 更新输入到神经网络中的训练集矩阵    test_matrix[:,i] = (test_img/255.0)*0.99+0.01    # 建立准确输出结果矩阵，对应的位置标签数值为0.99，其他位置为0.01    test_label_matrix[test_labels[i],i] = 0.99# 学习率learn_rate = 0.000025# 迭代次数epochs = 100# 初始化神经网络nn = NeuralNetwork(784,50,10,learn_rate)# 准确率数组train_accuracy = []test_accuracy = []# 进行迭代for i in range(epochs):    train_accuracy.append( nn.train(train_matrix,train_labels_matrix,str(i)) )    test_accuracy.append( nn.test(test_matrix,test_label_matrix,str(i)) )# 画图plt.plot(range(1,epochs+1),train_accuracy,'y')plt.plot(range(1,epochs+1),test_accuracy,'g')plt.legend(labels = ('train accuracy', 'test accuracy'), loc = 'lower right') # legend placed at lower rightplt.title(\"learn rate: \"+str(learn_rate))plt.xlabel('iteration')plt.ylabel('accuracy')plt.show()\n\n实验结果分析当学习率为0.1时，由于学习率过大导致更新的权重过大使得权重数组全为负值，继而在之后的迭代中计算激活能时是一个极大的复数，带入sigmod函数趋近于0，从而导致权值不再更新，正确率维持在0.1更新。\n\n\n\n\n解决的方法是降低学习率，不让权值更新的过快，将学习率降低为0.000025时，迭代50次，整个模型有很大的优化：\n\n\n提高迭代次数至200次，预测正确率可以达到75%左右：\n\n\n参考：【1】神经网络基础与反向传播_Sunburst7的博客-CSDN博客\n【2】识别MNIST数据集之（二）：用Python实现神经网络_superCally的专栏-CSDN博客\n【3】 用python创建的神经网络–mnist手写数字识别率达到98%_学习机器学习-CSDN博客_mnist手写数字识别python\n【4】利用Python对MNIST手写数据集进行数字识别（初学者入门级）_仲子_real-CSDN博客_mnist手写数字识别python\n","categories":["机器学习"],"tags":["机器学习","python"]},{"title":"神经网络","url":"/2022/01/10/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","content":"生物神经网络到人工神经网络人工神经网络的构筑理念是受到生物（人或其他动物）神经网络功能的运作启发而产生的。神经元大致可以分为：树突、突触、细胞体和轴突。\n在生物神经网络中，每个神经元与其他神经元相连，当它兴奋时，就会向相连的神经元发送化学物质，从而改变这些神经元的电位；如果某神经元的电位超过了一个阈值，它就会被激活，即”兴奋”起来，向其他神经元发送化学物质。\n\n\n人工神经网络（artificial neural network，ANN），简称神经网络（neural network，NN），是一种模仿生物神经网络的结构和功能的数学模型或计算模型。神经网络由大量的人工神经元联结进行计算，【2】是：\n\n模拟大脑学习过程的计算模型\n具有神经元的基本特征以及类似大脑的神经元的连接。\n\n神经网络是由简单处理单元组成的大规模并行分布式处理器，具有存储实验知识并使其可用的自然倾向。它在两个方面与大脑相似：\n\n知识的获取方式是网络通过一个学习的过程在环境中获取的\n神经元间连接强度被称为突触权重，用来储存获得的知识\n在学习过程中，为了在训练中正确地为特定的学习任务建模，需要对权值进行了修改\n\n神经网络的发展历史：\n\nFrank Rosenblatt，（康奈尔大学的心理学家）在1958年，在《 纽约时报 (New York Times)》上发表文 章《Electronic ‘Brain’ Teaches Itself.》，正式把算 法取名为“感知器”。\n  它有400个光传感器，它们一起充当视网膜，将 信息传递给大约1000个“神经元” ，这些神经元进行处理并输出单一信息。\n  \n马文·明斯基（人工智能之父” (Marvin Minsky) 1970图灵奖获得者）1969年，Minsky 和Papert所著的《Perceptron》一书出版， 从数学角度证明了关于单层感知器的计算具有根本的局限性， 指出感知器的处理能力有限，甚至连XOR这样的问题也不能解决。神经网络进入了萧条期\n\n杰弗里·辛顿（“神经网络之父”(Geoffrey Hinton) 2019图灵奖获得者）1986年在多伦多大学的辛顿实现了一种叫做反向传播的 原理来让神经网络从他们的错误中学习\n\n\n单层感知机网络感知机模型感知机（Perceptron）或神经元（Neuron）是神经网络中最基本的信息处理单元，它模拟生物神经元，由以下几个部分组成：\n\n输入一组特征向量：\n\n一组突触或连接，每根连接都会赋予一个权重：\n\n一个偏置(bias)：，偏置增加了感知机的灵活性\n\n一个加法器函数(线性组合器)，计算通过突触输入的加权值的和：\n\n激活函数(压实函数)，用于限制神经元输出的振幅：\n\n\n\n\n为了保持加权和的形式统一我们可以添加一个输入，权值，形成新的输入特征向量在特征增广空间中穿过原点。\n\n\n激活函数\n\n\n\n\n\n\n\n感知机分类图示假设我们有训练集分为两种类型：和。其中，样本表示为偏置，假设T1与T2是线性可分的（linearly separable），能否给出一个感知机将数据正确划分？\n\n\n我们使用单层感知机模型来解决这个问题，激活函数选择符号函数。输出1为1类正例，输出-1为2类负例。\n\n\n假设数据的维数是二维，有个测试数据真实标签为1类，下图的这个向量能够正确的分类，因为计算激活函数的值为1。\n\n\n但下图的却不能正确分类\n\n\n如何更新w让感知机变得可行？应该让加上一个使得\n\n\n对于分类结果的真实类别与预测类别一共有以下四种情况：\n\n\n\n真实类别\n预测类别\n差\n\n\n\n1\n-1\n2\n\n\n-1\n1\n-2\n\n\n1\n1\n0\n\n\n-1\n-1\n0\n\n\n因此我们设计一种误差：\n\n，把正例错分成负例，假负例\n，把负例错分成正例，假正例\n，预测正确\n\n再配上**学习率**，来构造一个标准化，用于更新激活函数中的\n感知机的学习策略对于2.3节的问题，假设我们的误差函数是均方误差的形式：\n\n\n在m=2时，也就是每个数据有两个特征时，可以画出近似的误差函数图像：\n\n\n我们的目标是减小误差，直观的来说就是“下山”，因此学习策略采用梯度下降法：\n\n对于任意一个函数，定义一个梯度算子，。\n则f的全导数\n梯度(向量)表示某一函数在该点处的方向导数沿着该方向取得最大值，即函数在该点处沿着该方向（此梯度的方向）变化最快，变化率最大（为该梯度的模）。\n\n为了最小化误差函数的值，我们选择向负梯度的方向学习\n\n\n\n\n\n\n多层神经网络\n\n上图显示的是一个简单的异或(XOR)问题三层神经网络，这个网络由一个输入层，一个隐含层（它的输入与输出并不为外部环境直接所见）和一个输出层组成。它们由可修正的权值相连，除了连接输入单元，每个单元还连接者一个**偏置(bias)**，单元也被称为神经元（neuron），我们要利用这种网络来做模式识别，输入单元提供特征量，输出单元激发的信号成为用来分类的判别函数的值。\n通过一个最简单的非线性问题了解多层神经网络——异或(XOR)问题：给定两个特征(x1,x2)，输出他们异或的值。\n每个二维输入向量都提供给输入层，每个输入神经元的输出结果就是对应的分量，隐含层单元对它的各个输入进行加权求和运算而形成标量的净激活（net activation简称net），为了简单，我们增广输入向量(附加一个特征值)和权值()，因此其形式定义：下标i是输入层单元的索引，j是输出层单元的索引，表示输入层第i个神经元到隐含层第j个神经元的权值。每个隐含层单元激发出一个输出分量，这个分量是将净激活传入一个激活函数中，该问题中定义激活函数为符号函数(sign)：每个输出单元同隐含层单元计算它的净激活：这样最后的输出，我们用这个输出来解决异或问题。容易验证，上述给定权值的三层网络的确可以解决异或（XOR）问题。它计算判决边界为 x1+x2+0.5 = 0。另一个隐含层单元的判别边界x1+x2-1.5=0。只有y1与y2都等于1，最终z才激发为+1。\n反向传播学习算法(Back Propagation)对于一个三层的神经网络，可以很直接的根据其误差，找到隐含层与输出层的权值更新，这与线性LMS算法类型，可是如何训练从输入层到隐函层的权值呢？如果一个隐含层单元的“适当”输出对每种模式都是已知的，那么输入层到隐含层的权值就可以调节到很接近它。BP算法允许我们对每个隐含层单元计算有效误差，并由此推导出一个输入层到隐含层权值的学习规则\n神经网络中有两种基本的学习模式：前馈与反向传播。\n\n前馈：在网络间传递信号，然后在输出层得到输出。\n反向传播：对于一个有监督学习，通过修改网络中每个节点的连接权重来使实际输出更接近真实值。\n\n\n\n对于一个d-n-c的全连接三层网络：\n\n一个d维的输入向量被提供给输入层，每个输入单元发送它对应的分量\n\nn个隐含层单元的每个都计算它的净激活能，他是输入层和隐含层单元权值的内积\n\n隐含层单元的输出是，f是一个激活函数，这里选择Sigmod函数。\n\n输出层单元类似于隐含层，计算净激活能，网络的最终信号\n\n是学习率。\n\n\n从输出层到隐含层根据期望输出值与实际输出值，我们先定义一个误差函数(LossFunction)：反向传播学习规则是基于梯度下降法的。权值向量首先被初始化为随机值，然后向误差减小的方向调整：\n针对上图的三层网络，考虑一个隐含层神经元到一个输出层神经元的权值分量，利用链式求导法则：其中单元k的敏感度定义为误差关于输出层净激活能的偏导，而误差又与激活函数的值直接相关：（8）式的最后一项由，对于具体的一个隐含层神经元与该神经元到输出层的权值因此一个隐含层神经元()到一个输出层神经元()的权值()更新规则：\n从隐含层到输入层(隐含层)从输入层到隐含层的权值学习规则不太一样，对误差求关于任意一个输入层到隐含层权值()的偏导：而对于第一项，因为从隐含层到输出层是全连接，一个具体的输出输入到了所有的输出层中，要对所有的输出层误差求和再偏导：、类似的定义一个隐含层单元的敏感度为各输出单元的敏感度的加权和，权重为隐含层到输出层的权重，因此输入层到隐含层的学习策略是：（9）式与（16）式共同给出了反向传播算法，确切的说是误差反向传播算法。\n\n\n\n\n简单的反向传播例子下面通过一个简单三层神经元的例子来直观的感受BP算法的过程，b代表偏置，激活函数选择sigmod函数：\n\n\n\n计算h1的输入：$h_1=w_1i_1+w_2i_2+b_1*1=0.3775$\n\n计算h1的输出值：\n\n同理计算h2的输出值y2 = 0.596884378。\n\no1的输入值：$o_1=w_5y_1+w_6y_2+b_2*1=1.105905967$\n  o1的输出值为sigmod(1.105905867)=0.75136507\n\n同理o2的输出值为0.772928465\n\n\n定义Loss function(损失函数)为平方误差，计算总误差：\n\n\n求总误差关于的梯度：\n\n\n\n\n\n因此总误差关于w5权重的梯度方向为：\n\n\n取学习率为0.5，w5的变化率：\n\n\nBP算法的优化规格化假设我们使用2-输入的网络，利用质量（以克为单位）和长度（以米为单位）特征来对鱼进行分类，这种表示法对于一个神经网络分类器具有严重的不足：质量与长度的度量不在一个数量级上，从而在训练的过程中，网络将更多的根据质量输入来调节权值。我们不希望我们的分类器仅根据某一种做出判断，仅仅因为它们在数值表示上不同。\n为了避免这样的问题，输入模式必须重新进行尺度变换(scaling)，常见的尺度变换有归一化：将所有输入标签全部映射在[0,1]区间上。\n\n\n隐含层单元数输入层与输出层单元数分别由输入向量的维数与类别决定，隐含层单元数，决定了网络的表达能力——从而决定了判别边界的复杂度。如果模式较容易分开或线性可分，那么仅需要较少的隐单元；相反需要更多的隐单元。\n隐含层单元的选择应该适中：\n\n隐含层单元过大：训练误差率可能变得很小，但可能过拟合训练集，使得测试集的误差很大\n隐含层单元过小：网络将不具备足够的自由度以较好的拟合训练数据。\n\n一个经验规则是选取隐单元的个数，使得网络中总权重数大约为n/10（n为训练样本数）\n权值初始化我们不能将权值初始化为0，否则学习过程将不可能开始。相关的知识可以看【3】\n学习率原则上，学习率足够小以保证收敛，那么它的值仅仅决定网络中到达最小误差的速度。\n\n学习率过小：可以保证收敛到最小误差，但训练速度太慢\n学习率过大：可能系统会震荡，可能系统会发散无法收敛。\n\n\n\n参考【1】模式分类第二版\n【2】神经网络详解（基本完成）_大土的博客-CSDN博客_神经网络\n【3】啃一啃神经网络——权重初始化 - 知乎zhihu.com\n","categories":["机器学习"],"tags":["机器学习"]},{"title":"实验：贝叶斯决策论预测贷款是否违约","url":"/2022/01/10/%E5%AE%9E%E9%AA%8C%EF%BC%9A%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%86%B3%E7%AD%96%E8%AE%BA%E9%A2%84%E6%B5%8B%E8%B4%B7%E6%AC%BE%E6%98%AF%E5%90%A6%E8%BF%9D%E7%BA%A6/","content":"实验说明背景信用风险是指银行向用户提供金融服务后，用户不还款的概率。信用风险一直是银行贷款决策中广泛研究的领域。信用风险对银行和金融机构，特别是商业银行来说，起着至关重要的作用，但是一直以来都比较难管理。\n本实验以贷款违约为背景，要求使用贝叶斯决策论的相关知识在训练集上构建模型，在测试集上进行贷款违约预测并计算分类准确度。\n实验数据说明训练数据集train.csv包含9000条数据，测试数据集test.csv包含1000条数据。注意，训练集和测试集中都有缺失值存在。以下是字段说明：\n\n\n\n字段\n描述\n\n\n\nloan_id\n贷款记录唯一标识\n\n\nuser_id\n借款人唯一标识\n\n\ntotal_loan\n贷款数额\n\n\nyear_of_loan\n贷款年份\n\n\ninterest\n当前贷款利率\n\n\nmonthly_payment\n分期付款金额\n\n\nGrade/class\n贷款级别\n\n\nemployment_type\n所在公司类型\n\n\nindustry\n工作领域\n\n\nwork_year\n工作年限\n\n\nhome_exist\n是否有房\n\n\ncensor_status\n审核情况\n\n\nissue_date\n贷款发放的月份\n\n\nuse\n贷款用途类别\n\n\npost_code\n贷款人申请时邮政编码\n\n\nregion\n地区编码\n\n\ndebt_loan_ratio\n债务收入比\n\n\ndel_in_18month\n借款人过去18个月逾期30天以上的违约事件数\n\n\nscoring_low\n借款人在贷款评分中所属的下限范围\n\n\nscoring_high\n借款人在贷款评分中所属的上限范围\n\n\nknown_outstanding_loan\n借款人档案中未结信用额度的数量\n\n\nknown_dero\n贬损公共记录的数量\n\n\npub_dero_bankrup\n公开记录清除的数量\n\n\nrecircle_bal\n信贷周转余额合计\n\n\nrecircle_util\n循环额度利用率\n\n\ninitial_list_status\n贷款的初始列表状态\n\n\napp_type\n是否个人申请\n\n\nearlies_credit_mon\n借款人最早报告的信用额度开立的月份\n\n\ntitle\n借款人提供的贷款名称\n\n\npolicy_code\n公开可用的策略_代码=1新产品不公开可用的策略_代码=2\n\n\nf系列匿名特征\n匿名特征f0-f4，为一些贷款人行为计数特征的处理\n\n\nearly_return\n借款人提前还款次数\n\n\nearly_return_amount\n贷款人提前还款累积金额\n\n\nearly_return_amount_3mon\n近3个月内提前还款金额\n\n\nisDefault\n贷款是否违约（预测标签）\n\n\n实验注意事项\n实验不限制使用何种高级语言，推荐使用python中pandas库处理csv文件。\n\n在进行贝叶斯分类之前重点是对数据进行预处理操作，如，缺失值的填充、将文字表述转为数值型、日期处理格式（处理成“年-月-日”三列属性或者以最早时间为基准计算差值）、无关属性的删除等方面。\n\n数据中存在大量连续值的属性，不能直接计算似然，需要将连续属性离散化。\n\n另外，特别注意零概率问题，贝叶斯算法中如果乘以0的话就会失去意义，需要使用平滑技术。\n\n实验目的是使用贝叶斯处理实际问题，不得使用现成工具包直接进行分类。\n\n实验代码中需要有必要的注释。\n\n\n实验数据分析训练样本是没有预处理的数据，直接用来训练模型是不现实的，首先我们要进行数据的分析。\n贷款记录唯一标识(loan_id)、借款人唯一标识(user_id)属于标志属性，与实际问题没有关联，可以删除。\n贷款年份(year_of_loan)、贷款发放的月份(issue_date)、借款人最早报告的信用额度开立的月份(earlies_credit_mon)、贷款人申请时邮政编码(post_code)、地区编码(region)。这些时间地点属性对贷款人的还款行为没有过多影响，也可以剔除。【1】\n通过对剩下的字段画出频率分布直方图分析：\n\n\n是否个人申请(app.type)、公开可用的策略(policy_code)、匿名特征(f1)属于归一化属性，即一个变量大部分的观测都是相同的特征，那么认为此类特征变量无法显著区分目标变量，可以考虑将其删除。\n而工作领域(industry)、(贷款级别)class、(工作年限)work_year、(所在公司类型)employer_type，这些字段都是属于分类变量，需要进行分类处理。\n同时字段total_loan、interest、monthly_payment、debt_loan_ratio、scoring_low、scoring_high、 recircle_b、recircle_u、early_return_amount_3mon的取值是连续值（小数），因此需要对这些数据进行离散化。特征离散化后，模型会更稳定，降低了模型过拟合的风险。\n对于缺失的数据，可以利用众数填充。\n实验原理主要原理本次实验原理主要为朴素贝叶斯决策论。什么是贝叶斯决策论可以看我的上一篇文章：\n\n(3条消息) 贝叶斯决策论理论_Sunburst7的博客-CSDN博客\n\n如果使用普通的贝叶斯方法计算后验概率时，类条件概率是特征向量上所有特征的联合概率，难以从有限的训练样本中直接得到。为了避开这个障碍，朴素贝叶斯分类器采用了属性条件独立性假设：对已知类别，假设所有属性相互独立，换言之，假设每个属性独立地对分类结果发生影响。基于这个假设，我们的后验概率可以修改为：【2】\n3.2 处理分类数据有时候，根据某种特性而不是数量来度量对象会更有效。我们常常使用这种定性的信息来判断一个观察值的属性，比如按照性别、颜色或者车的品牌这样的类别对其分类。本身没有内在顺序的特征类别称为 nominal。分类的特征总是有某种天然顺序的称为ordinary。【3】\n\n对于内部没有顺序的分类（性别，水果类型）：通常使用one-hot编码\n对于内部有顺序的分类（非常同意、同意、保持中立、反对..）：将 ordinal 分类转换成数值，同时保留其顺序。最常见的方法就是，创建一个字典，将分类的字符串标签映射为一个数字，然后将 其映射在特征上。\n\n本次实验中的class、industry、work_year、employer_type都属于分类特征，我们可以采用将特征值映射到一个数字的方法。\n数据离散化对于连续型的特征，在计算似然时很难找到同类型的数据，这样就会出现类条件概率为0的情况，使得分类器判别出现误差，为了避免这种情况，需要将连续特征离散化。这里用到的技术通常被称为数据分箱：【4】\n\n\n常见的分箱方法主要分为有监督与无监督两种，本实验采用卡方分箱对数据离散化：\n\n无监督分箱：不需要提供预测标签，仅凭借特征就能实现分箱\n等宽分箱\n等频分箱\n\n\n有监督分箱：需要结合预测标签的值，通过算法实现分箱\n决策树分箱\n卡方分箱：关于卡方分箱的原理可以看参考【5】的博客\n\n\n\n拉普拉斯平滑计算要预测数据集的某个特征似然时，如果在观察样本库（训练集）中没有出现过，会导致类条件概率结果是0。在贝叶斯分类中如果乘以0的话，整个后验概率就会失去意义。\n为了解决零概率的问题，法国数学家拉普拉斯最早提出用加1的方法估计没有出现过的现象的概率，所以加法平滑也叫做拉普拉斯平滑。假定训练样本很大时，每个分量x的计数加1造成的估计概率变化可以忽略不计，但可以方便有效的避免零概率问题。因此特征向量中某一个特征的类条件概率密度的计算公式可以改写为：。其中N表示特征xi有几种不同取值    \n代码实现众数填充缺失值dataframe.isnull().any()返回一个Series，某行/列存在缺失值为True，axis=0表示跨行检测，即每一列跨行检测，返回一个与列等宽的Series\ndataframe.fillna(value,inplace=True)表示用value填充DataFrame中NaN的数据，inplace=True表示填充内存中的DataFrame而不是副本。\n# 按照众数填充缺失值def fillMissingColumn(dataframe: pd.DataFrame):    # 检测出有缺失值的列，返回一个Series，有缺失值的列为True，无缺失值的列为False    missing_column = dataframe.isnull().any(axis=0)  # 按列检测    for index, value in missing_column.items():        if value:            print(index + \" needs to fill missing values\")            # 利用众数填充有缺失值的行            dataframe[index].fillna(dataframe[index].mode()[0], inplace=True)  # 一定要设置inplace=True 修改内存的值\n\n处理分类数据将class(A,B,C,D,E)利用func函数映射到1-5。mapper定义了映射字典，将分类特征映射到对应的整数。最后利用dataframe.replace(dict)替换\n# 处理nominal型的分类数据-industry：一共有14类 使用one-hot编码太大，还是采用简单编码# 处理ordinary型的分类数据：employer_type class work_yeardef classifyOrdinary(dataframe: pd.DataFrame):    # 创建class特征 映射器，将A-1,B-2...F-6    func = lambda x: ord(x) - 64  # ord()将字母转变为ASCII码    # 将class特征分类    dataframe['class'] = dataframe['class'].apply(func)    # 创建编码映射器    mapper = {        'industry': {            '金融业': 0,            '电力、热力生产供应业': 1,            '公共服务、社会组织': 2,            '住宿和餐饮业': 3,            '信息传输、软件和信息技术服务业': 4,            '文化和体育业': 5,            '建筑业': 6,            '房地产业': 7,            '采矿业': 8,            '交通运输、仓储和邮政业': 9,            '农、林、牧、渔业': 10,            '制造业': 11,            '批发和零售业': 12,            '国际组织': 13        },        'work_year': {            '&lt; 1 year': 0,            '1 year': 1,            '2 years': 2,            '3 years': 3,            '4 years': 4,            '5 years': 5,            '6 years': 6,            '7 years': 7,            '8 years': 8,            '9 years': 9,            '10+ years': 10,        },        'employer_type': {            '普通企业': 1,            '幼教与中小学校': 2,            '政府机构': 3,            '上市企业': 4,            '高等教育机构': 5,            '世界五百强': 6        }    }    # 离散化    dataframe = dataframe.replace(mapper, inplace=True)\n\n离散化​参考【4】中的博客，利用scorecardpy包先计算出分箱区间：\nimport pandas as pdimport scorecardpy as sc # 导入两列数据df = pd.DataFrame({'年龄': [29,7,49,12,50,34,36,75,61,20,3,11],                   'Y'   : [0,0,1,1,0,1,0,1,1,0,0,0]})bins = sc.woebin(df, y='Y', method='chimerge')  # 卡方分箱sc.woebin_plot(bins)\n\n使用**np.digitize(DataFrame,bin:list)**进行离散化\n\"\"\"    连续的属性值无法计算似然（后验概率）！需要将其离散化——数据分箱    需要离散化的列有：total_loan、interest、monthly_payment、debt_loan_ratio、scoring_low、scoring_high、    recircle_b、recircle_u、early_return_amount_3mon、early_return_amount、title    参考博客：https://blog.csdn.net/Orange_Spotty_Cat/article/details/116485079\"\"\"def discretize(dataframe):    # 使用分箱技术    dataframe['total_loan'] = np.digitize(dataframe['total_loan'], bins=[8000, 21000, 24000, 31000])    # dataframe['interest'] = np.digitize(dataframe['interest'], bins=range(5, 36, 1))  # 4.779-33.979    dataframe['interest'] = np.digitize(dataframe['interest'], bins=[7, 9, 10, 12, 16, 21])    # dataframe['monthly_payment'] = np.digitize(dataframe['monthly_payment'], bins=range(100, 2000, 100))  # 30.44-1503.89    dataframe['monthly_payment'] = np.digitize(dataframe['monthly_payment'], bins=[250, 500])    # dataframe['debt_loan_ratio'] = np.digitize(dataframe['debt_loan_ratio'], bins=range(10, 1000, 10))  # 0-999    dataframe['debt_loan_ratio'] = np.digitize(dataframe['debt_loan_ratio'], bins=[11, 15, 26])    # dataframe['scoring_low'] = np.digitize(dataframe['scoring_low'], bins=range(10, 1000, 10))  # 540-910.9    dataframe['scoring_low'] = np.digitize(dataframe['scoring_low'], bins=[560, 600, 630, 660, 680, 780])    # dataframe['scoring_high'] = np.digitize(dataframe['scoring_high'], bins=range(10, 2000, 10))  # 585.0-1131.818182    dataframe['scoring_high'] = np.digitize(dataframe['scoring_high'], bins=[730, 750, 860])    # dataframe['recircle_b'] = np.digitize(dataframe['recircle_b'], bins=range(10000, 770000, 10000))  # 0.0-779021.0    dataframe['recircle_b'] = np.digitize(dataframe['recircle_b'], bins=[16000])    # dataframe['recircle_u'] = np.digitize(dataframe['recircle_u'], bins=range(1, 120, 1))  # 0.0-120.6153846    dataframe['recircle_u'] = np.digitize(dataframe['recircle_u'], bins=[38, 56, 66, 70])    # dataframe['early_return_amount_3mon'] = np.digitize(dataframe['early_return_amount_3mon'],bins=range(1, 5500, 10))  # 0.0-5523.9    dataframe['early_return_amount_3mon'] = np.digitize(dataframe['early_return_amount_3mon'], bins=[50, 150, 1250])    dataframe['title'] = np.digitize(dataframe['title'], bins=[1])    dataframe['early_return_amount'] = np.digitize(dataframe['early_return_amount'], bins=[5000,10000,15000,20000])\n\n构造分类器为了避免大量重复的计算类条件概率（有很多特征取值相同，计算的类条件概率也是重复的），先用两个numpy的二维数据(利用下标访问)存储所有可能特征值的类条件概率。计算出还剩下29个特征，经过离散化后每个特征的取值类型在100种以内。初始化为0。\n​train.columns.get_loc(columns_label)用于返回某个列名的列索引值。\n\"\"\"    朴素贝叶斯分类，假设每个字段之间相互独立：        小数的连乘可能下溢，因此对p(x|w)*p(w)取对数         为了防止零概率情况使log无意义，使用拉普拉斯平滑技术    定义一个分类器 g(x) = lnp(x|w)+lnp(w)        输入一个特征向量x与一个数据集，输出它的分类\"\"\"# 创建两个dataframe分别缓存isDefault=0与isDefault=1的似然值storeage0 = np.zeros((29,100))storeage1 = np.zeros((29,100))def classifier(x, train: pd.DataFrame):    # 分别统计贷款没违约与贷款违约的情况    type0 = train[train['isDefault'] == 0]    type1 = train[train['isDefault'] == 1]    # 计算行数    sum_type0 = type0.count().values[0]    sum_type1 = type1.count().values[0]    # 计算先验概率    prior_0 = sum_type0 / (sum_type0 + sum_type1)    prior_1 = sum_type1 / (sum_type0 + sum_type1)    # print(str(prior_0) + \" \" + str(prior_1))    # 初始化分类器值(加上lnp(w))    g0 = math.log(prior_0)    g1 = math.log(prior_1)    # print(str(g0) + \" \" + str(g1))    # 计算所有列的似然/类条件概率密度    for column in train.columns:        if column != 'isDefault':  # 去除预测标签的影响            likelihood0, likelihood1 = 0, 0            if storeage0[train.columns.get_loc(column)][int(x[column])] &gt; 0:                # 缓存中已有数据                likelihood0 = storeage0[train.columns.get_loc(column)][int(x[column])]            else:                # 计算拉普拉斯平滑后的似然                likelihood0 = (type0[type0[column] == x[column]].count().values[0] + 1) / (                        sum_type0 + train[column].nunique())                # 按照行-列索引，列—特征值 将数据保存在缓存中                storeage0[train.columns.get_loc(column)][int(x[column])] = likelihood0            # 对 isDefault = 1的训练集数据进行一次同样的操作，计算后验概率            if storeage1[train.columns.get_loc(column)][int(x[column])] &gt; 0:                likelihood1 = storeage1[train.columns.get_loc(column)][int(x[column])]            else:                likelihood1 = (type1[type1[column] == x[column]].count().values[0] + 1) / (                        sum_type1 + train[column].nunique())                storeage1[train.columns.get_loc(column)][int(x[column])] = likelihood1            # 取对数            ln_likelihood0 = math.log(likelihood0)            ln_likelihood1 = math.log(likelihood1)            # print(\"type0: likelihood: \" + str(likelihood0) + \" ln:\" + str(ln_likelihood0))            # print(\"type1: likelihood: \" + str(likelihood1) + \" ln:\" + str(ln_likelihood1))            g0 += ln_likelihood0            g1 += ln_likelihood1            # print('------------------------------------------------------------------')    # print(str(g0) + \" \" + str(g1))    if g0 &gt;= g1:        # 预测为不违约        return 0    else:        return 1\n\n主函数与评估模型​假设贷款不违约(isDefault=0)为正例，贷款违约(isDefault=1)为负例。利用正确率、精度、召回率评估模型。\n# 读取训练集trainSet = pd.read_csv('train.csv')# 读取测试集testSet = pd.read_csv('test.csv')# 删除无关数据列（用户的id，贷款年份(year_of_loan)、贷款发放的月份(issue_date)、借款人最早报告的信用额度开立的月份(earlies_credit_mon)、贷款人申请时邮政编码(post_code)、地区编码(region)等信息，主观判断其对是否违约影响甚微。都是无关属性）trainSet = trainSet.drop(    ['year_of_loan', 'loan_id', 'user_id', 'earlies_credit_mon', 'issue_date', 'post_code', 'region'], axis=1)testSet = testSet.drop(    ['year_of_loan', 'loan_id', 'user_id', 'earlies_credit_mon', 'issue_date', 'post_code', 'region'], axis=1)# 画出频率分布直方图分析数据fig,axs=plt.subplots(8,4,figsize=(40,20),sharex=False,sharey=False)for i in range(10):    for j in range(4):        if i*4+j&lt;31:            axs[i][j].set_title(trainSet.columns[i*4+j])            axs[i][j].bar(x=pd.value_counts(trainSet[trainSet.columns[i*4+j]]).index,height=pd.value_counts(trainSet[trainSet.columns[i*4+j]]).values)plt.show()# 而app_type policy_code 与 f1都是归一化属性，直接去除trainSet = trainSet.drop(['app_type', 'policy_code', 'f1'], axis=1)testSet = testSet.drop(['app_type', 'policy_code', 'f1'], axis=1)# 数据预处理fillMissingColumn(trainSet)classifyOrdinary(trainSet)discretize(trainSet)fillMissingColumn(testSet)classifyOrdinary(testSet)discretize(testSet)# 保存分类器的分类结果isDefault_f = []for index, row in testSet.iterrows():    isDefault_f.append(classifier(row, trainSet))# 将分类结果添加到测试集中testSet['forecast'] = isDefault_f# 创建评估数据集evaluation = testSet[['isDefault', 'forecast']]print(evaluation)# 假设 没有违约（isDefault == 0）为正例TP = 0  # 真正例TN = 0  # 真负例FP = 0  # 假正例FN = 0  # 假负例for index, row in evaluation.iterrows():    if row['isDefault'] == 0 and row['forecast'] == 0:        TP += 1    if row['isDefault'] == 0 and row['forecast'] == 1:        FN += 1    if row['isDefault'] == 1 and row['forecast'] == 0:        FP += 1    if row['isDefault'] == 1 and row['forecast'] == 1:        TN += 1Accuracy = (TP + TN) / (TP + TN + FP + FN)Precision = TP / (TP + FP)Recall = TP / (TP + FN)print(\"正确率: %f\" % Accuracy)print(\"精确率: %f\" % Precision)print(\"召回率: %f\" % Recall)\n\n实验结果​    测试集共有1000行数据，forecast为我们预测的数据。正确率还有待改进。\n\n\n\n参考【1】(3条消息) Lending Club贷款违约预测_Mango的博客-CSDN博客\n【2】机器学习—周志华\n【3】Python机器学习手册：从数据预处理到深度学习\n【4】数据科学猫：数据预处理 之 数据分箱(Binning)_Orange_Spotty_Cat的博客-CSDN博客\n【5】从论文分析，告诉你什么叫 “卡方分箱”？ - 云+社区 - 腾讯云 (tencent.com)\n","categories":["机器学习"],"tags":["机器学习","python"]},{"title":"实验：参数估计与非参数估计","url":"/2022/01/10/%E5%AE%9E%E9%AA%8C%EF%BC%9A%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1%E4%B8%8E%E9%9D%9E%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/","content":"最大似然估计实验要求\n\n使用上面给出的三维数据： \n\n编写程序，对类1和类2中的三个特征𝑥𝑖分别求解最大似然估计的均值𝜇̂和方差。 \n\n编写程序，处理二维数据的情形𝑝(𝑥)~𝑁(µ, Σ)。对类1和类2中任意两个特征的组合分别求解最大似然估计的均值𝜇̂和方差（每个类有3种可能）。\n\n编写程序，处理三维数据的情形𝑝(𝑥)~𝑁(µ, Σ)。对类1和类2中三个特征求解最大似然估计的均值𝜇̂和 方差𝛴。 \n\n假设该三维高斯模型是可分离的，即，编写程序估计类1和类2中的均值和协方差矩阵中的参数。 \n\n比较前 4 种方法计算出来的每一个特征的均值的异同，并加以解释。 \n\n比较前 4 种方法计算出来的每一个特征的方差的异同，并加以解释。\n\n\n实验思路根据最大似然估计的原理，可以推导出：均值的最大似然估计就是样本的均值，而协方差的最大似然估计是n个的算术平均。实际上对方差的最大似然估计是有偏的估计，样本的协方差矩阵，而我们估计的方差是，具体原理可以看：参数估计—最大似然估计与贝叶斯估计\n\n\n对于任意一个多元的高斯分布，这里的多元就对应着数据的多特征（例如本次实验中的x1,x2,x3），此高斯分布的采样是以列向量的形式，每行的值为一个随机变量，因此计算统计属性：\n\n均值：分别计算每个特征的均值，以向量的形式输出，即均值向量\n方差：数据集中所有向量（列向量）计算，在求和取平均\n\n当高斯模型是可分离的时，说明每个特征（随机变量）相互独立，则任意两个特征的协方差为0（Cov(x1,x2)=0）,因此协方差矩阵的形式如下：\n代码实现数据以DataFrame的形式存储，计算均值向量的函数：\n# 通用的计算一个数据集的平均向量def calculateAvg(vectors:pd.DataFrame):    # 创建一个空Series存储平均数    avg = pd.Series(index=vectors.columns,dtype=float)    for column in vectors.columns:        # 分别计算每个特诊的平均值        avg[column] = vectors[column].mean()    return np.array(avg)\n\n计算协方差矩阵的函数：\n# 通用的计算一个数据集的估计协方差矩阵：对每个向量求其协方差矩阵再求和取平均# 返回一个协方差矩阵，训练集内是一维向量的话返回的矩阵只有一个元素def calculateCov(vectors:pd.DataFrame):    # 计算数据集的均值列向量    mu = np.matrix(calculateAvg(vectors)).T    # 获取训练集中每个随机变量的维度    dimension = vectors.shape[1]    Cov = np.zeros((dimension,dimension))    for index,row in vectors.iterrows():        # 取出训练集中的每一个数据，形式为列向量        xi = np.matrix(row).T        diff = xi - mu        Cov+=diff*diff.T    # 取平均    return Cov/vectors.shape[0]\n\n利用DataFrame[[特征1,特征2,..]]来提取训练集中的某几个特征，分别实现计算。\n\n问（1）编写程序，对类1和类2中的三个特征𝑥𝑖分别求解最大似然估计的均值𝜇̂和方差。 \n  # 创建数据帧trainSet_1 = pd.read_csv('w1.csv')trainSet_2 = pd.read_csv('w2.csv')# (1)对类 1 和类 2 中的三个特征𝑥𝑖分别求解最大似然估计的均值𝜇̂和方差𝜎2。print(\"(1): \")print(\"类1：\")trainSet_1_x1 = trainSet_1['x1'].to_frame()print(\"x1的最大似然估计:μ：\"+str(calculateAvg(trainSet_1_x1))+\" 𝜎^2: \"+str(calculateCov(trainSet_1_x1)))trainSet_1_x2 = trainSet_1['x2'].to_frame()print(\"x2的最大似然估计:μ：\"+str(calculateAvg(trainSet_1_x2))+\" 𝜎^2: \"+str(calculateCov(trainSet_1_x2)))trainSet_1_x3 = trainSet_1['x3'].to_frame()print(\"x3的最大似然估计:μ：\"+str(calculateAvg(trainSet_1_x3))+\" 𝜎^2: \"+str(calculateCov(trainSet_1_x3)))print(\"------------------------------------------------------------------------------\")print(\"类2：\")trainSet_2_x1 = trainSet_2['x1'].to_frame()print(\"x1的最大似然估计:μ：\"+str(calculateAvg(trainSet_2_x1))+\" 𝜎^2: \"+str(calculateCov(trainSet_2_x1)))trainSet_2_x2 = trainSet_2['x2'].to_frame()print(\"x2的最大似然估计:μ：\"+str(calculateAvg(trainSet_2_x2))+\" 𝜎^2: \"+str(calculateCov(trainSet_2_x2)))trainSet_2_x3 = trainSet_2['x3'].to_frame()print(\"x3的最大似然估计:μ：\"+str(calculateAvg(trainSet_2_x3))+\" 𝜎^2: \"+str(calculateCov(trainSet_2_x3)))\n问（2）编写程序，处理二维数据的情形𝑝(𝑥)~𝑁(µ, Σ)。对类1和类2中任意两个特征的组合分别求解最大似然估计的均值𝜇̂和方差（每个类有3种可能）。\n  # 创建数据帧trainSet_1 = pd.read_csv('w1.csv')trainSet_2 = pd.read_csv('w2.csv')# (2)处理二维数据的情形𝑝𝑝(𝑥)~𝑁(µ, Σ)。对类 1 和类 2 中任意两个特征的组合分别求解最大似然估计的均值𝜇̂和方差𝛴𝛴（每个类有3种可能）。print(\"(2): \")print(\"类1：\")trainSet_1_x1x2 = trainSet_1[['x1','x2']]print(\"(x1,x2)的最大似然估计:\")print(\"μ：\"+str(calculateAvg(trainSet_1_x1x2)))print(\"𝜎^2: \")print(calculateCov(trainSet_1_x1x2))trainSet_1_x1x3 = trainSet_1[['x1','x3']]print(\"(x1,x3)的最大似然估计:\")print(\"μ：\"+str(calculateAvg(trainSet_1_x1x3)))print(\"𝜎^2:\")print(calculateCov(trainSet_1_x1x3))trainSet_1_x2x3 = trainSet_1[['x2','x3']]print(\"(x2,x3)的最大似然估计:\")print(\"μ：\"+str(calculateAvg(trainSet_1_x2x3)))print(\"𝜎^2: \")print(calculateCov(trainSet_1_x2x3))print(\"------------------------------------------------------------------------------\")print(\"类2：\")trainSet_2_x1x2 = trainSet_2[['x1','x2']]print(\"(x1,x2)的最大似然估计:\")print(\"μ：\"+str(calculateAvg(trainSet_2_x1x2)))print(\"𝜎^2: \")print(calculateCov(trainSet_2_x1x2))trainSet_2_x1x3 = trainSet_2[['x1','x3']]print(\"(x1,x3)的最大似然估计:\")print(\"μ：\"+str(calculateAvg(trainSet_2_x1x3)))print(\"𝜎^2: \")print(calculateCov(trainSet_2_x1x3))trainSet_2_x2x3 = trainSet_2[['x2','x3']]print(\"(x2,x3)的最大似然估计:\")print(\"μ：\"+str(calculateAvg(trainSet_2_x2x3)))print(\"𝜎^2: \")print(calculateCov(trainSet_2_x2x3))\n（3）编写程序，处理三维数据的情形𝑝(𝑥)~𝑁(µ, Σ)。对类1和类2中三个特征求解最大似然估计的均值𝜇̂和 方差𝛴。 \n  # 创建数据帧trainSet_1 = pd.read_csv('w1.csv')trainSet_2 = pd.read_csv('w2.csv')# (3)编写程序，处理三维数据的情形𝑝(𝑥)~𝑁(µ, Σ)。对类 1 和类 2 中三个特征求解最大似然估计的均值𝜇̂和方差𝛴𝛴print(\"(3)\")print(\"类1\")print(\"(x1,x2,x3)的最大似然估计: µ\"+str(calculateAvg(trainSet_1)))print(\"Σ:\")print(calculateCov(trainSet_1))print(\"------------------------------------------------------------------------------\")print(\"类2\")print(\"(x1,x2,x3)的最大似然估计: µ\"+str(calculateAvg(trainSet_2)))print(\"Σ:\")print(calculateCov(trainSet_2))\n（4）假设该三维高斯模型是可分离的，即，编写程序估计类1和类2中的均值和协方差矩阵中的参数。 \n  # 创建数据帧trainSet_1 = pd.read_csv('w1.csv')trainSet_2 = pd.read_csv('w2.csv')# 取出每一个特征trainSet_1_x1 = trainSet_1['x1'].to_frame()trainSet_1_x2 = trainSet_1['x2'].to_frame()trainSet_1_x3 = trainSet_1['x3'].to_frame()trainSet_2_x1 = trainSet_2['x1'].to_frame()trainSet_2_x2 = trainSet_2['x2'].to_frame()trainSet_2_x3 = trainSet_2['x3'].to_frame()# (4)# 因为该模型是可分离的，所以各个特征之间相互独立，每个训练样本向量(x1,x2,x3)的Cov(xi,xj)=0 所以协方差是一个对角矩阵，对角线即为一维数据的方差。print(\"类1\")print(\"(x1,x2,x3)的最大似然估计:\")print(\"µ\"+str(calculateAvg(trainSet_1)))Cov_1 = np.zeros((3,3))Cov_1[0, 0] = calculateCov(trainSet_1_x1)Cov_1[1, 1] = calculateCov(trainSet_1_x2)Cov_1[2, 2] = calculateCov(trainSet_1_x3)print(\"Σ:\")print(Cov_1)print(\"----------------------------------------------------------\")print(\"类2\")print(\"(x1,x2,x3)的最大似然估计:\")print(\"µ\"+str(calculateAvg(trainSet_2)))Cov_2 = np.zeros((3,3))Cov_2[0, 0] = calculateCov(trainSet_2_x1)Cov_2[1, 1] = calculateCov(trainSet_2_x2)Cov_2[2, 2] = calculateCov(trainSet_2_x3)print(\"Σ:\")print(Cov_2)\n（5）（6）比较前 4 种方法计算出来的每一个特征的均值与方差的异同，并加以解释。 \n  均值的计算与向量维度无关，都是每一维数据求和再除以n。\n  因为该模型是可分离的，所以各个特征之间相互独立，每个训练样本向量(x1,x2,x3)的Cov(xi,xj)=0 所以协方差是一个对角矩阵，除对角线外其他处的值为0，对角线即为一维数据的方差。\n\n\n实验结果\n问题1\n \n问题2\n (2): 类1：(x1,x2)的最大似然估计:μ：[-0.0709 -0.6047]𝜎^2: [[0.90617729 0.56778177] [0.56778177 4.20071481]](x1,x3)的最大似然估计:μ：[-0.0709 -0.911 ]𝜎^2:[[0.90617729 0.3940801 ] [0.3940801  4.541949  ]](x2,x3)的最大似然估计:μ：[-0.6047 -0.911 ]𝜎^2: [[4.20071481 0.7337023 ] [0.7337023  4.541949  ]]------------------------------------------------------------------------------类2：(x1,x2)的最大似然估计:μ：[-0.0426  0.4299]𝜎^2: [[ 0.06478984 -0.01184426] [-0.01184426  0.04597009]](x1,x3)的最大似然估计:μ：[-0.0426   0.00372]𝜎^2: [[ 0.06478984 -0.00306033] [-0.00306033  0.00726551]](x2,x3)的最大似然估计:μ：[0.4299  0.00372]𝜎^2: [[0.04597009 0.00850987] [0.00850987 0.00726551]]\n问题3\n \n问题4\n \n\nParzen窗实验要求\n\nParzen 窗估计： 使用上面表格中的数据进行 Parzen 窗估计和设计分类器。窗函数为一个球形的高斯函数如下所示：\n\n\n编写程序，使用 Parzen 窗估计方法对任意一个的测试样本点𝑥进行分类。对分类器的训练则使用表格中的三维数据。令h = 1，分类样本点为，， 。\n实验思路实验给出的训练集数据分类三个类别，记为w1,w2,w3，我们分别对这三类数据计算每个训练集样本的关于样本测试点的窗函数值，在求和取平均，计算出估计的后验概率。\n由于先验知识我的得到，这三类的先验概率应相等，所以由最大后验概率决策变为最大似然决策，根据以下公式计算出每个类的估计类条件概率密度，比大小判断即可。\n\n值得注意的是，Parzen窗是将测试样本点放在窗的中心，让训练集中的每个数据去与窗中心比对，也就是代表测试集数据，代表训练集数据\n代码实现\n11行定义了一个窗函数计算函数，输入一个测试样本点、一个训练集样本点以及窗宽，输出窗函数的值。\n21行定义了一个求和取平均的函数，用于计算每个类的类条件概率密度\n31行定义了一个分类器，传入测试点，通过已经输入好的训练集对该测试数据进行分类\n\nimport pandas as pdimport numpy as npimport math# 导入训练集数据trainSet_1 = pd.read_csv('w1.csv')trainSet_2 = pd.read_csv('w2.csv')trainSet_3 = pd.read_csv('w3.csv')# 计算sample测试数据在训练数据trainSample下的窗函数def window(sample:pd.Series,trainSample:pd.Series,h):    # 将Series转化为列向量    vector_s = np.matrix(sample).T    vector_ts = np.matrix(trainSample).T    # 计算 x-xi    diff = vector_s - vector_ts    # 返回窗函数值    return math.exp(-diff.T*diff/(2*h**2))# Parzen窗方法估计该类的条件概率密度def Parzen(sample:pd.Series,trainSet:pd.DataFrame):    # 初始化似然    likelihood = 0.0    for index, row in trainSet.iterrows():        # 对样本的每个点计算窗函数(h=1)，累加        likelihood+=window(sample,row,1)    likelihood = likelihood/10    # 返回估计的后验概率    return likelihood# 该实验的Parzen窗分类器，训练集中每个类的先验概率相等，因此后验概率就等于类条件概率密度def ParzenClassifier(sample:pd.Series):    posterior_1 = Parzen(sample, trainSet_1)    posterior_2 = Parzen(sample, trainSet_2)    posterior_3 = Parzen(sample, trainSet_3)    print(sample)    print(\"p(w1): \"+  str(posterior_1))    print(\"p(w2): \" + str(posterior_2))    print(\"p(w3): \" + str(posterior_3))    if posterior_1&gt;posterior_2:        if posterior_1&gt;posterior_3:            print(\"Sample belong 类1\")        else:            print(\"Sample belong 类3\")    else:        if posterior_2&gt;posterior_3:            print(\"Sample belong 类2\")        else:            print(\"Sample belong 类3\")    print(\"-------------------------------------\")ParzenClassifier(pd.Series([0.5,1.0,0.0]))ParzenClassifier(pd.Series([0.31,1.51,-0.50]))ParzenClassifier(pd.Series([-0.3,0.44, -0.1]))\n\n实验结果\n\n可以看到这三个测试数据都属于类2\nK近邻实验要求\n\nk-近邻概率密度估计： 对上面表格中的数据使用k-近邻方法进行概率密度估计： \n\n编写程序，对于一维的情况，当有 n 个数据样本点时，进行k-近邻概率密度估计。 对表格中的类3的特征𝑥1，用程序画出当 k=1，3，5 时的概率密度估计结果。  \n编写程序，对于二维的情况，当有 n 个数据样本点时，进行k-近邻概率密度估计。 对表格中的类2的特征(𝑥1, 𝑥2)𝑡，用程序画出当 k=1，3，5 时的概率密度估计结果。 \n编写程序，对表格中的3个类别的三维特征，使用k-近邻概率密度估计方法。并且 对下列点处的概率密度进行估计： (-0.41,0.82,0.88)𝑡，(0.14,0.72, 4.1)𝑡，(-0.81,0.61,  -0.38)𝑡\n\n实验思路\n实验的核心公式就是（3）式，给定一个测试数据点，以测试数据点为中心，我们分别计算从该点到训练集中样本点的数据的距离作为度量的标准，排序。然后选出距离测试数据点第k近的样本点距离，计算出包括k个训练集数据点的超立方体体积，带入公式计算。具体的针对不同维度：\n\n一维：，超立方体的体积就是以测试点为中心，的线段长度。\n二维：，超立方体体积是以测试点为中心，为半径的圆\n三维：\n\n指的注意的是，在画图的过程中，可能出现测试点与样本点重合的情况，这时最好在分母加上一个极小项防止/0。\n当我们估计出类条件概率密度后，因为由表中数据得到，每个类别的训练数据数量相等先验概率相同，因此对于每个测试数据只需要计算三种情况下的类条件概率密度，再用最大类条件概率密度估计进行决策即可。\n代码实现及结果一维情况编写了一个1维KNN方法计算一个测试数据集的概率密度，输入测试数据（一维）、训练集、K值。输出概率密度\n# 对于一维的情况，当有 n 个数据样本点时，进行k-近邻概率密度估计，# 对于类3_x3特征，估计任意一个点关于类3的类条件概率密度import numpy as npimport pandas as pdimport matplotlib.pyplot as plt# 定义1维KNN方法计算一个测试数据集的概率密度，输入测试数据、训练集、K值 输出概率密度def one_dimension_KNN(testData:float,trainSet:pd.Series,k:int):    distance = []    for i in range(trainSet.shape[0]):        # 计算测试数据点 与 训练集中每个样本点的距离        d = np.abs(testData-trainSet[i])        distance.append(d)    # 距离数组进行排序 提取出第k个数据    distance.sort()    posterior = (k/trainSet.shape[0])/(2*distance[k-1])    return posterior# 导入实验1数据，w3类的x3特征trainSet1 = pd.read_csv('w3.csv')['x3']# 随机产生n=500个-2~2的1维随机数dimension1_randoms = np.random.uniform(-2, 2, 500)# 进行升序排序dimension1_randoms = np.sort(dimension1_randoms)# 声明三个一维数组用于存储K值不同情况下的后验概率dimension1_posterior_1 = []dimension1_posterior_3 = []dimension1_posterior_5 = []# 对随机数计算后验概率for i in range(500):    dimension1_posterior_1.append(one_dimension_KNN(dimension1_randoms[i], trainSet1, 1))    dimension1_posterior_3.append(one_dimension_KNN(dimension1_randoms[i], trainSet1, 3))    dimension1_posterior_5.append(one_dimension_KNN(dimension1_randoms[i], trainSet1, 5))# 画出三张一维的图像plt.subplot(131)plt.plot(dimension1_randoms,dimension1_posterior_1)plt.title('k=1 pdf')plt.subplot(132)plt.plot(dimension1_randoms,dimension1_posterior_3)plt.title('k=3 pdf')plt.subplot(133)plt.plot(dimension1_randoms,dimension1_posterior_5)plt.title('k=5 pdf')plt.show()\n\n实验结果如图，可以看到在k=1时，在训练集样本点周围有着明显的尖峰，表示图中充满噪音（可能测试样本只是和某个训练样本接近而不是该类，但类条件概率密度却很大）当k增大时曲线变得平滑最后收敛为一个极值，表示类条件概率密度的估计慢慢变得准确。\n\n\n二维情况定义2维KNN方法\n\n输入n个测试数据的x1特征取值矩阵与x2特征取值矩阵、训练数据集、k值。\n输出后验概率估计数组\n\n生成x1、x2特征的测试数据是在一定范围内每隔0.05采样。\n# 对于2维的情况，当有 n 个数据样本点时，进行k-近邻概率密度估计，import numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3D# 定义2维knn方法(x1,x2) 输入x1特征取值矩阵与x2特征取值矩阵、训练数据集、k# x1矩阵代表二维坐标轴的所有点的x1特征值 x2矩阵代表二维坐标轴的所有点的x2特征值def two_dimension_KNN(x1:np.matrix,x2:np.matrix,trainSet:pd.DataFrame,k:int):    # 声明一个后验概率矩阵存储计算出的后验概率 行(x轴)代表x2的取值，列(y轴)代表x1取值    posteriorMatrix = np.zeros((x1.shape[0],x1.shape[1]))    # 每一个x2特征    for i in range(x1.shape[0]):        # 每一个x1特征        for j in range(x1.shape[1]):            # 存储二维的欧氏距离            distance = []            for index,row in trainSet.iterrows():                # 计算测试数据点 与 训练集中每个样本点的欧式距离                d = np.sqrt((x1[i,j]-row[0])**2+(x2[i,j]-row[1])**2)                distance.append(d)            # 距离数组进行排序 提取出第k个数据            distance.sort()            # 分母加上一个极小的数防止测试点与样本点重合导致分布为0的情况            posterior = (k / trainSet.shape[0]) / (np.pi * (distance[k - 1]**2)+np.spacing(1))            posteriorMatrix[i,j] = posterior    return posteriorMatrix# 导入实验2数据 w2类的x1,x2特征trainSet2 = pd.read_csv('w2.csv')[['x1','x2']]# 生成x1 100个 x2 80个测试数据test_x1 = np.arange(-3, 2, 0.05)test_x2 = np.arange(0, 4, 0.05)# 将x1与x2网格化matrix_x1,matrix_x2 = np.meshgrid(test_x1, test_x2)# 计算不同k值情况下网格中每个点的后验概率posterior1 = two_dimension_KNN(matrix_x1,matrix_x2,trainSet2,1)posterior3 = two_dimension_KNN(matrix_x1,matrix_x2,trainSet2,3)posterior5 = two_dimension_KNN(matrix_x1,matrix_x2,trainSet2,5)# 画图配置fig = plt.figure(figsize=(12, 6), facecolor='w')ax1 = fig.add_subplot(131, projection='3d')ax1.plot_surface(matrix_x1,matrix_x2,posterior1,                    rstride=1,  # rstride（row）指定行的跨度                    cstride=1,  # cstride(column)指定列的跨度                    cmap=plt.get_cmap('rainbow'))  # 设置颜色映射ax1.set_xlabel('x2')ax1.set_ylabel('x1')ax1.set_zlabel('likelihood')plt.title('k=1 pdf')ax2 = fig.add_subplot(132, projection='3d')ax2.plot_surface(matrix_x1,matrix_x2,posterior3,                    rstride=1,                    cstride=1,                    cmap=plt.get_cmap('rainbow'))ax1.set_xlabel('x2')ax1.set_ylabel('x1')ax1.set_zlabel('likelihood')plt.title('k=3 pdf')ax3 = fig.add_subplot(133, projection='3d')ax3.plot_surface(matrix_x1,matrix_x2,posterior5,                    rstride=1,                    cstride=1,                    cmap=plt.get_cmap('rainbow'))ax1.set_xlabel('x2')ax1.set_ylabel('x1')ax1.set_zlabel('likelihood')plt.title('k=5 pdf')plt.show()\n\n实验结果如图所示：同一维的情况，在k=1时，在训练集样本点周围有着明显的尖峰，表示图中充满噪音（可能测试样本只是和某个训练样本接近而不是该类，但类条件概率密度却很大）当k增大时曲线变得平滑最后收敛为一个极值，表示类条件概率密度的估计慢慢变得准确。\n\n\n三维情况该情况与前面的有所不同，实验要求导入三个类别全部特征，判断具体的三个测试数据属于哪个类别，因此对于每个测试数据需要计算三种情况下的类条件概率密度，再用最大类条件概率密度估计进行决策。\nimport numpy as npimport pandas as pd# 导入实验3数据 三个类别的全部特征trainSet3_1 = pd.read_csv('w1.csv')trainSet3_2 = pd.read_csv('w2.csv')trainSet3_3 = pd.read_csv('w3.csv')trainSet = [trainSet3_1, trainSet3_2, trainSet3_3]# 三维的KNN方法，该方法输入一个三维列向量，k值；输出该向量的类别def three_dimension_KNN(testData:np.matrix,k:int):    # 声明距离数组用于保存距离    distance = [[],[],[]]    posterior = []    for i in range(3):        # 对每类的数据集计算测试数据点与训练集中每个样本点的距离        for j in range(10):            d = np.sqrt((testData[0,0]-trainSet[i].iloc[j]['x1'])**2 +                        (testData[1,0]-trainSet[i].iloc[j]['x2'])**2 +                        (testData[2,0]-trainSet[i].iloc[j]['x3'])**2)            distance[i].append(d)        # 距离数组进行排序 提取出第k个数据        distance[i].sort()        V = 4 * np.pi * (distance[i][k - 1] ** 3) / 3        posterior.append(k/10/V)    print(\"类条件概率密度数组:\"+str(posterior))    return posterior.index(max(posterior))# [0.14],[0.72],[4.1]  [-0.81],[0.61],[-0.38]]print(\"(-0.41,0.82,0.88)属于w\"+str(three_dimension_KNN(np.matrix([[-0.41],[0.82],[0.88]]),3)))print(\"(0.14,0.72,4.1)属于w\"+str(three_dimension_KNN(np.matrix([[0.14],[0.72],[4.1]]),3)))print(\"(-0.81,0.61,-0.38)属于w\"+str(three_dimension_KNN(np.matrix([[-0.81],[0.61],[-0.38]]),3)))\n\n分类的结果如图：\n\n\n\n\nKNN实战现有一数据集存放在 e2.txt 中，共有 1000 条数据。e2.txt 中数据格式如下图所示： \n\n\n三个特征： 1.每年的出行里程 2.玩游戏所占用的时间百分比 3.每三天喝的牛奶总升数。三个标签： 1.不喜欢 2.一般 3.喜欢 \n用学过的 KNN 方法 来构建一个分类器，判断一个样本所属的类别\n实验要求\n数据预处理 \n\n将 e2.txt 中的数据处理成可以输入给模型的格式 \n是否还需要对特征值进行归一化处理？目的是什么？\n\n\n数据可视化分析：将预处理好的数据以散点图的形式进行可视化，通过直观感觉总结规律，感受KNN模型思想与人类经验的相似之处。 \n\n构建 KNN 模型并测试 \n\n输出测试集各样本的预测标签和真实标签，并计算模型准确率。 \n\n选择哪种距离更好？欧氏还是马氏？ \n\n改变数据集的划分以及 k 的值，观察模型准确率随之的变化情况。 注意：选择训练集与测试集的随机性\n\n\n\n使用模型构建可用系统 利用构建好的 KNN 模型实现系统，输入为新的数据的三个特征，输出为预测的类别。\n\n\n实验思路KNN模型的核心方法还是之前构造的三维KNN方法，简单的修改了一点输出：我们这里拿欧式距离度量\n# 三维的KNN方法，该方法输入一个三维列向量，k值；输出该向量的类别def three_dimension_KNN(testData:np.matrix,k:int):    # 声明距离数组用于保存距离    distance = [[],[],[]]    posterior = []    # 对三种预测标签分别计算后验概率    for i in range(3):        # 对每类的数据集计算测试数据点与训练集中每个样本点的距离        for j in range(trainSet[i].shape[0]):            # 计算欧氏距离            d = np.sqrt((testData[0,0]-trainSet[i].iloc[j]['mileage'])**2 +                        (testData[1,0]-trainSet[i].iloc[j]['game'])**2 +                        (testData[2,0]-trainSet[i].iloc[j]['milk'])**2)            distance[i].append(d)        # 距离数组进行排序 提取出第k个数据        distance[i].sort()        V = 4 * np.pi * (distance[i][k - 1] ** 3) / 3        posterior.append(k/10/V)    print(\"概率密度数组：\"+str(posterior))    if posterior.index(max(posterior)) == 0:        return 'largeDoses'    elif posterior.index(max(posterior)) == 1:        return 'smallDoses'    else:        return 'didntLike'\n\n先导入实验数据：\ndata = pd.DataFrame(columns=['mileage','game','milk','isLike'])# 读取文件with open('e2.txt','r') as f:    # 按行读取    content = f.readlines()    for line in content:        # 按照'\\t'分割        newLine = pd.Series(line.split('\\t'),index=['mileage','game','milk','isLike'])        # 去除预测标签末尾的'\\n'        newLine['isLike'] = newLine['isLike'].strip('\\n')        data = data.append(newLine,ignore_index=True)\n\n由于每个特征的度量值不同，有的特征取值很大，有的特征取值很小，如果直接进行计算欧式具体不合理，我们需要进行归一化的处理：使用最小归一化的方法，将所有的特征值映射到[0,1]区间上。计算公式如下：实际过程我们使用一个库：\n# 归一化features = data.iloc[:,0:3]features = MinMaxScaler().fit_transform(features)data.iloc[:,0:3] = features # 覆盖原来数据\n\n然后是对训练集与测试集的划分，因为有选择训练集与测试集的随机性，我们采用留出法：直接将原数据集划分为两个互斥的数据集，即训练集与测试集。具体的就是每隔10行选取一行作为测试集，余下的数据作为训练集，同时按照预测标签进行分组。\n# 每隔10行选取一行作为测试集，余下的数据作为训练集,按照预测标签进行分组testSet = data.iloc[::10,:]for index,row in testSet.iterrows():    data.drop(index=index,inplace=True)group = data.groupby('isLike')trainSet = [group.get_group('largeDoses'),group.get_group('smallDoses'),group.get_group('didntLike')]\n\n最后进行预测，画图即可。\n实验结果与思考完整代码如下：\nimport numpy as npimport pandas as pdfrom sklearn.preprocessing import MinMaxScalerimport matplotlib.pyplot as plt# 三维的KNN方法，该方法输入一个三维列向量，k值；输出该向量的类别def three_dimension_KNN(testData:np.matrix,k:int):    # 声明距离数组用于保存距离    distance = [[],[],[]]    posterior = []    # 对三种预测标签分别计算后验概率    for i in range(3):        # 对每类的数据集计算测试数据点与训练集中每个样本点的距离        for j in range(trainSet[i].shape[0]):            # 计算欧氏距离            d = np.sqrt((testData[0,0]-trainSet[i].iloc[j]['mileage'])**2 +                        (testData[1,0]-trainSet[i].iloc[j]['game'])**2 +                        (testData[2,0]-trainSet[i].iloc[j]['milk'])**2)            distance[i].append(d)        # 距离数组进行排序 提取出第k个数据        distance[i].sort()        V = 4 * np.pi * (distance[i][k - 1] ** 3) / 3        posterior.append(k/10/V)    print(\"概率密度数组：\"+str(posterior))    if posterior.index(max(posterior)) == 0:        return 'largeDoses'    elif posterior.index(max(posterior)) == 1:        return 'smallDoses'    else:        return 'didntLike'data = pd.DataFrame(columns=['mileage','game','milk','isLike'])# 读取文件with open('e2.txt','r') as f:    # 按行读取    content = f.readlines()    for line in content:        # 按照'\\t'分割        newLine = pd.Series(line.split('\\t'),index=['mileage','game','milk','isLike'])        # 去除预测标签末尾的'\\n'        newLine['isLike'] = newLine['isLike'].strip('\\n')        data = data.append(newLine,ignore_index=True)# 归一化features = data.iloc[:,0:3]features = MinMaxScaler().fit_transform(features)data.iloc[:,0:3] = features # 覆盖原来数据# 每隔10行选取一行作为测试集，余下的数据作为训练集,按照预测标签进行分组testSet = data.iloc[::10,:]for index,row in testSet.iterrows():    data.drop(index=index,inplace=True)group = data.groupby('isLike')trainSet = [group.get_group('largeDoses'),group.get_group('smallDoses'),group.get_group('didntLike')]# 进行预测T = 0 # 预测正确的个数F = 0 # 预测错误的个数forecast = []for index,row in testSet.iterrows():    columnVector = np.matrix([        [row[0]],        [row[1]],        [row[2]]    ])    forecast.append(three_dimension_KNN(columnVector,3))    if forecast[int(index/10)] == row[3]:        T+=1    else:        F+=1print(\"正确率:\"+str(T/(T+F)))# 给测试集添加预测标签列testSet['forecast'] =  forecast# 画图fig = plt.figure(figsize=(12, 6), facecolor='w')ax1 = plt.axes(projection='3d')ax1.legend(loc='best') # 添加图例ax1.scatter3D(trainSet[0]['mileage'],trainSet[0]['game'],trainSet[0]['milk'],c='r',label='largeDoses')ax1.scatter3D(trainSet[1]['mileage'],trainSet[1]['game'],trainSet[1]['milk'],c='y',label='smallDoses')ax1.scatter3D(trainSet[2]['mileage'],trainSet[2]['game'],trainSet[2]['milk'],c='b',label='didntLike')for index,row in testSet.iterrows():    if row[3] == row[4]:        ax1.scatter3D(row[0], row[1], row[2], c='g')    else:        ax1.scatter3D(row[0], row[1], row[2], c='k')ax1.set_xlabel('mileage')ax1.set_ylabel('game')ax1.set_zlabel('milk')plt.legend(loc='best')plt.show()\n\n\n当k=3时\n  \n\n​    \n图中绿色的点是预测正确的点，黑色的点是预测错误的点，其他颜色的点是训练集，可以看到在三种类别交汇的地方（决策边界处）有误判的出现。而在每种类别密集的地方基本没有误判的情况。\n","categories":["机器学习"],"tags":["机器学习","python"]},{"title":"JS深入学习(8)：bind的模拟实现","url":"/2022/01/22/JS-bind%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/","content":"bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。\nconst module = &#123;  x: 42,  getX: function() &#123;    return this.x;  &#125;&#125;;const unboundGetX = module.getX;console.log(unboundGetX()); // The function gets invoked at the global scope// expected output: undefinedconst boundGetX = unboundGetX.bind(module);console.log(boundGetX());// expected output: 42\n\n1 bind的基本实现由此我们可以首先得出 bind 函数的两个基本特点：\n\n返回一个函数：\n Function.prototype.bind2 = function (context) &#123;    var self = this;    return function () &#123;// 返回的函数        // 函数执行的内容，关于指定 this 的指向，我们可以使用 call 或者 apply 实现        return self.apply(context);    &#125;&#125;\n可以传入参数：函数在 bind 的时候，可以传参。在执行 bind 返回的函数的时候，同样可以传参\n 例子：\n var foo = &#123;    value: 1&#125;;function bar(name, age) &#123;    console.log(this.value);    console.log(name);    console.log(age);&#125;var bindFoo = bar.bind(foo, &#x27;daisy&#x27;);bindFoo(&#x27;18&#x27;);// 1// daisy// 18\n\n 因此我们分两次获取参数，在返回的函数中apply时传入两次获得参数的连接：\n Function.prototype.bind2 = function (context) &#123;    var self = this;    // 获取bind2函数从第二个参数到最后一个参数    var args = Array.prototype.slice.call(arguments, 1);    return function () &#123;        // 这个时候的arguments是指bind返回的函数传入的参数        var bindArgs = Array.prototype.slice.call(arguments);// arguments转数组        return self.apply(context, args.concat(bindArgs));    &#125;&#125;\n\n2 构造函数效果的模拟实现bind 还有一个进阶特点：一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。\n也就是说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子：\nvar value = 2;var foo = &#123;    value: 1&#125;;function bar() &#123;    this.habit = &#x27;shopping&#x27;;    console.log(this.value);&#125;bar.prototype.friend = &#x27;kevin&#x27;;var bindFoo = bar.bind(foo);var obj = new bindFoo();// undefinedconsole.log(obj.habit);console.log(obj.friend);// shopping// kevin\n\n尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了，这个时候的 this 已经指向了 obj。\n我们可以通过修改返回函数的原型，将其原型指向调用bind的函数的原型(bar)来实现继承绑定函数的原型中的值：\n// 第三版Function.prototype.bind2 = function (context) &#123;    var self = this;    var args = Array.prototype.slice.call(arguments, 1);    var fBound = function () &#123;        var bindArgs = Array.prototype.slice.call(arguments);        return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs));    &#125;    // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值    fBound.prototype = this.prototype;    return fBound;&#125;\n\n当fBound作为构造函数时，this 指向实例，this instanceof fBound结果为 true，将绑定函数的 this(=self) 指向该实例，可以让实例获得来自绑定函数的值。以上面的是 demo 为例，如果改成 this instanceof fBound ? null : context，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性。\n当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context。\n3 构造函数效果的优化实现在上面的写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转：\n// 第四版Function.prototype.bind2 = function (context) &#123;    var self = this;    var args = Array.prototype.slice.call(arguments, 1);    var fNOP = function () &#123;&#125;;    var fBound = function () &#123;        var bindArgs = Array.prototype.slice.call(arguments);        return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs));    &#125;    fNOP.prototype = this.prototype;    fBound.prototype = new fNOP();    return fBound;&#125;\n\n\n\n调用 bind 的必须是函数\nif (typeof this !== &quot;function&quot;) &#123;  throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);&#125;\n\n因此最终版本：\nFunction.prototype.bind2 = function (context) &#123;    if (typeof this !== &quot;function&quot;) &#123;      throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);    &#125;    var self = this;    var args = Array.prototype.slice.call(arguments, 1);    var fNOP = function () &#123;&#125;;    var fBound = function () &#123;        var bindArgs = Array.prototype.slice.call(arguments);        return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs));    &#125;    fNOP.prototype = this.prototype;    fBound.prototype = new fNOP();    return fBound;&#125;// 测试用例var value = 2;var foo = &#123;    value: 1&#125;;function bar(name, age) &#123;    this.habit = &#x27;shopping&#x27;;    console.log(this.value);    console.log(name);    console.log(age);&#125;bar.prototype.friend = &#x27;kevin&#x27;;console.log(bar.prototype)var bindFoo = bar.bind2(foo, &#x27;daisy&#x27;);var obj = new bindFoo(&#x27;18&#x27;);// undefined// daisy// 18console.log(obj.habit);console.log(obj.friend);// shopping// kevin\n\n参考【1】JavaScript深入之bind的模拟实现 · Issue #12 · mqyqingfeng/Blog (github.com)\n","categories":["JavaScript"],"tags":["JavaScript","前端","模拟实现"]},{"title":"JS深入学习(9)：new的模拟实现","url":"/2022/01/22/JS-new%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/","content":"new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一。举个例子：\nfunction Person(name,age) &#123;\tthis.name = name;\tthis.age = age;&#125;// 人固有的行为：睡觉Person.prototype.behavior = &#x27;sleep&#x27;;Person.prototype.sayYourName = function () &#123;    console.log(&#x27;I am &#x27; + this.name);&#125;var person = new Person(&#x27;Kevin&#x27;, &#x27;18&#x27;);console.log(person.name) // Kevinconsole.log(person.behavior) // sleepperson.sayYourName(); // I am Kevin\n\n实例 person 可以：\n\n访问到 Person 构造函数里的属性\n访问到 Person.prototype 中的属性\n\n因为 new 是关键字，所以无法像 bind 函数一样直接覆盖，所以我们写一个函数，命名为 objectFactory，来模拟 new 的效果。使用的时候是这样的：\nfunction Otaku () &#123;    ……&#125;// 使用 newvar person = new Person(……);// 使用 objectFactoryvar person = objectFactory(Person, ……)\n\n1 基本功能因为 new 的结果是一个新对象，所以在模拟实现的时候，我们也要建立一个新对象，假设这个对象叫 obj，因为 obj 会具有 Person 构造函数里的属性，想想经典继承的例子，我们可以使用 Person.apply(obj, arguments) 来给 obj 添加新的属性。\n在 JavaScript 深入系列第一篇中，我们便讲了原型与原型链，我们知道实例的__proto__属性会指向构造函数的 prototype，也正是因为建立起这样的关系，实例可以访问原型上的属性。\n// 第一版代码function objectFactory() &#123;\t// 新建的对象    var obj = new Object(),\t// 从参数中提取出构造函数，同时在参数中删除构造函数    Constructor = [].shift.call(arguments);\t// 将新建对象的原型指向构造函数的原型    obj.__proto__ = Constructor.prototype;\t// 调用构造函数，this指向新对象，参数为传入剩余参数    Constructor.apply(obj, arguments);\t// 返回obj    return obj;&#125;;\n\n进行测试：\nfunction Person(name,age) &#123;\tthis.name = name;\tthis.age = age;&#125;// 人固有的行为：睡觉Person.prototype.behavior = &#x27;sleep&#x27;;Person.prototype.sayYourName = function () &#123;    console.log(&#x27;I am &#x27; + this.name);&#125;// 第一版代码function objectFactory() &#123;\t// 新建的对象    var obj = new Object(),\t// 从参数中提取出构造函数，同时在参数中删除构造函数    Constructor = [].shift.call(arguments);\t// 将新建对象的原型指向构造函数的原型    obj.__proto__ = Constructor.prototype;\t// 调用构造函数，this指向新对象，参数为传入剩余参数    Constructor.apply(obj, arguments);\t// 返回obj    return obj;&#125;;var p1 = objectFactory(Person,&#x27;张三&#x27;,18);console.log(p1.name)console.log(p1.behavior)p1.sayYourName()\n\n\n\n2 构造函数返回值还要考虑构造函数的返回值的情况：\n\nConstructor返回一个对象，在实例 person 中只能访问返回的对象中的属性：\n  function Person (name, age) &#123;    this.strength = 60;    this.age = age;    return &#123;        name: name,        habit: &#x27;Games&#x27;    &#125;&#125;var person = new Person(&#x27;Kevin&#x27;, &#x27;18&#x27;);console.log(person.name) // Kevinconsole.log(person.habit) // Gamesconsole.log(person.strength) // undefinedconsole.log(person.age) // undefined\n\n  因此objectFactory的返回值应该是Constructor返回的一个对象\n\nConstructor返回一个基本类型，在实例 person 中只能访问this中的属性：\n  function Person (name, age) &#123;    this.strength = 60;    this.age = age;    return &#x27;handsome boy&#x27;;&#125;var person = new Person(&#x27;Kevin&#x27;, &#x27;18&#x27;);console.log(person.name) // undefinedconsole.log(person.habit) // undefinedconsole.log(person.strength) // 60console.log(person.age) // 18\n\n  因此objectFactory的返回值应该是obj\n\n\n最后的版本：\n// 第二版的代码function objectFactory() &#123;    var obj = new Object(),    Constructor = [].shift.call(arguments);    obj.__proto__ = Constructor.prototype;\t// 保存返回值    var ret = Constructor.apply(obj, arguments);\t// 判断返回值类型    return typeof ret === &#x27;object&#x27; ? ret : obj;&#125;;\n\n参考【1】JavaScript深入之new的模拟实现 · Issue #13 · mqyqingfeng/Blog (github.com)\n","categories":["JavaScript"],"tags":["JavaScript","前端","模拟实现"]},{"title":"JS深入学习(10)：Promise与异步的基础篇","url":"/2022/01/24/JS-Promise/","content":"1 同步与异步同步：对应内存中顺序执行的处理器指令。每条指令都会严格按照它们出现的顺序来执行，而每条指令执行后也能立即获得存储在系统本地（如寄存器或系统内存）的信息。\nlet x = 3;x = x + 4;\n\n异步：类似于系统中断，即当前进程外部的实体可以触发代码执行。异步操作经常是必要的，因为强制进程等待一个长时间的操作通常是不可行的（同步操作则必须要等）。如果代码要访问一些高延迟的资源，比如向远程服务器发送请求并等待响应，那么就会出现长时间的等待。\nlet x = 3;setTimeout(() =&gt; x = x + 4, 1000);\n\n为了让后续代码能够使用 x，异步执行的函数需要在更新 x 的值以后通知其他代码。如果程序不需要这个值，那么就只管继续执行，不必等待这个结果了。\nJavaScript是一种单线程事件循环模型。但是浏览器不是，只是执行JS代码的引擎是个单线程的所以JS的代码没办法开启多个线程，但是浏览器还有定时器线程、事件触发线程、异步http请求线程、GUI线程。\n在继续学习之前有必要介绍一下JS的定时器：\n **setTimeout()**方法设置一个定时器，该定时器在定时器到期后执行一个函数或指定的一段代码。\nvar timeoutID = setTimeout(function[, delay, arg1, arg2, ...]);\n\n\nfunction：function 是你想要在到期时间(delay毫秒)之后执行的函数。\ndelay 可选：延迟的毫秒数 (一秒等于1000毫秒)，函数的调用会在该延迟之后发生。如果省略该参数，delay取默认值0，意味着“马上”执行，或者尽快执行。不管是哪种情况，实际的延迟时间可能会比期待的(delay毫秒数) 值长\narg1, ..., argN 可选：附加参数，一旦定时器到期，它们会作为参数传递给function\n返回值timeoutID是一个正整数，表示定时器的编号。这个值可以传递给clearTimeout()来取消该定时器。\n需要注意的是setTimeout()和[setInterval()]共用一个编号池，技术上，clearTimeout()和 clearInterval() 可以互换。但是，为了避免混淆，不要混用取消定时函数。\n\nsetInterval() 方法重复调用一个函数或执行一个代码段，在每次调用之间具有固定的时间延迟。\nvar intervalID = scope.setInterval(func, delay, [arg1, arg2, ...]);\n\n示例程序：\nvar intervalID = window.setInterval(myCallback, 500, &#x27;Parameter 1&#x27;, &#x27;Parameter 2&#x27;);function myCallback(a, b)&#123; // Your code here // Parameters are purely optional.\tconsole.log(a); \tconsole.log(b);&#125;\n\n2 期约\n当你把一件事情交给别人去做（可能马上就能完成的也可能是需要一段时间的）这个人在任务完成或者失败后都会给你一个回应，这样你就会特别放心的把事情交给他，他没回应你那么他是正在办事、回应你了就是成功了或者失败了。在javascript中这样的人就是Promise。\n\nES6中新增的引用类型Promise，可以通过new 操作符来实例化。创建新期约时需要传入执行器（executor）函数作为参数。\nlet p = new Promise(() =&gt; &#123;&#125;);setTimeout(console.log, 0, p); // Promise &lt;pending&gt;\n\n2.1 期约基础2.1.1 期约状态机期约是一个有状态的对象，可能处于如下 3 种状态之一：\n\n待定（pending）\n最初始状态，待定状态下可以落定为代表成功的解决状态，或者失败的拒绝状态\n状态修改不可逆\n不能保证期约必然会脱离待定状态\n\n\n兑现（fulfilled，有时也称解决，resolved）\n拒绝（rejected）\n\n重要的是，期约的状态是私有的，不能直接通过JavaScript 检测到。这主要是为了避免根据读取到的期约状态，以同步方式处理期约对象。另外，期约的状态也不能被外部 JavaScript 代码修改。期约故意将异步行为封装起来，从而隔离外部的同步代码。\n2.1.2 执行器函数由于期约的状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。执行器函数主要有两项职责：\n\n初始化期约的异步行为\n\n控制状态的最终转换。执行函数有两个可选参数，分别代表两种的状态转换：\n\n调用resolve()会把状态切换为解决\n调用reject()会把状态切换为拒绝。也会抛出错误\n\n\n\nlet p1 = new Promise((resolve, reject) =&gt; resolve());//let p1 = Promise.resolve();setTimeout(console.log, 0, p1); // Promise &lt;resolved&gt;let p2 = new Promise((resolve, reject) =&gt; reject());//let p2 = Promise.reject();setTimeout(console.log, 0, p2); // Promise &lt;rejected&gt;// Uncaught error (in promise)\n\n无论resolve()和reject()中的哪个被调用，状态转换都不可撤销了。于是继续修改状态会静默失败，如下所示：\nlet p = new Promise((resolve, reject) =&gt; &#123;\tresolve();\treject(); // 没有效果&#125;);setTimeout(console.log, 0, p); // Promise &lt;resolved&gt;\n\n某些情况下，这个状态机就是期约可以提供的最有用的信息。知道一段异步代码已经完成，对于其他代码而言已经足够了。在另外一些情况下，期约封装的异步操作会实际生成某个值，而程序期待期约状态改变时可以访问这个值。相应地，如果期约被拒绝，程序就会期待期约状态改变时可以拿到拒绝的理由。\n为了支持这两种用例，每个期约只要状态切换为兑现，就会有一个私有的内部值（value）。类似地，每个期约只要状态切换为拒绝，就会有一个私有的内部理由（reason）。无论是值还是理由，都是包含原始值或对象的不可修改的引用。二者都是可选的，而且默认值为undefined。\n\n\n\n\nresolve()\nreject()\n\n\n\n作用\n状态切换为解决\n状态切换为拒绝。也会抛出错误\n\n\n第一参数\n解决的期约的值——value\n拒绝的期约的理由——reason\n\n\n第一参数是期约\n如果传入的参数本身是一个期约，那它的行为就类似于一个空包装。因此，Promise.resolve()可以说是一个幂等方法\n如果给它传一个期约对象，则这个期约会成为它返回的拒绝期约的理由\n\n\n幂等性\n有幂等性，保留传入期约的状态：\n无幂等性。如果给它传一个期约对象，则这个期约会成为它返回的拒绝期约的理由：\n\n\n返回值\n实例化一个解决的期约\n会实例化一个拒绝的期约\n\n\nsetTimeout(console.log, 0, Promise.resolve());// Promise &lt;resolved&gt;: undefinedsetTimeout(console.log, 0, Promise.resolve(3));// Promise &lt;resolved&gt;: 3// 多余的参数会忽略setTimeout(console.log, 0, Promise.resolve(4, 5, 6));// Promise &lt;resolved&gt;: 4let p = Promise.resolve(7);setTimeout(console.log, 0, p === Promise.resolve(p));// true\n\nlet p = Promise.reject(3);setTimeout(console.log, 0, p); // Promise &lt;rejected&gt;: 3setTimeout(console.log, 0, Promise.reject(Promise.resolve()));// Promise &lt;rejected&gt;: Promise &lt;resolved&gt;\n\n2.1.3 期约二元性对比包含了两种模式下抛出错误的情形：\ntry &#123;\tthrow new Error(&#x27;foo&#x27;);&#125; catch(e) &#123;\tconsole.log(e); // Error: foo&#125;try &#123;\tPromise.reject(new Error(&#x27;bar&#x27;));&#125; catch(e) &#123;\tconsole.log(e);&#125;// Uncaught (in promise) Error: bar\n\n第一个try/catch 抛出并捕获了错误，第二个try/catch 抛出错误却没有捕获到。\n这里的同步代码之所以没有捕获期约抛出的错误，是因为它没有通过异步模式捕获错误。从这里就可以看出期约真正的异步特性：它们是同步对象（在同步执行模式中使用），但也是异步执行模式的媒介。\n\n拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的。因此，try/catch 块并不能捕获该错误。代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步结构——更具体地说，就是期约的方法。\n\n2.2 期约方法2.2.1 Promise.prototype.then(value)是为期约实例添加处理程序的主要方法。这个then()方法接收最多两个参数：onResolved处理程序和onRejected处理程序。这两个参数都是可选的，如果提供的话，则会在期约分别进入“兑现”和“拒绝”状态时执行。\nfunction onResolved(id) &#123;\tsetTimeout(console.log, 0, id, &#x27;resolved&#x27;);&#125;function onRejected(id) &#123;\tsetTimeout(console.log, 0, id, &#x27;rejected&#x27;);&#125;let p1 = new Promise((resolve, reject) =&gt; setTimeout(resolve, 3000));let p2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 3000));p1.then(() =&gt; onResolved(&#x27;p1&#x27;),\t\t() =&gt; onRejected(&#x27;p1&#x27;));p2.then(() =&gt; onResolved(&#x27;p2&#x27;),\t\t() =&gt; onRejected(&#x27;p2&#x27;));//（3 秒后）// p1 resolved// p2 rejected// 非函数处理程序会被静默忽略，不推荐p1.then(&#x27;gobbeltygook&#x27;);// 不传onResolved 处理程序的规范写法p2.then(null, () =&gt; onRejected(&#x27;p2&#x27;));\n\n因为期约只能转换为最终状态一次，所以这两个操作一定是互斥的。\n当期约进入解决状态，Promise.prototype.then()方法返回一个新的期约实例，这个新期约实例基于onResovled处理程序的返回值构建，其返回值被Promise.resolve()包装后作为then()的返回值，根据onResovled处理程序的不同返回值：\n\n如果没有提供这个处理程序，则Promise.resolve()就会包装上一个期约解决之后的值。\n  let p1 = Promise.resolve(&#x27;foo&#x27;);// 若调用then()时不传处理程序，则原样向后传let p2 = p1.then();setTimeout(console.log, 0, p2); // Promise &lt;resolved&gt;: foo\n如果onResovled没有显式的返回语句，则Promise.resolve()会包装默认的返回值undefined。\n  // 没有显式返回语句 这些都一样let p3 = p1.then(() =&gt; undefined);let p4 = p1.then(() =&gt; &#123;&#125;);let p5 = p1.then(() =&gt; Promise.resolve());setTimeout(console.log, 0, p3); // Promise &lt;resolved&gt;: undefinedsetTimeout(console.log, 0, p4); // Promise &lt;resolved&gt;: undefinedsetTimeout(console.log, 0, p5); // Promise &lt;resolved&gt;: undefined\n如果有显式的返回值，则Promise.resolve()会包装这个值：\n  注意：当返回值是一个期约实例时，Promise.resolve()的幂等性保留传入的状态\n  // 如果有显式的返回值，则Promise.resolve()会包装这个值：let p6 = p1.then(() =&gt; &#x27;bar&#x27;);let p7 = p1.then(() =&gt; Promise.resolve(&#x27;bar&#x27;));// resolve的幂等性setTimeout(console.log, 0, p6); // Promise &lt;resolved&gt;: barsetTimeout(console.log, 0, p7); // Promise &lt;resolved&gt;: bar// Promise.resolve()的幂等性保留传入的状态let p8 = p1.then(() =&gt; new Promise(() =&gt; &#123;&#125;));let p9 = p1.then(() =&gt; Promise.reject());// Uncaught (in promise): undefinedsetTimeout(console.log, 0, p8); // Promise &lt;pending&gt;setTimeout(console.log, 0, p9); // Promise &lt;rejected&gt;: undefined\n抛出异常返回拒绝期约：\n  let p11 = p1.then(() =&gt; Error(&#x27;qux&#x27;));setTimeout(console.log, 0, p11); // Promise &lt;resolved&gt;: Error: qux\n\n当期约进入拒绝状态，onRejected 处理程序也与之类似：onRejected 处理程序返回的值也会被Promise.resolve()包装\n\n乍一看这可能有点违反直觉，但是想一想，onRejected 处理程序的任务不就是捕获异步错误吗？因此，拒绝处理程序在捕获错误后不抛出异常是符合期约的行为，应该返回一个解决期约。\n\n2.2.2 Promise.prototype.catch(reason)Promise.prototype.catch()方法用于给期约添加拒绝处理程序。这个方法只接收一个参数：onRejected 处理程序。事实上，这个方法就是一个语法糖，调用它就相当于调用Promise.prototype.then(null, onRejected)。\nlet p = Promise.reject();let onRejected = function(e) &#123;\tsetTimeout(console.log, 0, &#x27;rejected&#x27;);&#125;;// 这两种添加拒绝处理程序的方式是一样的：p.then(null, onRejected); // rejectedp.catch(onRejected); // rejecte\n\nPromise.prototype.catch()返回一个新的期约实例，在返回实例方面，其行为与Promise.prototype.then()的onRejected 处理程序是一样的。\nlet p1 = new Promise(() =&gt; &#123;&#125;);let p2 = p1.catch();setTimeout(console.log, 0, p1); // Promise &lt;pending&gt;setTimeout(console.log, 0, p2); // Promise &lt;pending&gt;setTimeout(console.log, 0, p1 === p2); // false\n\n2.2.3 Promise.prototype.finally()Promise.prototype.finally()方法用于给期约添加onFinally 处理程序，这个处理程序在期约转换为解决或拒绝状态时都会执行。这个方法可以避免 onResolved 和 onRejected 处理程序中出现冗余代码。但 onFinally 处理程序没有办法知道期约的状态是解决还是拒绝，所以这个方法主要用于添加清理代码。\nlet p1 = Promise.resolve();let p2 = Promise.reject();let onFinally = function() &#123;\tsetTimeout(console.log, 0, &#x27;Finally!&#x27;)&#125;p1.finally(onFinally); // Finallyp2.finally(onFinally); // Finally\n\nPromise.prototype.finally()方法返回一个新的期约实例，但不同于then()或catch()方式返回的实例。因为 onFinally 被设计为一个状态无关的方法，所以在大多数情况下它将表现为父期约的传递。\n\nonFinally返回值是已解决的期约或其他数据类型：父期约\nonFinally返回值是一个待定的期约，或者onFinally 处理程序抛出了错误（显式抛出或返回了一个拒绝期约），则会返回相应的期约（待定或拒绝）\n\nlet p1 = Promise.resolve(&#x27;foo&#x27;);// 这里都会原样后传let p2 = p1.finally();let p3 = p1.finally(() =&gt; undefined);let p4 = p1.finally(() =&gt; &#123;&#125;);let p5 = p1.finally(() =&gt; Promise.resolve());let p6 = p1.finally(() =&gt; &#x27;bar&#x27;);let p7 = p1.finally(() =&gt; Promise.resolve(&#x27;bar&#x27;));let p8 = p1.finally(() =&gt; Error(&#x27;qux&#x27;));// 返回一个待定的期约或抛出错误let p9 = p1.finally(() =&gt; new Promise(() =&gt; &#123;&#125;));let p10 = p1.finally(() =&gt; Promise.reject());let p11 = p1.finally(() =&gt; &#123; throw &#x27;baz&#x27;; &#125;);// Uncaught (in promise) bazsetTimeout(console.log, 0, p2); // Promise &lt;resolved&gt;: foosetTimeout(console.log, 0, p3); // Promise &lt;resolved&gt;: foosetTimeout(console.log, 0, p4); // Promise &lt;resolved&gt;: foosetTimeout(console.log, 0, p5); // Promise &lt;resolved&gt;: foosetTimeout(console.log, 0, p6); // Promise &lt;resolved&gt;: foosetTimeout(console.log, 0, p7); // Promise &lt;resolved&gt;: foosetTimeout(console.log, 0, p8); // Promise &lt;resolved&gt;: foo// Uncaught (in promise): undefinedsetTimeout(console.log, 0, p9); // Promise &lt;pending&gt;setTimeout(console.log, 0, p10); // Promise &lt;rejected&gt;: undefinedsetTimeout(console.log, 0, p11); // Promise &lt;rejected&gt;: baz\n\n2.3 非重入特性当期约进入解决或拒绝状态时，与该状态相关的处理程序仅仅会被排期，而非立即执行。跟在添加这个处理程序的代码之后的同步代码一定会在处理程序之前先执行。这个特性由JavaScript 运行时保证，被称为“非重入”（non-reentrancy）特性。\n非重入适用于 onResolved/onRejected 处理程序、catch()处理程序和 finally() 处理程序。\nlet p1 = Promise.resolve();p1.then(() =&gt; console.log(&#x27;p1.then() onResolved&#x27;));console.log(&#x27;p1.then() returns&#x27;);let p2 = Promise.reject();p2.then(null, () =&gt; console.log(&#x27;p2.then() onRejected&#x27;));console.log(&#x27;p2.then() returns&#x27;);let p3 = Promise.reject();p3.catch(() =&gt; console.log(&#x27;p3.catch() onRejected&#x27;));console.log(&#x27;p3.catch() returns&#x27;);let p4 = Promise.resolve();p4.finally(() =&gt; console.log(&#x27;p4.finally() onFinally&#x27;));console.log(&#x27;p4.finally() returns&#x27;);// p1.then() returns// p2.then() returns// p3.catch() returns// p4.finally() returns// p1.then() onResolved// p2.then() onRejected// p3.catch() onRejected// p4.finally() onFinally\n\n在这个例子中，在一个解决期约上调用 then() 会把 onResolved 处理程序推进消息队列。但这个处理程序在当前线程上的同步代码执行完成前不会执行。因此，跟在then()后面的同步代码一定先于处理程序执行。\n2.4 拒绝错误处理期约可以以任何理由拒绝，包括undefined，但最好统一使用错误对象。所有错误都是异步抛出且未处理的。\nlet p1 = new Promise((resolve, reject) =&gt; reject(Error(&#x27;foo&#x27;)));let p2 = new Promise((resolve, reject) =&gt; &#123; throw Error(&#x27;foo&#x27;); &#125;);let p3 = Promise.resolve().then(() =&gt; &#123; throw Error(&#x27;foo&#x27;); &#125;);let p4 = Promise.reject(Error(&#x27;foo&#x27;));setTimeout(console.log, 0, p1); // Promise &lt;rejected&gt;: Error: foosetTimeout(console.log, 0, p2); // Promise &lt;rejected&gt;: Error: foosetTimeout(console.log, 0, p3); // Promise &lt;rejected&gt;: Error: foosetTimeout(console.log, 0, p4); // Promise &lt;rejected&gt;: Error: foo\n\n正常情况下，在通过throw()关键字抛出错误时，JavaScript 运行时的错误处理机制会停止执行抛出错误之后的任何指令：\nthrow Error(&#x27;foo&#x27;);console.log(&#x27;bar&#x27;); // 这一行不会执行// Uncaught Error: foo\n\n但是，在期约中抛出错误时，因为错误实际上是从消息队列中异步抛出的，所以并不会阻止运行时继续执行同步指令：\nPromise.reject(Error(&#x27;foo&#x27;));console.log(&#x27;bar&#x27;);// bar// Uncaught (in promise) Error: foo\n\nthen()和catch()的onRejected 处理程序与try/catch的区别：\n\n异步错误只能通过异步的onRejected 处理程序捕获，不能通过同步的try/catch捕获：\n  // 正确Promise.reject(Error(&#x27;foo&#x27;)).catch((e) =&gt; &#123;&#125;);// 不正确try &#123;Promise.reject(Error(&#x27;foo&#x27;));&#125; catch(e) &#123;&#125;\n在解决或拒绝期约之前，仍然可以使用try/catch 在执行函数  中捕获错误：\n  let p = new Promise((resolve, reject) =&gt; &#123;\ttry &#123;\t\tthrow Error(&#x27;foo&#x27;);\t&#125; catch(e) &#123;&#125;\t\tresolve(&#x27;bar&#x27;);&#125;);setTimeout(console.log, 0, p); // Promise &lt;resolved&gt;: bar\nthen()和catch()的onRejected 处理程序在语义上相当于try/catch。出发点都是捕获错误之后将其隔离，同时不影响正常逻辑执行。为此，onRejected 处理程序的任务应该是在捕获异步错误之后返回一个解决的期约。下面的例子中对比了同步错误处理与异步错误处理：\n  console.log(&#x27;begin synchronous execution&#x27;);try &#123;\tthrow Error(&#x27;foo&#x27;);&#125; catch(e) &#123;\tconsole.log(&#x27;caught error&#x27;, e);&#125;console.log(&#x27;continue synchronous execution&#x27;);// begin synchronous execution// caught error Error: foo// continue synchronous executionnew Promise((resolve, reject) =&gt; &#123;\tconsole.log(&#x27;begin asynchronous execution&#x27;);\treject(Error(&#x27;bar&#x27;));&#125;).catch((e) =&gt; &#123;\tconsole.log(&#x27;caught error&#x27;, e);&#125;).then(() =&gt; &#123;\tconsole.log(&#x27;continue asynchronous execution&#x27;);&#125;);// begin asynchronous execution// caught error Error: bar// continue asynchronous execution\n\n2.5 期约连锁与期约合成多个期约组合在一起可以构成强大的代码逻辑。这种组合可以通过两种方式实现：\n\n期约连锁：一个期约接一个期约地拼接\n\n期约合成：将多个期约组合为一个期约。\n\n\n2.5.1 期约链锁因为每个期约实例的方法（then()、catch()和finally()）都会返回一个新的期约对象，而这个新期约又有自己的实例方法。\n实现串行化的异步任务，每个后续的处理程序都会等待前一个期约解决，然后实例化一个新期约并返回它。：\nlet p1 = new Promise((resolve, reject) =&gt; &#123;\tconsole.log(&#x27;p1 executor&#x27;);\tsetTimeout(resolve, 1000);&#125;);p1.then(() =&gt; new Promise((resolve, reject) =&gt; &#123;\tconsole.log(&#x27;p2 executor&#x27;);\tsetTimeout(resolve, 1000);&#125;)).then(() =&gt; new Promise((resolve, reject) =&gt; &#123;\tconsole.log(&#x27;p3 executor&#x27;);\tsetTimeout(resolve, 1000);&#125;)).then(() =&gt; new Promise((resolve, reject) =&gt; &#123;\tconsole.log(&#x27;p4 executor&#x27;);\tsetTimeout(resolve, 1000);&#125;));// p1 executor（1 秒后）// p2 executor（2 秒后）// p3 executor（3 秒后）// p4 executor（4 秒后）\n\n把生成期约的代码提取到一个工厂函数中：\nfunction delayedResolve(str) &#123;\treturn new Promise((resolve, reject) =&gt; &#123;\t\tconsole.log(str);\t\tsetTimeout(resolve, 1000);\t&#125;);&#125;delayedResolve(&#x27;p1 executor&#x27;)\t.then(() =&gt; delayedResolve(&#x27;p2 executor&#x27;))\t.then(() =&gt; delayedResolve(&#x27;p3 executor&#x27;))\t.then(() =&gt; delayedResolve(&#x27;p4 executor&#x27;))// p1 executor（1 秒后）// p2 executor（2 秒后）// p3 executor（3 秒后）// p4 executor（4 秒后）\n\n\n因为一个期约可以有任意多个处理程序，所以期约连锁可以构建有向非循环图的结构。这样，每个期约都是图中的一个节点，而使用实例方法添加的处理程序则是有向顶点。因为图中的每个节点都会等待前一个节点落定，所以图的方向就是期约的解决或拒绝顺序。\n//  A// / \\// B C// /\\ /\\//D E F Glet A = new Promise((resolve, reject) =&gt; &#123;\tconsole.log(&#x27;A&#x27;);\tresolve();&#125;);let B = A.then(() =&gt; console.log(&#x27;B&#x27;));let C = A.then(() =&gt; console.log(&#x27;C&#x27;));B.then(() =&gt; console.log(&#x27;D&#x27;));B.then(() =&gt; console.log(&#x27;E&#x27;));C.then(() =&gt; console.log(&#x27;F&#x27;));C.then(() =&gt; console.log(&#x27;G&#x27;));// A// B// C// D// E// F// G\n\n2.5.2 期约组合Promise 类提供两个将多个期约实例组合成一个期约的静态方法：Promise.all()和Promise.race()。而合成后期约的行为取决于内部期约的行为。\n2.5.2.1 Promise.all()这个静态方法必须接收一个可迭代对象，可迭代对象中的元素会通过Promise.resolve()转换为期约\n// 可迭代对象中的元素会通过Promise.resolve()转换为期约let p2 = Promise.all([3, 4]);// 空的可迭代对象等价于Promise.resolve()let p3 = Promise.all([]);\n\n合成的期约只会在每个包含的期约都解决之后才解决，如果所有期约都成功解决，则合成期约的解决值就是所有包含期约解决值的数组，按照迭代器顺序。\nlet p = Promise.all([\tPromise.resolve(3),\tPromise.resolve(),\tPromise.resolve(4)]);p.then((values) =&gt; setTimeout(console.log, 0, values)); // [3, undefined, 4]\n\n如果有一个包含的期约拒绝，则合成的期约也会拒绝。第一个拒绝的期约会将自己的理由作为合成期约的拒绝理由。之后再拒绝的期约不会影响最终期约的拒绝理由。不过，这并不影响所有包含期约正常的拒绝操作。合成的期约会静默处理所有包含期约的拒绝操作\n// 永远待定let p1 = Promise.all([new Promise(() =&gt; &#123;&#125;)]);setTimeout(console.log, 0, p1); // Promise &lt;pending&gt;// 一次拒绝会导致最终期约拒绝let p2 = Promise.all([\tPromise.resolve(),\tPromise.reject(),\tPromise.resolve()]);setTimeout(console.log, 0, p2); // Promise &lt;rejected&gt;// Uncaught (in promise) undefined// 虽然只有第一个期约的拒绝理由会进入// 拒绝处理程序，第二个期约的拒绝也// 会被静默处理，不会有错误跑掉let p = Promise.all([\tPromise.reject(3),\tnew Promise((resolve, reject) =&gt; setTimeout(reject, 1000))]);p.catch((reason) =&gt; setTimeout(console.log, 0, reason)); // 3// 没有未处理的错误\n\n2.5.2.2 Promise.race()Promise.race()静态方法返回一个包装期约，这个方法必须接收一个可迭代对象，是一组集合中最先解决或拒绝的期约的镜像。返回一个新期约\nPromise.race()不会对解决或拒绝的期约区别对待。无论是解决还是拒绝，只要是第一个落定的期约，Promise.race()就会包装其解决值或拒绝理由并返回新期约：\n// 解决先发生，超时后的拒绝被忽略let p1 = Promise.race([\tPromise.resolve(3),\tnew Promise((resolve, reject) =&gt; setTimeout(reject, 1000))]);setTimeout(console.log, 0, p1); // Promise &lt;resolved&gt;: 3// 拒绝先发生，超时后的解决被忽略let p2 = Promise.race([\tPromise.reject(4),\tnew Promise((resolve, reject) =&gt; setTimeout(resolve, 1000))]);setTimeout(console.log, 0, p2); // Promise &lt;rejected&gt;: 4// 迭代顺序决定了落定顺序let p3 = Promise.race([\tPromise.resolve(5),\tPromise.resolve(6),\tPromise.resolve(7)]);setTimeout(console.log, 0, p3); // Promise &lt;resolved&gt;: 5\n\n2.5.3 期约串行合成后续期约使用之前期约的返回值来串联期约是期约的基本功能。这很像函数合成，即将多个函数合成为一个函数。\nfunction addTwo(x) &#123;return x + 2;&#125;function addThree(x) &#123;return x + 3;&#125;function addFive(x) &#123;return x + 5;&#125;function addTen(x) &#123;return Promise.resolve(x)\t.then(addTwo)\t.then(addThree)\t.then(addFive);&#125;addTen(8).then(console.log); // 18\n\nArray.prototype.reduce(callbackfunc, initialValue)可以写成更简洁的形式：\nreduce() 方法对数组中的每个元素执行一个callback函数，将其结果汇总为单个返回值。initialvalue提供初始值：\narr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])\n\ncallback 函数接收4个参数:\n\nAccumulator (acc) (累计器)\nCurrent Value (cur) (当前值)\nCurrent Index (idx) (当前索引)\nSource Array (src) (源数组)\n\n callback 函数的返回值分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。\nfunction addTwo(x) &#123;return x + 2;&#125;function addThree(x) &#123;return x + 3;&#125;function addFive(x) &#123;return x + 5;&#125;function addTen(x) &#123;\treturn [addTwo, addThree, addFive]\t.reduce((promise, fn) =&gt; promise.then(fn),Promise.resolve(x));&#125;addTen(8).then(console.log); // 18\n\n这种模式可以提炼出一个通用函数，可以把任意多个函数作为处理程序合成一个连续传值的期约连锁。这个通用的合成函数可以这样实现：\nfunction addTwo(x) &#123;return x + 2;&#125;function addThree(x) &#123;return x + 3;&#125;function addFive(x) &#123;return x + 5;&#125;function compose(...fns) &#123;\treturn (x) =&gt; fns.reduce((promise, fn) =&gt; promise.then(fn), Promise.resolve(x))&#125;let addTen = compose(addTwo, addThree, addFive);addTen(8).then(console.log); // 18\n\n3 异步函数异步函数，也称为“async/await”（语法关键字）。async/await 是ES8 规范新增的。这个特性从行为和语法上都增强了JavaScript，让以同步方式写的代码能够异步执行。\n3.1 asyncasync 关键字用于声明异步函数。这个关键字可以用在函数声明、函数表达式、箭头函数和方法上。异步函数仍然具有普通JavaScript 函数的正常行为。但异步函数的返回值会被Promise.resolve()包装成一个期约对象。异步函数始终返回期约对象。在函数外部调用这个函数可以得到它返回的期约：\nasync function foo() &#123;\tconsole.log(1);\treturn 3;&#125;// 给返回的期约添加一个解决处理程序foo().then(console.log);console.log(2);// 1// 2// 3\n\n与在期约处理程序中一样，在异步函数中抛出错误会返回拒绝的期约：\nasync function foo() &#123;\tconsole.log(1);\tthrow 3;&#125;// 给返回的期约添加一个拒绝处理程序foo().catch(console.log);console.log(2);// 1// 2// 3\n\n拒绝期约的错误不会被异步函数捕获：\nasync function foo() &#123;\tconsole.log(1);\tPromise.reject(3);&#125;// Attach a rejected handler to the returned promisefoo().catch(console.log);console.log(2);// 1// 2// Uncaught (in promise): 3\n\n3.2 await异步函数主要针对不会马上完成的任务，自然需要一种暂停和恢复执行的能力。\n使用await关键字暂停执行异步函数后面的代码，让出JavaScript 运行时的执行线程。这个行为与生成器函数中的 yield 关键字是一样的。await 关键字同样是尝试“解包”对象的值，然后将这个值传给表达式，再异步恢复异步函数的执行。\nasync function foo() &#123;    let p = new Promise((resolve, reject) =&gt; setTimeout(resolve, 2000, 3));    console.log(await p);    console.log(`finish`)&#125;foo();// 3// finish\n\n这个例子中，await之后的代码，包括打印p都会暂停，等到2s后的某一时刻p的状态变为解决时再继续打印。\nawait 关键字等待的对象有两种情况：\n\n实现thenable接口：则这个对象可以由await 来“解包”（提取出期约中的value或reason）。\n没有实现thenable接口：被当作已经解决的期约。\n\n等待会抛出错误的同步操作，会返回拒绝的期约：\nasync function foo() &#123;\tconsole.log(1);\tawait (() =&gt; &#123; throw 3; &#125;)();&#125;// 给返回的期约添加一个拒绝处理程序foo().catch(console.log);console.log(2);// 1// 2// 3\n\n对拒绝的期约使用await 则会释放（unwrap）错误值（将拒绝期约返回）同时终止异步函数：\nasync function foo() &#123;\tconsole.log(1);\tawait Promise.reject(3);\tconsole.log(4); // 这行代码不会执行&#125;// 给返回的期约添加一个拒绝处理程序foo().catch(console.log);console.log(2);// 1// 2// 3\n\nawait限制：\n\nawait 关键字必须在异步函数中使用\n此外，异步函数的特质不会扩展到嵌套函数。因此，await 关键字也只能直接出现在异步函数的定义中。\n\n3.3 异步函数应用3.3.1 实现sleep()如果想要实现类似Java 中Thread.sleep()之类的函数以前，这个需求基本上都通过setTimeout()利用JavaScript 运行时的行为来实现的。\n有了异步函数之后，就不一样了。一个简单的箭头函数就可以实现sleep()：\nasync function sleep(delay) &#123;\treturn new Promise((resolve) =&gt; setTimeout(resolve, delay));&#125;async function foo() &#123;\tconst t0 = Date.now();\tawait sleep(1500); // 暂停约1500 毫秒\tconsole.log(Date.now() - t0);&#125;foo();// 1502\n\n3.3.2 平行加速以下面这个例子导入，其中顺序等待了5个随机的超时：\nasync function randomDelay(id) &#123;\t// 延迟0~1000 毫秒\tconst delay = Math.random() * 1000;\treturn new Promise((resolve) =&gt; setTimeout(() =&gt; &#123;\t\tconsole.log(`$&#123;id&#125; finished`);\t\tresolve();\t&#125;, delay));&#125;async function foo() &#123;\tconst t0 = Date.now();    const t0 = Date.now();\tfor (let i = 0; i &lt; 5; ++i) &#123;\t\tawait randomDelay(i);\t&#125;\tconsole.log(`$&#123;Date.now() - t0&#125;ms elapsed`);&#125;foo();// 0 finished// 1 finished// 2 finished// 3 finished// 4 finished// 877ms elapsed\n\n就算这些期约之间没有依赖，异步函数也会依次暂停，等待每个超时完成。这样可以保证执行顺序，但总执行时间会变长。\n如果顺序不是必需保证的，那么可以先一次性初始化所有期约，然后再分别等待它们的结果。比如：\nasync function randomDelay(id) &#123;// 延迟0~1000 毫秒\tconst delay = Math.random() * 1000;\treturn new Promise((resolve) =&gt; setTimeout(() =&gt; &#123;\t\tconsole.log(`$&#123;id&#125; finished`);\t\tresolve(id);\t&#125;, delay));&#125;async function foo() &#123;\tconst t0 = Date.now();    // map(callback(数组当前元素(必须),index,arr)) 第一个形参没有用但是要有\tconst promises = Array(5).fill(null).map((_, i) =&gt; randomDelay(i));\tfor (const p of promises) &#123;\t\tconsole.log(`awaited $&#123;await p&#125;`);\t&#125;\tconsole.log(`$&#123;Date.now() - t0&#125;ms elapsed`);&#125;foo();// 3 finished// 0 finished// awaited 0// 4 finished// 1 finished// awaited 1// 2 finished// awaited 2// awaited 3// awaited 4// 691ms elapsed\n\n虽然期约没有按照顺序执行，但await 按顺序收到了每个期约的值\n","categories":["JavaScript"],"tags":["JavaScript","前端"]}]